define("sweet", [], function() { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.expand = expand;
	exports.parse = parse;
	exports.compile = compile;

	var _shiftReader = __webpack_require__(1);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _expander = __webpack_require__(29);

	var _expander2 = _interopRequireDefault(_expander);

	var _immutable = __webpack_require__(9);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _env = __webpack_require__(50);

	var _env2 = _interopRequireDefault(_env);

	var _shiftReducer = __webpack_require__(34);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _parseReducer = __webpack_require__(52);

	var _parseReducer2 = _interopRequireDefault(_parseReducer);

	var _shiftCodegen = __webpack_require__(53);

	var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

	var _scope = __webpack_require__(31);

	var _bindingMap = __webpack_require__(13);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _symbol = __webpack_require__(11);

	var _modules = __webpack_require__(59);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function expand(source) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  var reader = new _shiftReader2.default(source);
	  var stxl = reader.read();
	  var scope = (0, _scope.freshScope)('top');
	  var bindings = new _bindingMap2.default();
	  var expander = new _expander2.default({
	    env: new _env2.default(),
	    store: new _env2.default(),
	    bindings: bindings,
	    cwd: options.cwd,
	    modules: new _modules.Modules(),
	    currentScope: [scope],
	    transform: options.transform ? options.transform : function (x) {
	      return { code: x };
	    },
	    followImports: options.followImports,
	    moduleResolver: options.moduleResolver,
	    moduleLoader: options.moduleLoader
	  });
	  var exStxl = expander.expand(stxl.map(function (s) {
	    return s.addScope(scope, bindings);
	  }));
	  return new _terms2.default("Module", {
	    directives: (0, _immutable.List)(),
	    items: exStxl
	  });
	}

	function parse(source) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  return (0, _shiftReducer2.default)(new _parseReducer2.default(), expand(source, options));
	}

	function compile(source, cwd, _ref) {
	  var transform = _ref.transform;

	  var ast = parse(source, {
	    cwd: cwd,
	    transform: transform
	  });
	  var gen = (0, _shiftCodegen2.default)(ast);
	  return transform ? transform(gen) : { code: gen };
	}
	//# sourceMappingURL=sweet.js.map


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _tokenizer = __webpack_require__(2);

	var _tokenizer2 = _interopRequireDefault(_tokenizer);

	var _immutable = __webpack_require__(9);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _ramda = __webpack_require__(26);

	var R = _interopRequireWildcard(_ramda);

	var _ramdaFantasy = __webpack_require__(14);

	var _errors = __webpack_require__(12);

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Just = _ramdaFantasy.Maybe.Just;
	var Nothing = _ramdaFantasy.Maybe.Nothing;


	var LSYNTAX = { name: 'left-syntax' };
	var RSYNTAX = { name: 'right-syntax' };

	// TODO: also, need to handle contextual yield
	var literalKeywords = ['this', 'null', 'true', 'false'];

	// Token -> Boolean
	var isLeftBracket = R.whereEq({ type: _tokenizer.TokenType.LBRACK });
	var isLeftBrace = R.whereEq({ type: _tokenizer.TokenType.LBRACE });
	var isLeftParen = R.whereEq({ type: _tokenizer.TokenType.LPAREN });
	var isRightBracket = R.whereEq({ type: _tokenizer.TokenType.RBRACK });
	var isRightBrace = R.whereEq({ type: _tokenizer.TokenType.RBRACE });
	var isRightParen = R.whereEq({ type: _tokenizer.TokenType.RPAREN });

	var isEOS = R.whereEq({ type: _tokenizer.TokenType.EOS });

	var isHash = R.whereEq({ type: _tokenizer.TokenType.IDENTIFIER, value: '#' });
	var isLeftSyntax = R.whereEq({ type: LSYNTAX });
	var isRightSyntax = R.whereEq({ type: RSYNTAX });

	var isLeftDelimiter = R.anyPass([isLeftBracket, isLeftBrace, isLeftParen, isLeftSyntax]);

	var isRightDelimiter = R.anyPass([isRightBracket, isRightBrace, isRightParen, isRightSyntax]);

	var isMatchingDelimiters = R.cond([[isLeftBracket, function (_, b) {
	  return isRightBracket(b);
	}], [isLeftBrace, function (_, b) {
	  return isRightBrace(b);
	}], [isLeftParen, function (_, b) {
	  return isRightParen(b);
	}], [isLeftSyntax, function (_, b) {
	  return isRightSyntax(b);
	}], [R.T, R.F]]);

	var assignOps = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ","];

	var binaryOps = ["+", "-", "*", "/", "%", "<<", ">>", ">>>", "&", "|", "^", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==", "instanceof"];

	var unaryOps = ["++", "--", "~", "!", "delete", "void", "typeof", "yield", "throw", "new"];

	// List -> Boolean
	var isEmpty = R.whereEq({ size: 0 });

	// Syntax -> Boolean
	var isPunctuator = function isPunctuator(s) {
	  return s.isPunctuator();
	};
	var isKeyword = function isKeyword(s) {
	  return s.isKeyword();
	};
	var isDelimiter = function isDelimiter(s) {
	  return s.isDelimiter();
	};
	var isParens = function isParens(s) {
	  return s.isParens();
	};
	var isBraces = function isBraces(s) {
	  return s.isBraces();
	};
	var isBrackets = function isBrackets(s) {
	  return s.isBrackets();
	};
	var isIdentifier = function isIdentifier(s) {
	  return s.isIdentifier();
	};

	// Syntax -> any
	var val = function val(s) {
	  return s.val();
	};
	// Any -> Syntax -> Boolean
	var isVal = R.curry(function (v, s) {
	  return s.val() === v;
	});

	// Syntax -> Boolean
	var isDot = R.allPass([isPunctuator, isVal('.')]);
	var isColon = R.allPass([isPunctuator, isVal(':')]);
	var isFunctionKeyword = R.allPass([isKeyword, isVal('function')]);
	var isOperator = function isOperator(s) {
	  return (s.isPunctuator() || s.isKeyword()) && R.any(R.equals(s.val()), assignOps.concat(binaryOps).concat(unaryOps));
	};
	var isNonLiteralKeyword = R.allPass([isKeyword, function (s) {
	  return R.none(R.equals(s.val()), literalKeywords);
	}]);
	var isKeywordExprPrefix = R.allPass([isKeyword, function (s) {
	  return R.any(R.equals(s.val()), ['instanceof', 'typeof', 'delete', 'void', 'yield', 'throw', 'new', 'case']);
	}]);
	// List a -> a?
	var last = function last(p) {
	  return p.last();
	};
	// List a -> Maybe a
	var safeLast = R.pipe(R.cond([[isEmpty, R.always(Nothing())], [R.T, R.compose(_ramdaFantasy.Maybe.of, last)]]));

	// TODO: better name
	// List -> Boolean -> Maybe List
	var stuffTrue = R.curry(function (p, b) {
	  return b ? Just(p) : Nothing();
	});
	var stuffFalse = R.curry(function (p, b) {
	  return !b ? Just(p) : Nothing();
	});

	// List a -> Boolean
	var isTopColon = R.pipe(safeLast, R.map(isColon), _ramdaFantasy.Maybe.maybe(false, R.identity));
	// List a -> Boolean
	var isTopPunctuator = R.pipe(safeLast, R.map(isPunctuator), _ramdaFantasy.Maybe.maybe(false, R.identity));

	// Number -> List -> Boolean
	var isExprReturn = R.curry(function (l, p) {
	  var retKwd = safeLast(p);
	  var maybeDot = pop(p).chain(safeLast);

	  if (maybeDot.map(isDot).getOrElse(false)) {
	    return true;
	  }
	  return retKwd.map(function (s) {
	    return s.isKeyword() && s.val() === 'return' && s.lineNumber() === l;
	  }).getOrElse(false);
	});

	var isTopOperator = R.pipe(safeLast, R.map(isOperator), _ramdaFantasy.Maybe.maybe(false, R.identity));

	var isTopKeywordExprPrefix = R.pipe(safeLast, R.map(isKeywordExprPrefix), _ramdaFantasy.Maybe.maybe(false, R.identity));

	// Number -> Boolean -> List -> Boolean
	var isExprPrefix = R.curry(function (l, b) {
	  return R.cond([
	  // ... ({x: 42} /r/i)
	  [isEmpty, R.always(b)],
	  // ... ({x: {x: 42} /r/i })
	  [isTopColon, R.always(b)],
	  // ... throw {x: 42} /r/i
	  [isTopKeywordExprPrefix, R.T],
	  // ... 42 + {x: 42} /r/i
	  [isTopOperator, R.T],
	  // ... for ( ; {x: 42}/r/i)
	  [isTopPunctuator, R.always(b)],
	  // ... return {x: 42} /r /i
	  // ... return\n{x: 42} /r /i
	  [isExprReturn(l), R.T], [R.T, R.F]]);
	});

	// List a -> Maybe List a
	var curly = function curly(p) {
	  return safeLast(p).map(isBraces).chain(stuffTrue(p));
	};
	var paren = function paren(p) {
	  return safeLast(p).map(isParens).chain(stuffTrue(p));
	};
	var func = function func(p) {
	  return safeLast(p).map(isFunctionKeyword).chain(stuffTrue(p));
	};
	var ident = function ident(p) {
	  return safeLast(p).map(isIdentifier).chain(stuffTrue(p));
	};
	var nonLiteralKeyword = function nonLiteralKeyword(p) {
	  return safeLast(p).map(isNonLiteralKeyword).chain(stuffTrue(p));
	};

	var opt = R.curry(function (a, b, p) {
	  var result = R.pipeK(a, b)(_ramdaFantasy.Maybe.of(p));
	  return _ramdaFantasy.Maybe.isJust(result) ? result : _ramdaFantasy.Maybe.of(p);
	});

	var notDot = R.ifElse(R.whereEq({ size: 0 }), Just, function (p) {
	  return safeLast(p).map(function (s) {
	    return !(s.isPunctuator() && s.val() === '.');
	  }).chain(stuffTrue(p));
	});

	// List a -> Maybe List a
	var pop = R.compose(Just, function (p) {
	  return p.pop();
	});

	// Maybe List a -> Maybe List a
	var functionPrefix = R.pipeK(curly, pop, paren, pop, opt(ident, pop), func);

	// Boolean -> List a -> Boolean
	var isRegexPrefix = function isRegexPrefix(b) {
	  return R.anyPass([
	  // ε
	  isEmpty,
	  // P . t   where t ∈ Punctuator
	  isTopPunctuator,
	  // P . t . t'  where t \not = "." and t' ∈ (Keyword \setminus  LiteralKeyword)
	  R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
	  // P . t . t' . (T)  where t \not = "." and t' ∈ (Keyword \setminus LiteralKeyword)
	  R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(paren, pop, nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
	  // P . function^l . x? . () . {}     where isExprPrefix(P, b, l) = false
	  R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, R.chain(function (p) {
	    return safeLast(p).map(function (s) {
	      return s.lineNumber();
	    }).chain(function (fnLine) {
	      return pop(p).map(isExprPrefix(fnLine, b));
	    }).chain(stuffFalse(p));
	  }), _ramdaFantasy.Maybe.isJust),
	  // P . {T}^l  where isExprPrefix(P, b, l) = false
	  function (p) {
	    var isCurly = _ramdaFantasy.Maybe.isJust(safeLast(p).map(isBraces));
	    var alreadyCheckedFunction = R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, _ramdaFantasy.Maybe.isJust)(p);
	    if (alreadyCheckedFunction) {
	      return false;
	    }
	    return R.pipe(_ramdaFantasy.Maybe.of, R.chain(curly), R.chain(function (p) {
	      return safeLast(p).map(function (s) {
	        return s.lineNumber();
	      }).chain(function (curlyLine) {
	        return pop(p).map(isExprPrefix(curlyLine, b));
	      }).chain(stuffFalse(p));
	    }), _ramdaFantasy.Maybe.isJust)(p);
	  }]);
	};

	function lastEl(l) {
	  return l[l.length - 1];
	}

	var Reader = function (_Tokenizer) {
	  _inherits(Reader, _Tokenizer);

	  function Reader(strings, context, replacements) {
	    _classCallCheck(this, Reader);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Reader).call(this, Array.isArray(strings) ? strings.join('') : strings));

	    _this.delimStack = new Map();
	    _this.insideSyntaxTemplate = [false];
	    _this.context = context;

	    // setup splicing replacement array
	    if (Array.isArray(strings)) {
	      (function () {
	        var totalIndex = 0;
	        _this.replacementIndex = R.reduce(function (acc, strRep) {
	          acc.push({
	            index: totalIndex + strRep[0].length,
	            replacement: strRep[1]
	          });
	          totalIndex += strRep[0].length;
	          return acc;
	        }, [], R.zip(strings, replacements));
	      })();
	    }
	    return _this;
	  }

	  _createClass(Reader, [{
	    key: "read",
	    value: function read() {
	      var stack = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	      var b = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	      var singleDelimiter = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	      var prefix = (0, _immutable.List)();
	      while (true) {
	        var tok = this.advance(prefix, b);

	        // splicing allows syntax and terms
	        if (tok instanceof _syntax2.default || tok instanceof _terms2.default) {
	          stack.push(tok);
	          continue;
	        }
	        if (Array.isArray(tok)) {
	          Array.prototype.push.apply(stack, tok);
	          continue;
	        }
	        if (_immutable.List.isList(tok)) {
	          Array.prototype.push.apply(stack, tok.toArray());
	          continue;
	        }

	        if (isEOS(tok)) {
	          if (stack[0] && isLeftDelimiter(stack[0].token)) {
	            throw this.createUnexpected(tok);
	          }
	          break;
	        }

	        if (isLeftDelimiter(tok)) {
	          if (isLeftSyntax(tok)) {
	            this.insideSyntaxTemplate.push(true);
	          }
	          var line = tok.slice.startLocation.line;
	          var innerB = isLeftBrace(tok) ? isExprPrefix(line, b)(prefix) : true;
	          var inner = this.read([new _syntax2.default(tok)], innerB, false);
	          var stx = new _syntax2.default(inner, this.context);
	          prefix = prefix.concat(stx);
	          stack.push(stx);
	          if (singleDelimiter) {
	            break;
	          }
	        } else if (isRightDelimiter(tok)) {
	          if (stack[0] && !isMatchingDelimiters(stack[0].token, tok)) {
	            throw this.createUnexpected(tok);
	          }
	          var stx = new _syntax2.default(tok, this.context);
	          stack.push(stx);
	          if (lastEl(this.insideSyntaxTemplate) && isRightSyntax(tok)) {
	            this.insideSyntaxTemplate.pop();
	          }
	          break;
	        } else {
	          var stx = new _syntax2.default(tok, this.context);
	          prefix = prefix.concat(stx);
	          stack.push(stx);
	        }
	      }
	      return (0, _immutable.List)(stack);
	    }
	  }, {
	    key: "advance",
	    value: function advance(prefix, b) /*: any */{
	      var startLocation = this.getLocation();

	      this.lastIndex = this.index;
	      this.lastLine = this.line;
	      this.lastLineStart = this.lineStart;

	      this.skipComment();

	      this.startIndex = this.index;
	      this.startLine = this.line;
	      this.startLineStart = this.lineStart;

	      if (this.replacementIndex && this.replacementIndex[0] && this.index >= this.replacementIndex[0].index) {
	        var rep = this.replacementIndex[0].replacement;
	        this.replacementIndex.shift();
	        return rep;
	      }

	      var charCode = this.source.charCodeAt(this.index);

	      if (charCode === 0x60) {
	        // `
	        var element = undefined,
	            items = [];
	        var _startLocation = this.getLocation();
	        var start = this.index;
	        this.index++;
	        if (lastEl(this.insideSyntaxTemplate)) {

	          var slice = this.getSlice(start, _startLocation);
	          return {
	            type: RSYNTAX,
	            value: '`',
	            slice: slice
	          };
	        }
	        do {
	          element = this.scanTemplateElement();
	          items.push(element);
	          if (element.interp) {
	            // only read the single delimiter
	            element = this.read([], false, true);
	            (0, _errors.assert)(element.size === 1, "should only have read a single delimiter inside a template");
	            items.push(element.get(0));
	          }
	        } while (!element.tail);
	        return {
	          type: _tokenizer.TokenType.TEMPLATE,
	          items: (0, _immutable.List)(items)
	        };
	      } else if (charCode === 35) {
	        // #
	        var _startLocation2 = this.getLocation();
	        var start = this.index;
	        var slice = this.getSlice(start, _startLocation2);
	        this.index++;
	        // TODO: handle ` inside of syntax template interpolations
	        if (this.source.charCodeAt(this.index) === 0x60) {
	          // `
	          this.index++;
	          return {
	            type: LSYNTAX,
	            value: '#`',
	            slice: slice
	          };
	        }
	        return {
	          type: _tokenizer.TokenType.IDENTIFIER,
	          value: '#',
	          slice: slice
	        };
	      }

	      var lookahead = _get(Object.getPrototypeOf(Reader.prototype), "advance", this).call(this);
	      if (lookahead.type === _tokenizer.TokenType.DIV && isRegexPrefix(b)(prefix)) {
	        return _get(Object.getPrototypeOf(Reader.prototype), "scanRegExp", this).call(this, "/");
	      }
	      return lookahead;
	    }

	    // need to override how templates are lexed because of delimiters

	  }, {
	    key: "scanTemplateElement",
	    value: function scanTemplateElement() {
	      var startLocation = this.getLocation();
	      var start = this.index;
	      while (this.index < this.source.length) {
	        var ch = this.source.charCodeAt(this.index);
	        switch (ch) {
	          case 0x60:
	            // `
	            // don't include the traling "`"
	            var slice = this.getSlice(start, startLocation);
	            this.index++;
	            return {
	              type: _tokenizer.TokenType.TEMPLATE,
	              tail: true,
	              interp: false,
	              slice: slice
	            };
	          case 0x24:
	            // $
	            if (this.source.charCodeAt(this.index + 1) === 0x7B) {
	              // {
	              // don't include the trailing "$"
	              var _slice = this.getSlice(start, startLocation);
	              this.index += 1;
	              return {
	                type: _tokenizer.TokenType.TEMPLATE,
	                tail: false,
	                interp: true,
	                slice: _slice
	              };
	            }
	            this.index++;
	            break;
	          case 0x5C:
	            // \\
	            {
	              var octal = this.scanStringEscape("", null)[1];
	              if (octal != null) {
	                throw this.createILLEGAL();
	              }
	              break;
	            }
	          default:
	            this.index++;
	        }
	      }

	      throw this.createILLEGAL();
	    }
	  }]);

	  return Reader;
	}(_tokenizer2.default);

	exports.default = Reader;
	//# sourceMappingURL=shift-reader.js.map


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.JsError = exports.TokenType = exports.TokenClass = undefined;

	var _utils = __webpack_require__(3);

	var _errors = __webpack_require__(8);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var TokenClass = exports.TokenClass = {
	  Eof: { name: "<End>" },
	  Ident: { name: "Identifier", isIdentifierName: true },
	  Keyword: { name: "Keyword", isIdentifierName: true },
	  NumericLiteral: { name: "Numeric" },
	  TemplateElement: { name: "Template" },
	  Punctuator: { name: "Punctuator" },
	  StringLiteral: { name: "String" },
	  RegularExpression: { name: "RegularExpression" },
	  Illegal: { name: "Illegal" }
	};

	var TokenType = exports.TokenType = {
	  EOS: { klass: TokenClass.Eof, name: "EOS" },
	  LPAREN: { klass: TokenClass.Punctuator, name: "(" },
	  RPAREN: { klass: TokenClass.Punctuator, name: ")" },
	  LBRACK: { klass: TokenClass.Punctuator, name: "[" },
	  RBRACK: { klass: TokenClass.Punctuator, name: "]" },
	  LBRACE: { klass: TokenClass.Punctuator, name: "{" },
	  RBRACE: { klass: TokenClass.Punctuator, name: "}" },
	  COLON: { klass: TokenClass.Punctuator, name: ":" },
	  SEMICOLON: { klass: TokenClass.Punctuator, name: ";" },
	  PERIOD: { klass: TokenClass.Punctuator, name: "." },
	  ELLIPSIS: { klass: TokenClass.Punctuator, name: "..." },
	  ARROW: { klass: TokenClass.Punctuator, name: "=>" },
	  CONDITIONAL: { klass: TokenClass.Punctuator, name: "?" },
	  INC: { klass: TokenClass.Punctuator, name: "++" },
	  DEC: { klass: TokenClass.Punctuator, name: "--" },
	  ASSIGN: { klass: TokenClass.Punctuator, name: "=" },
	  ASSIGN_BIT_OR: { klass: TokenClass.Punctuator, name: "|=" },
	  ASSIGN_BIT_XOR: { klass: TokenClass.Punctuator, name: "^=" },
	  ASSIGN_BIT_AND: { klass: TokenClass.Punctuator, name: "&=" },
	  ASSIGN_SHL: { klass: TokenClass.Punctuator, name: "<<=" },
	  ASSIGN_SHR: { klass: TokenClass.Punctuator, name: ">>=" },
	  ASSIGN_SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>=" },
	  ASSIGN_ADD: { klass: TokenClass.Punctuator, name: "+=" },
	  ASSIGN_SUB: { klass: TokenClass.Punctuator, name: "-=" },
	  ASSIGN_MUL: { klass: TokenClass.Punctuator, name: "*=" },
	  ASSIGN_DIV: { klass: TokenClass.Punctuator, name: "/=" },
	  ASSIGN_MOD: { klass: TokenClass.Punctuator, name: "%=" },
	  COMMA: { klass: TokenClass.Punctuator, name: "," },
	  OR: { klass: TokenClass.Punctuator, name: "||" },
	  AND: { klass: TokenClass.Punctuator, name: "&&" },
	  BIT_OR: { klass: TokenClass.Punctuator, name: "|" },
	  BIT_XOR: { klass: TokenClass.Punctuator, name: "^" },
	  BIT_AND: { klass: TokenClass.Punctuator, name: "&" },
	  SHL: { klass: TokenClass.Punctuator, name: "<<" },
	  SHR: { klass: TokenClass.Punctuator, name: ">>" },
	  SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>" },
	  ADD: { klass: TokenClass.Punctuator, name: "+" },
	  SUB: { klass: TokenClass.Punctuator, name: "-" },
	  MUL: { klass: TokenClass.Punctuator, name: "*" },
	  DIV: { klass: TokenClass.Punctuator, name: "/" },
	  MOD: { klass: TokenClass.Punctuator, name: "%" },
	  EQ: { klass: TokenClass.Punctuator, name: "==" },
	  NE: { klass: TokenClass.Punctuator, name: "!=" },
	  EQ_STRICT: { klass: TokenClass.Punctuator, name: "===" },
	  NE_STRICT: { klass: TokenClass.Punctuator, name: "!==" },
	  LT: { klass: TokenClass.Punctuator, name: "<" },
	  GT: { klass: TokenClass.Punctuator, name: ">" },
	  LTE: { klass: TokenClass.Punctuator, name: "<=" },
	  GTE: { klass: TokenClass.Punctuator, name: ">=" },
	  INSTANCEOF: { klass: TokenClass.Keyword, name: "instanceof" },
	  IN: { klass: TokenClass.Keyword, name: "in" },
	  NOT: { klass: TokenClass.Punctuator, name: "!" },
	  BIT_NOT: { klass: TokenClass.Punctuator, name: "~" },
	  AWAIT: { klass: TokenClass.Keyword, name: "await" },
	  DELETE: { klass: TokenClass.Keyword, name: "delete" },
	  TYPEOF: { klass: TokenClass.Keyword, name: "typeof" },
	  VOID: { klass: TokenClass.Keyword, name: "void" },
	  BREAK: { klass: TokenClass.Keyword, name: "break" },
	  CASE: { klass: TokenClass.Keyword, name: "case" },
	  CATCH: { klass: TokenClass.Keyword, name: "catch" },
	  CLASS: { klass: TokenClass.Keyword, name: "class" },
	  CONTINUE: { klass: TokenClass.Keyword, name: "continue" },
	  DEBUGGER: { klass: TokenClass.Keyword, name: "debugger" },
	  DEFAULT: { klass: TokenClass.Keyword, name: "default" },
	  DO: { klass: TokenClass.Keyword, name: "do" },
	  ELSE: { klass: TokenClass.Keyword, name: "else" },
	  EXPORT: { klass: TokenClass.Keyword, name: "export" },
	  EXTENDS: { klass: TokenClass.Keyword, name: "extends" },
	  FINALLY: { klass: TokenClass.Keyword, name: "finally" },
	  FOR: { klass: TokenClass.Keyword, name: "for" },
	  FUNCTION: { klass: TokenClass.Keyword, name: "function" },
	  IF: { klass: TokenClass.Keyword, name: "if" },
	  IMPORT: { klass: TokenClass.Keyword, name: "import" },
	  LET: { klass: TokenClass.Keyword, name: "let" },
	  NEW: { klass: TokenClass.Keyword, name: "new" },
	  RETURN: { klass: TokenClass.Keyword, name: "return" },
	  SUPER: { klass: TokenClass.Keyword, name: "super" },
	  SWITCH: { klass: TokenClass.Keyword, name: "switch" },
	  THIS: { klass: TokenClass.Keyword, name: "this" },
	  THROW: { klass: TokenClass.Keyword, name: "throw" },
	  TRY: { klass: TokenClass.Keyword, name: "try" },
	  VAR: { klass: TokenClass.Keyword, name: "var" },
	  WHILE: { klass: TokenClass.Keyword, name: "while" },
	  WITH: { klass: TokenClass.Keyword, name: "with" },
	  NULL: { klass: TokenClass.Keyword, name: "null" },
	  TRUE: { klass: TokenClass.Keyword, name: "true" },
	  FALSE: { klass: TokenClass.Keyword, name: "false" },
	  YIELD: { klass: TokenClass.Keyword, name: "yield" },
	  NUMBER: { klass: TokenClass.NumericLiteral, name: "" },
	  STRING: { klass: TokenClass.StringLiteral, name: "" },
	  REGEXP: { klass: TokenClass.RegularExpression, name: "" },
	  IDENTIFIER: { klass: TokenClass.Ident, name: "" },
	  CONST: { klass: TokenClass.Keyword, name: "const" },
	  TEMPLATE: { klass: TokenClass.TemplateElement, name: "" },
	  ILLEGAL: { klass: TokenClass.Illegal, name: "" }
	};

	var TT = TokenType;
	var I = TT.ILLEGAL;
	var F = false;
	var T = true;

	var ONE_CHAR_PUNCTUATOR = [I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.NOT, I, I, I, TT.MOD, TT.BIT_AND, I, TT.LPAREN, TT.RPAREN, TT.MUL, TT.ADD, TT.COMMA, TT.SUB, TT.PERIOD, TT.DIV, I, I, I, I, I, I, I, I, I, I, TT.COLON, TT.SEMICOLON, TT.LT, TT.ASSIGN, TT.GT, TT.CONDITIONAL, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACK, I, TT.RBRACK, TT.BIT_XOR, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACE, TT.BIT_OR, TT.RBRACE, TT.BIT_NOT];

	var PUNCTUATOR_START = [F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, T, T, F, T, T, T, T, T, T, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, F];

	var JsError = exports.JsError = function (_Error) {
	  _inherits(JsError, _Error);

	  function JsError(index, line, column, msg) {
	    _classCallCheck(this, JsError);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(JsError).call(this, msg));

	    _this.index = index;
	    _this.line = line;
	    _this.column = column;
	    _this.description = msg;
	    _this.message = "[" + line + ":" + column + "]: " + msg;
	    return _this;
	  }

	  return JsError;
	}(Error);

	function fromCodePoint(cp) {
	  if (cp <= 0xFFFF) return String.fromCharCode(cp);
	  var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
	  var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
	  return cu1 + cu2;
	}

	function decodeUtf16(lead, trail) {
	  return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	}

	var Tokenizer = function () {
	  function Tokenizer(source) {
	    _classCallCheck(this, Tokenizer);

	    this.source = source;
	    this.index = 0;
	    this.line = 0;
	    this.lineStart = 0;
	    this.startIndex = 0;
	    this.startLine = 0;
	    this.startLineStart = 0;
	    this.lastIndex = 0;
	    this.lastLine = 0;
	    this.lastLineStart = 0;
	    this.hasLineTerminatorBeforeNext = false;
	    this.tokenIndex = 0;
	  }

	  _createClass(Tokenizer, [{
	    key: "saveLexerState",
	    value: function saveLexerState() {
	      return {
	        source: this.source,
	        index: this.index,
	        line: this.line,
	        lineStart: this.lineStart,
	        startIndex: this.startIndex,
	        startLine: this.startLine,
	        startLineStart: this.startLineStart,
	        lastIndex: this.lastIndex,
	        lastLine: this.lastLine,
	        lastLineStart: this.lastLineStart,
	        lookahead: this.lookahead,
	        hasLineTerminatorBeforeNext: this.hasLineTerminatorBeforeNext,
	        tokenIndex: this.tokenIndex
	      };
	    }
	  }, {
	    key: "restoreLexerState",
	    value: function restoreLexerState(state) {
	      this.source = state.source;
	      this.index = state.index;
	      this.line = state.line;
	      this.lineStart = state.lineStart;
	      this.startIndex = state.startIndex;
	      this.startLine = state.startLine;
	      this.startLineStart = state.startLineStart;
	      this.lastIndex = state.lastIndex;
	      this.lastLine = state.lastLine;
	      this.lastLineStart = state.lastLineStart;
	      this.lookahead = state.lookahead;
	      this.hasLineTerminatorBeforeNext = state.hasLineTerminatorBeforeNext;
	      this.tokenIndex = state.tokenIndex;
	    }
	  }, {
	    key: "createILLEGAL",
	    value: function createILLEGAL() {
	      this.startIndex = this.index;
	      this.startLine = this.line;
	      this.startLineStart = this.lineStart;
	      return this.index < this.source.length ? this.createError(_errors.ErrorMessages.UNEXPECTED_ILLEGAL_TOKEN, this.source.charAt(this.index)) : this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
	    }
	  }, {
	    key: "createUnexpected",
	    value: function createUnexpected(token) {
	      switch (token.type.klass) {
	        case TokenClass.Eof:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
	        case TokenClass.Ident:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_IDENTIFIER);
	        case TokenClass.Keyword:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.slice.text);
	        case TokenClass.NumericLiteral:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_NUMBER);
	        case TokenClass.TemplateElement:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_TEMPLATE);
	        case TokenClass.Punctuator:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.type.name);
	        case TokenClass.StringLiteral:
	          return this.createError(_errors.ErrorMessages.UNEXPECTED_STRING);
	        // the other token classes are RegularExpression and Illegal, but they cannot reach here
	      }
	    }
	  }, {
	    key: "createError",
	    value: function createError(message) {
	      var _arguments = arguments;

	      /* istanbul ignore next */
	      var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
	        return JSON.stringify(_arguments[+n + 1]);
	      });
	      return new JsError(this.startIndex, this.startLine + 1, this.startIndex - this.startLineStart + 1, msg);
	    }
	  }, {
	    key: "createErrorWithLocation",
	    value: function createErrorWithLocation(location, message) {
	      var _arguments2 = arguments;

	      /* istanbul ignore next */
	      var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
	        return JSON.stringify(_arguments2[+n + 2]);
	      });
	      if (location.slice && location.slice.startLocation) {
	        location = location.slice.startLocation;
	      }
	      return new JsError(location.offset, location.line, location.column + 1, msg);
	    }
	  }, {
	    key: "getKeyword",
	    value: function getKeyword(id) {
	      if (id.length === 1 || id.length > 10) {
	        return TokenType.IDENTIFIER;
	      }

	      /* istanbul ignore next */
	      switch (id.length) {
	        case 2:
	          switch (id.charAt(0)) {
	            case "i":
	              switch (id.charAt(1)) {
	                case "f":
	                  return TokenType.IF;
	                case "n":
	                  return TokenType.IN;
	                default:
	                  break;
	              }
	              break;
	            case "d":
	              if (id.charAt(1) === "o") {
	                return TokenType.DO;
	              }
	              break;
	          }
	          break;
	        case 3:
	          switch (id.charAt(0)) {
	            case "v":
	              if (Tokenizer.cse2(id, "a", "r")) {
	                return TokenType.VAR;
	              }
	              break;
	            case "f":
	              if (Tokenizer.cse2(id, "o", "r")) {
	                return TokenType.FOR;
	              }
	              break;
	            case "n":
	              if (Tokenizer.cse2(id, "e", "w")) {
	                return TokenType.NEW;
	              }
	              break;
	            case "t":
	              if (Tokenizer.cse2(id, "r", "y")) {
	                return TokenType.TRY;
	              }
	              break;
	            case "l":
	              if (Tokenizer.cse2(id, "e", "t")) {
	                return TokenType.LET;
	              }
	              break;
	          }
	          break;
	        case 4:
	          switch (id.charAt(0)) {
	            case "t":
	              if (Tokenizer.cse3(id, "h", "i", "s")) {
	                return TokenType.THIS;
	              } else if (Tokenizer.cse3(id, "r", "u", "e")) {
	                return TokenType.TRUE;
	              }
	              break;
	            case "n":
	              if (Tokenizer.cse3(id, "u", "l", "l")) {
	                return TokenType.NULL;
	              }
	              break;
	            case "e":
	              if (Tokenizer.cse3(id, "l", "s", "e")) {
	                return TokenType.ELSE;
	              }
	              break;
	            case "c":
	              if (Tokenizer.cse3(id, "a", "s", "e")) {
	                return TokenType.CASE;
	              }
	              break;
	            case "v":
	              if (Tokenizer.cse3(id, "o", "i", "d")) {
	                return TokenType.VOID;
	              }
	              break;
	            case "w":
	              if (Tokenizer.cse3(id, "i", "t", "h")) {
	                return TokenType.WITH;
	              }
	              break;
	          }
	          break;
	        case 5:
	          switch (id.charAt(0)) {
	            case "a":
	              if (this.moduleIsTheGoalSymbol && Tokenizer.cse4(id, "w", "a", "i", "t")) {
	                return TokenType.AWAIT;
	              }
	              break;
	            case "w":
	              if (Tokenizer.cse4(id, "h", "i", "l", "e")) {
	                return TokenType.WHILE;
	              }
	              break;
	            case "b":
	              if (Tokenizer.cse4(id, "r", "e", "a", "k")) {
	                return TokenType.BREAK;
	              }
	              break;
	            case "f":
	              if (Tokenizer.cse4(id, "a", "l", "s", "e")) {
	                return TokenType.FALSE;
	              }
	              break;
	            case "c":
	              if (Tokenizer.cse4(id, "a", "t", "c", "h")) {
	                return TokenType.CATCH;
	              } else if (Tokenizer.cse4(id, "o", "n", "s", "t")) {
	                return TokenType.CONST;
	              } else if (Tokenizer.cse4(id, "l", "a", "s", "s")) {
	                return TokenType.CLASS;
	              }
	              break;
	            case "t":
	              if (Tokenizer.cse4(id, "h", "r", "o", "w")) {
	                return TokenType.THROW;
	              }
	              break;
	            case "y":
	              if (Tokenizer.cse4(id, "i", "e", "l", "d")) {
	                return TokenType.YIELD;
	              }
	              break;
	            case "s":
	              if (Tokenizer.cse4(id, "u", "p", "e", "r")) {
	                return TokenType.SUPER;
	              }
	              break;
	          }
	          break;
	        case 6:
	          switch (id.charAt(0)) {
	            case "r":
	              if (Tokenizer.cse5(id, "e", "t", "u", "r", "n")) {
	                return TokenType.RETURN;
	              }
	              break;
	            case "t":
	              if (Tokenizer.cse5(id, "y", "p", "e", "o", "f")) {
	                return TokenType.TYPEOF;
	              }
	              break;
	            case "d":
	              if (Tokenizer.cse5(id, "e", "l", "e", "t", "e")) {
	                return TokenType.DELETE;
	              }
	              break;
	            case "s":
	              if (Tokenizer.cse5(id, "w", "i", "t", "c", "h")) {
	                return TokenType.SWITCH;
	              }
	              break;
	            case "e":
	              if (Tokenizer.cse5(id, "x", "p", "o", "r", "t")) {
	                return TokenType.EXPORT;
	              }
	              break;
	            case "i":
	              if (Tokenizer.cse5(id, "m", "p", "o", "r", "t")) {
	                return TokenType.IMPORT;
	              }
	              break;
	          }
	          break;
	        case 7:
	          switch (id.charAt(0)) {
	            case "d":
	              if (Tokenizer.cse6(id, "e", "f", "a", "u", "l", "t")) {
	                return TokenType.DEFAULT;
	              }
	              break;
	            case "f":
	              if (Tokenizer.cse6(id, "i", "n", "a", "l", "l", "y")) {
	                return TokenType.FINALLY;
	              }
	              break;
	            case "e":
	              if (Tokenizer.cse6(id, "x", "t", "e", "n", "d", "s")) {
	                return TokenType.EXTENDS;
	              }
	              break;
	          }
	          break;
	        case 8:
	          switch (id.charAt(0)) {
	            case "f":
	              if (Tokenizer.cse7(id, "u", "n", "c", "t", "i", "o", "n")) {
	                return TokenType.FUNCTION;
	              }
	              break;
	            case "c":
	              if (Tokenizer.cse7(id, "o", "n", "t", "i", "n", "u", "e")) {
	                return TokenType.CONTINUE;
	              }
	              break;
	            case "d":
	              if (Tokenizer.cse7(id, "e", "b", "u", "g", "g", "e", "r")) {
	                return TokenType.DEBUGGER;
	              }
	              break;
	          }
	          break;
	        case 10:
	          if (id === "instanceof") {
	            return TokenType.INSTANCEOF;
	          }
	          break;
	      }
	      return TokenType.IDENTIFIER;
	    }
	  }, {
	    key: "skipSingleLineComment",
	    value: function skipSingleLineComment(offset) {
	      this.index += offset;
	      while (this.index < this.source.length) {
	        /**
	         * @type {Number}
	         */
	        var chCode = this.source.charCodeAt(this.index);
	        this.index++;
	        if ((0, _utils.isLineTerminator)(chCode)) {
	          this.hasLineTerminatorBeforeNext = true;
	          if (chCode === 0xD /* "\r" */ && this.source.charCodeAt(this.index) === 0xA /*"\n" */) {
	              this.index++;
	            }
	          this.lineStart = this.index;
	          this.line++;
	          return;
	        }
	      }
	    }
	  }, {
	    key: "skipMultiLineComment",
	    value: function skipMultiLineComment() {
	      this.index += 2;
	      var length = this.source.length;
	      var isLineStart = false;
	      while (this.index < length) {
	        var chCode = this.source.charCodeAt(this.index);
	        if (chCode < 0x80) {
	          switch (chCode) {
	            case 42:
	              // "*"
	              // Block comment ends with "*/".
	              if (this.source.charAt(this.index + 1) === "/") {
	                this.index = this.index + 2;
	                return isLineStart;
	              }
	              this.index++;
	              break;
	            case 10:
	              // "\n"
	              isLineStart = true;
	              this.hasLineTerminatorBeforeNext = true;
	              this.index++;
	              this.lineStart = this.index;
	              this.line++;
	              break;
	            case 13:
	              // "\r":
	              isLineStart = true;
	              this.hasLineTerminatorBeforeNext = true;
	              if (this.source.charAt(this.index + 1) === "\n") {
	                this.index++;
	              }
	              this.index++;
	              this.lineStart = this.index;
	              this.line++;
	              break;
	            default:
	              this.index++;
	          }
	        } else if (chCode === 0x2028 || chCode === 0x2029) {
	          isLineStart = true;
	          this.hasLineTerminatorBeforeNext = true;
	          this.index++;
	          this.lineStart = this.index;
	          this.line++;
	        } else {
	          this.index++;
	        }
	      }
	      throw this.createILLEGAL();
	    }
	  }, {
	    key: "skipComment",
	    value: function skipComment() {
	      this.hasLineTerminatorBeforeNext = false;

	      var isLineStart = this.index === 0;
	      var length = this.source.length;

	      while (this.index < length) {
	        var chCode = this.source.charCodeAt(this.index);
	        if ((0, _utils.isWhiteSpace)(chCode)) {
	          this.index++;
	        } else if ((0, _utils.isLineTerminator)(chCode)) {
	          this.hasLineTerminatorBeforeNext = true;
	          this.index++;
	          if (chCode === 13 /* "\r" */ && this.source.charAt(this.index) === "\n") {
	            this.index++;
	          }
	          this.lineStart = this.index;
	          this.line++;
	          isLineStart = true;
	        } else if (chCode === 47 /* "/" */) {
	            if (this.index + 1 >= length) {
	              break;
	            }
	            chCode = this.source.charCodeAt(this.index + 1);
	            if (chCode === 47 /* "/" */) {
	                this.skipSingleLineComment(2);
	                isLineStart = true;
	              } else if (chCode === 42 /* "*" */) {
	                isLineStart = this.skipMultiLineComment() || isLineStart;
	              } else {
	              break;
	            }
	          } else if (!this.moduleIsTheGoalSymbol && isLineStart && chCode === 45 /* "-" */) {
	            if (this.index + 2 >= length) {
	              break;
	            }
	            // U+003E is ">"
	            if (this.source.charAt(this.index + 1) === "-" && this.source.charAt(this.index + 2) === ">") {
	              // "-->" is a single-line comment
	              this.skipSingleLineComment(3);
	            } else {
	              break;
	            }
	          } else if (!this.moduleIsTheGoalSymbol && chCode === 60 /* "<" */) {
	            if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
	              this.skipSingleLineComment(4);
	            } else {
	              break;
	            }
	          } else {
	          break;
	        }
	      }
	    }
	  }, {
	    key: "scanHexEscape2",
	    value: function scanHexEscape2() {
	      if (this.index + 2 > this.source.length) {
	        return -1;
	      }
	      var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
	      if (r1 === -1) {
	        return -1;
	      }
	      var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
	      if (r2 === -1) {
	        return -1;
	      }
	      this.index += 2;
	      return r1 << 4 | r2;
	    }
	  }, {
	    key: "scanUnicode",
	    value: function scanUnicode() {
	      if (this.source.charAt(this.index) === "{") {
	        //\u{HexDigits}
	        var i = this.index + 1;
	        var hexDigits = 0,
	            ch = undefined;
	        while (i < this.source.length) {
	          ch = this.source.charAt(i);
	          var hex = (0, _utils.getHexValue)(ch);
	          if (hex === -1) {
	            break;
	          }
	          hexDigits = hexDigits << 4 | hex;
	          if (hexDigits > 0x10FFFF) {
	            throw this.createILLEGAL();
	          }
	          i++;
	        }
	        if (ch !== "}") {
	          throw this.createILLEGAL();
	        }
	        this.index = i + 1;
	        return hexDigits;
	      } else {
	        //\uHex4Digits
	        if (this.index + 4 > this.source.length) {
	          return -1;
	        }
	        var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
	        if (r1 === -1) {
	          return -1;
	        }
	        var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
	        if (r2 === -1) {
	          return -1;
	        }
	        var r3 = (0, _utils.getHexValue)(this.source.charAt(this.index + 2));
	        if (r3 === -1) {
	          return -1;
	        }
	        var r4 = (0, _utils.getHexValue)(this.source.charAt(this.index + 3));
	        if (r4 === -1) {
	          return -1;
	        }
	        this.index += 4;
	        return r1 << 12 | r2 << 8 | r3 << 4 | r4;
	      }
	    }
	  }, {
	    key: "getEscapedIdentifier",
	    value: function getEscapedIdentifier() {
	      var id = "";
	      var check = _utils.isIdentifierStart;

	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        var code = ch.charCodeAt(0);
	        var start = this.index;
	        ++this.index;
	        if (ch === "\\") {
	          if (this.index >= this.source.length) {
	            throw this.createILLEGAL();
	          }
	          if (this.source.charAt(this.index) !== "u") {
	            throw this.createILLEGAL();
	          }
	          ++this.index;
	          code = this.scanUnicode();
	          if (code < 0) {
	            throw this.createILLEGAL();
	          }
	          ch = fromCodePoint(code);
	        } else if (0xD800 <= code && code <= 0xDBFF) {
	          if (this.index >= this.source.length) {
	            throw this.createILLEGAL();
	          }
	          var lowSurrogateCode = this.source.charCodeAt(this.index);
	          ++this.index;
	          if (!(0xDC00 <= lowSurrogateCode && lowSurrogateCode <= 0xDFFF)) {
	            throw this.createILLEGAL();
	          }
	          code = decodeUtf16(code, lowSurrogateCode);
	          ch = fromCodePoint(code);
	        }
	        if (!check(code)) {
	          if (id.length < 1) {
	            throw this.createILLEGAL();
	          }
	          this.index = start;
	          return id;
	        }
	        check = _utils.isIdentifierPart;
	        id += ch;
	      }
	      return id;
	    }
	  }, {
	    key: "getIdentifier",
	    value: function getIdentifier() {
	      var start = this.index;
	      var l = this.source.length;
	      var i = this.index;
	      var check = _utils.isIdentifierStart;
	      while (i < l) {
	        var ch = this.source.charAt(i);
	        var code = ch.charCodeAt(0);
	        if (ch === "\\" || 0xD800 <= code && code <= 0xDBFF) {
	          // Go back and try the hard one.
	          this.index = start;
	          return this.getEscapedIdentifier();
	        }
	        if (!check(code)) {
	          this.index = i;
	          return this.source.slice(start, i);
	        }
	        ++i;
	        check = _utils.isIdentifierPart;
	      }
	      this.index = i;
	      return this.source.slice(start, i);
	    }
	  }, {
	    key: "scanIdentifier",
	    value: function scanIdentifier() {
	      var startLocation = this.getLocation();
	      var start = this.index;

	      // Backslash (U+005C) starts an escaped character.
	      var id = this.source.charAt(this.index) === "\\" ? this.getEscapedIdentifier() : this.getIdentifier();

	      // There is no keyword or literal with only one character.
	      // Thus, it must be an identifier.
	      var slice = this.getSlice(start, startLocation);
	      slice.text = id;

	      return { type: this.getKeyword(id), value: id, slice: slice };
	    }
	  }, {
	    key: "getLocation",
	    value: function getLocation() {
	      return {
	        line: this.startLine + 1,
	        column: this.startIndex - this.startLineStart,
	        offset: this.startIndex
	      };
	    }
	  }, {
	    key: "getSlice",
	    value: function getSlice(start, startLocation) {
	      return { text: this.source.slice(start, this.index), start: start, startLocation: startLocation, end: this.index };
	    }
	  }, {
	    key: "scanPunctuatorHelper",
	    value: function scanPunctuatorHelper() {
	      var ch1 = this.source.charAt(this.index);

	      switch (ch1) {
	        // Check for most common single-character punctuators.
	        case ".":
	          var ch2 = this.source.charAt(this.index + 1);
	          if (ch2 !== ".") return TokenType.PERIOD;
	          var ch3 = this.source.charAt(this.index + 2);
	          if (ch3 !== ".") return TokenType.PERIOD;
	          return TokenType.ELLIPSIS;
	        case "(":
	          return TokenType.LPAREN;
	        case ")":
	        case ";":
	        case ",":
	          return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
	        case "{":
	          return TokenType.LBRACE;
	        case "}":
	        case "[":
	        case "]":
	        case ":":
	        case "?":
	        case "~":
	          return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
	        default:
	          // "=" (U+003D) marks an assignment or comparison operator.
	          if (this.index + 1 < this.source.length && this.source.charAt(this.index + 1) === "=") {
	            switch (ch1) {
	              case "=":
	                if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
	                  return TokenType.EQ_STRICT;
	                }
	                return TokenType.EQ;
	              case "!":
	                if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
	                  return TokenType.NE_STRICT;
	                }
	                return TokenType.NE;
	              case "|":
	                return TokenType.ASSIGN_BIT_OR;
	              case "+":
	                return TokenType.ASSIGN_ADD;
	              case "-":
	                return TokenType.ASSIGN_SUB;
	              case "*":
	                return TokenType.ASSIGN_MUL;
	              case "<":
	                return TokenType.LTE;
	              case ">":
	                return TokenType.GTE;
	              case "/":
	                return TokenType.ASSIGN_DIV;
	              case "%":
	                return TokenType.ASSIGN_MOD;
	              case "^":
	                return TokenType.ASSIGN_BIT_XOR;
	              case "&":
	                return TokenType.ASSIGN_BIT_AND;
	              // istanbul ignore next
	              default:
	                break; //failed
	            }
	          }
	      }

	      if (this.index + 1 < this.source.length) {
	        var ch2 = this.source.charAt(this.index + 1);
	        if (ch1 === ch2) {
	          if (this.index + 2 < this.source.length) {
	            var ch3 = this.source.charAt(this.index + 2);
	            if (ch1 === ">" && ch3 === ">") {
	              // 4-character punctuator: >>>=
	              if (this.index + 3 < this.source.length && this.source.charAt(this.index + 3) === "=") {
	                return TokenType.ASSIGN_SHR_UNSIGNED;
	              }
	              return TokenType.SHR_UNSIGNED;
	            }

	            if (ch1 === "<" && ch3 === "=") {
	              return TokenType.ASSIGN_SHL;
	            }

	            if (ch1 === ">" && ch3 === "=") {
	              return TokenType.ASSIGN_SHR;
	            }
	          }
	          // Other 2-character punctuators: ++ -- << >> && ||
	          switch (ch1) {
	            case "+":
	              return TokenType.INC;
	            case "-":
	              return TokenType.DEC;
	            case "<":
	              return TokenType.SHL;
	            case ">":
	              return TokenType.SHR;
	            case "&":
	              return TokenType.AND;
	            case "|":
	              return TokenType.OR;
	            // istanbul ignore next
	            default:
	              break; //failed
	          }
	        } else if (ch1 === "=" && ch2 === ">") {
	            return TokenType.ARROW;
	          }
	      }

	      return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
	    }

	    // 7.7 Punctuators

	  }, {
	    key: "scanPunctuator",
	    value: function scanPunctuator() {
	      var startLocation = this.getLocation();
	      var start = this.index;
	      var subType = this.scanPunctuatorHelper();
	      this.index += subType.name.length;
	      return { type: subType, value: subType.name, slice: this.getSlice(start, startLocation) };
	    }
	  }, {
	    key: "scanHexLiteral",
	    value: function scanHexLiteral(start, startLocation) {
	      var i = this.index;
	      while (i < this.source.length) {
	        var ch = this.source.charAt(i);
	        var hex = (0, _utils.getHexValue)(ch);
	        if (hex === -1) {
	          break;
	        }
	        i++;
	      }

	      if (this.index === i) {
	        throw this.createILLEGAL();
	      }

	      if (i < this.source.length && (0, _utils.isIdentifierStart)(this.source.charCodeAt(i))) {
	        throw this.createILLEGAL();
	      }

	      this.index = i;

	      var slice = this.getSlice(start, startLocation);
	      return { type: TokenType.NUMBER, value: parseInt(slice.text.substr(2), 16), slice: slice };
	    }
	  }, {
	    key: "scanBinaryLiteral",
	    value: function scanBinaryLiteral(start, startLocation) {
	      var offset = this.index - start;

	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if (ch !== "0" && ch !== "1") {
	          break;
	        }
	        this.index++;
	      }

	      if (this.index - start <= offset) {
	        throw this.createILLEGAL();
	      }

	      if (this.index < this.source.length && ((0, _utils.isIdentifierStart)(this.source.charCodeAt(this.index)) || (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index)))) {
	        throw this.createILLEGAL();
	      }

	      return {
	        type: TokenType.NUMBER,
	        value: parseInt(this.getSlice(start, startLocation).text.substr(offset), 2),
	        slice: this.getSlice(start, startLocation),
	        octal: false,
	        noctal: false
	      };
	    }
	  }, {
	    key: "scanOctalLiteral",
	    value: function scanOctalLiteral(start, startLocation) {
	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if ("0" <= ch && ch <= "7") {
	          this.index++;
	        } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
	          throw this.createILLEGAL();
	        } else {
	          break;
	        }
	      }

	      if (this.index - start === 2) {
	        throw this.createILLEGAL();
	      }

	      return {
	        type: TokenType.NUMBER,
	        value: parseInt(this.getSlice(start, startLocation).text.substr(2), 8),
	        slice: this.getSlice(start, startLocation),
	        octal: false,
	        noctal: false
	      };
	    }
	  }, {
	    key: "scanLegacyOctalLiteral",
	    value: function scanLegacyOctalLiteral(start, startLocation) {
	      var isOctal = true;

	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if ("0" <= ch && ch <= "7") {
	          this.index++;
	        } else if (ch === "8" || ch === "9") {
	          isOctal = false;
	          this.index++;
	        } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
	          throw this.createILLEGAL();
	        } else {
	          break;
	        }
	      }

	      return {
	        type: TokenType.NUMBER,
	        slice: this.getSlice(start, startLocation),
	        value: parseInt(this.getSlice(start, startLocation).text.substr(1), isOctal ? 8 : 10),
	        octal: true,
	        noctal: !isOctal
	      };
	    }
	  }, {
	    key: "scanNumericLiteral",
	    value: function scanNumericLiteral() {
	      var ch = this.source.charAt(this.index);
	      // assert(ch === "." || "0" <= ch && ch <= "9")
	      var startLocation = this.getLocation();
	      var start = this.index;

	      if (ch === "0") {
	        this.index++;
	        if (this.index < this.source.length) {
	          ch = this.source.charAt(this.index);
	          if (ch === "x" || ch === "X") {
	            this.index++;
	            return this.scanHexLiteral(start, startLocation);
	          } else if (ch === "b" || ch === "B") {
	            this.index++;
	            return this.scanBinaryLiteral(start, startLocation);
	          } else if (ch === "o" || ch === "O") {
	            this.index++;
	            return this.scanOctalLiteral(start, startLocation);
	          } else if ("0" <= ch && ch <= "9") {
	            return this.scanLegacyOctalLiteral(start, startLocation);
	          }
	        } else {
	          var _slice = this.getSlice(start, startLocation);
	          return {
	            type: TokenType.NUMBER,
	            value: +_slice.text,
	            slice: _slice,
	            octal: false,
	            noctal: false
	          };
	        }
	      } else if (ch !== ".") {
	        // Must be "1".."9"
	        ch = this.source.charAt(this.index);
	        while ("0" <= ch && ch <= "9") {
	          this.index++;
	          if (this.index === this.source.length) {
	            var _slice2 = this.getSlice(start, startLocation);
	            return {
	              type: TokenType.NUMBER,
	              value: +_slice2.text,
	              slice: _slice2,
	              octal: false,
	              noctal: false
	            };
	          }
	          ch = this.source.charAt(this.index);
	        }
	      }

	      var e = 0;
	      if (ch === ".") {
	        this.index++;
	        if (this.index === this.source.length) {
	          var _slice3 = this.getSlice(start, startLocation);
	          return {
	            type: TokenType.NUMBER,
	            value: +_slice3.text,
	            slice: _slice3,
	            octal: false,
	            noctal: false
	          };
	        }

	        ch = this.source.charAt(this.index);
	        while ("0" <= ch && ch <= "9") {
	          e++;
	          this.index++;
	          if (this.index === this.source.length) {
	            var _slice4 = this.getSlice(start, startLocation);
	            return {
	              type: TokenType.NUMBER,
	              value: +_slice4.text,
	              slice: _slice4,
	              octal: false,
	              noctal: false
	            };
	          }
	          ch = this.source.charAt(this.index);
	        }
	      }

	      // EOF not reached here
	      if (ch === "e" || ch === "E") {
	        this.index++;
	        if (this.index === this.source.length) {
	          throw this.createILLEGAL();
	        }

	        ch = this.source.charAt(this.index);
	        var neg = false;
	        if (ch === "+" || ch === "-") {
	          neg = ch === "-";
	          this.index++;
	          if (this.index === this.source.length) {
	            throw this.createILLEGAL();
	          }
	          ch = this.source.charAt(this.index);
	        }

	        var f = 0;
	        if ("0" <= ch && ch <= "9") {
	          while ("0" <= ch && ch <= "9") {
	            f *= 10;
	            f += +ch;
	            this.index++;
	            if (this.index === this.source.length) {
	              break;
	            }
	            ch = this.source.charAt(this.index);
	          }
	        } else {
	          throw this.createILLEGAL();
	        }
	        e += neg ? f : -f;
	      }

	      if ((0, _utils.isIdentifierStart)(ch.charCodeAt(0))) {
	        throw this.createILLEGAL();
	      }

	      var slice = this.getSlice(start, startLocation);
	      return {
	        type: TokenType.NUMBER,
	        value: +slice.text,
	        slice: slice,
	        octal: false,
	        noctal: false
	      };
	    }
	  }, {
	    key: "scanStringEscape",
	    value: function scanStringEscape(str, octal) {
	      this.index++;
	      if (this.index === this.source.length) {
	        throw this.createILLEGAL();
	      }
	      var ch = this.source.charAt(this.index);
	      if (!(0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	        switch (ch) {
	          case "n":
	            str += "\n";
	            this.index++;
	            break;
	          case "r":
	            str += "\r";
	            this.index++;
	            break;
	          case "t":
	            str += "\t";
	            this.index++;
	            break;
	          case "u":
	          case "x":
	            var unescaped = undefined;
	            this.index++;
	            if (this.index >= this.source.length) {
	              throw this.createILLEGAL();
	            }
	            unescaped = ch === "u" ? this.scanUnicode() : this.scanHexEscape2();
	            if (unescaped < 0) {
	              throw this.createILLEGAL();
	            }
	            str += fromCodePoint(unescaped);
	            break;
	          case "b":
	            str += "\b";
	            this.index++;
	            break;
	          case "f":
	            str += "\f";
	            this.index++;
	            break;
	          case "v":
	            str += "\u000b";
	            this.index++;
	            break;
	          default:
	            if ("0" <= ch && ch <= "7") {
	              var octalStart = this.index;
	              var octLen = 1;
	              // 3 digits are only allowed when string starts
	              // with 0, 1, 2, 3
	              if ("0" <= ch && ch <= "3") {
	                octLen = 0;
	              }
	              var code = 0;
	              while (octLen < 3 && "0" <= ch && ch <= "7") {
	                this.index++;
	                if (octLen > 0 || ch !== "0") {
	                  octal = this.source.slice(octalStart, this.index);
	                }
	                code *= 8;
	                code += ch - "0";
	                octLen++;
	                if (this.index === this.source.length) {
	                  throw this.createILLEGAL();
	                }
	                ch = this.source.charAt(this.index);
	              }
	              str += String.fromCharCode(code);
	            } else if (ch === "8" || ch === "9") {
	              throw this.createILLEGAL();
	            } else {
	              str += ch;
	              this.index++;
	            }
	        }
	      } else {
	        this.index++;
	        if (ch === "\r" && this.source.charAt(this.index) === "\n") {
	          this.index++;
	        }
	        this.lineStart = this.index;
	        this.line++;
	      }
	      return [str, octal];
	    }
	    // 7.8.4 String Literals

	  }, {
	    key: "scanStringLiteral",
	    value: function scanStringLiteral() {
	      var str = "";

	      var quote = this.source.charAt(this.index);
	      //  assert((quote === "\"" || quote === """), "String literal must starts with a quote")

	      var startLocation = this.getLocation();
	      var start = this.index;
	      this.index++;

	      var octal = null;
	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if (ch === quote) {
	          this.index++;
	          return { type: TokenType.STRING, slice: this.getSlice(start, startLocation), str: str, octal: octal };
	        } else if (ch === "\\") {
	          var _scanStringEscape = this.scanStringEscape(str, octal);

	          var _scanStringEscape2 = _slicedToArray(_scanStringEscape, 2);

	          str = _scanStringEscape2[0];
	          octal = _scanStringEscape2[1];
	        } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	          throw this.createILLEGAL();
	        } else {
	          str += ch;
	          this.index++;
	        }
	      }

	      throw this.createILLEGAL();
	    }
	  }, {
	    key: "scanTemplateElement",
	    value: function scanTemplateElement() {
	      var startLocation = this.getLocation();
	      var start = this.index;
	      this.index++;
	      while (this.index < this.source.length) {
	        var ch = this.source.charCodeAt(this.index);
	        switch (ch) {
	          case 0x60:
	            // `
	            this.index++;
	            return { type: TokenType.TEMPLATE, tail: true, slice: this.getSlice(start, startLocation) };
	          case 0x24:
	            // $
	            if (this.source.charCodeAt(this.index + 1) === 0x7B) {
	              // {
	              this.index += 2;
	              return { type: TokenType.TEMPLATE, tail: false, slice: this.getSlice(start, startLocation) };
	            }
	            this.index++;
	            break;
	          case 0x5C:
	            // \\
	            {
	              var octal = this.scanStringEscape("", null)[1];
	              if (octal != null) {
	                throw this.createILLEGAL();
	              }
	              break;
	            }
	          default:
	            this.index++;
	        }
	      }

	      throw this.createILLEGAL();
	    }
	  }, {
	    key: "scanRegExp",
	    value: function scanRegExp(str) {
	      var startLocation = this.getLocation();
	      var start = this.index;

	      var terminated = false;
	      var classMarker = false;
	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if (ch === "\\") {
	          str += ch;
	          this.index++;
	          ch = this.source.charAt(this.index);
	          // ECMA-262 7.8.5
	          if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	            throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
	          }
	          str += ch;
	          this.index++;
	        } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
	          throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
	        } else {
	          if (classMarker) {
	            if (ch === "]") {
	              classMarker = false;
	            }
	          } else {
	            if (ch === "/") {
	              terminated = true;
	              str += ch;
	              this.index++;
	              break;
	            } else if (ch === "[") {
	              classMarker = true;
	            }
	          }
	          str += ch;
	          this.index++;
	        }
	      }

	      if (!terminated) {
	        throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
	      }

	      while (this.index < this.source.length) {
	        var ch = this.source.charAt(this.index);
	        if (ch === "\\") {
	          throw this.createError(_errors.ErrorMessages.INVALID_REGEXP_FLAGS);
	        }
	        if (!(0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
	          break;
	        }
	        this.index++;
	        str += ch;
	      }
	      return { type: TokenType.REGEXP, value: str, slice: this.getSlice(start, startLocation) };
	    }
	  }, {
	    key: "advance",
	    value: function advance() {
	      var startLocation = this.getLocation();

	      this.lastIndex = this.index;
	      this.lastLine = this.line;
	      this.lastLineStart = this.lineStart;

	      this.skipComment();

	      this.startIndex = this.index;
	      this.startLine = this.line;
	      this.startLineStart = this.lineStart;

	      if (this.lastIndex === 0) {
	        this.lastIndex = this.index;
	        this.lastLine = this.line;
	        this.lastLineStart = this.lineStart;
	      }

	      if (this.index >= this.source.length) {
	        return { type: TokenType.EOS, slice: this.getSlice(this.index, startLocation) };
	      }

	      var charCode = this.source.charCodeAt(this.index);

	      if (charCode < 0x80) {
	        if (PUNCTUATOR_START[charCode]) {
	          return this.scanPunctuator();
	        }

	        if ((0, _utils.isIdentifierStart)(charCode) || charCode === 0x5C /* backslash (\) */) {
	            return this.scanIdentifier();
	          }

	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (charCode === 0x2E) {
	          if (this.index + 1 < this.source.length && (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index + 1))) {
	            return this.scanNumericLiteral();
	          }
	          return this.scanPunctuator();
	        }

	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (charCode === 0x27 || charCode === 0x22) {
	          return this.scanStringLiteral();
	        }

	        // Template literal starts with back quote (U+0060)
	        if (charCode === 0x60) {
	          return this.scanTemplateElement();
	        }

	        if (0x30 /* "0" */ <= charCode && charCode <= 0x39 /* "9" */) {
	            return this.scanNumericLiteral();
	          }

	        // Slash (/) U+002F can also start a regex.
	        throw this.createILLEGAL();
	      } else {
	        if ((0, _utils.isIdentifierStart)(charCode) || 0xD800 <= charCode && charCode <= 0xDBFF) {
	          return this.scanIdentifier();
	        }

	        throw this.createILLEGAL();
	      }
	    }
	  }, {
	    key: "eof",
	    value: function eof() {
	      return this.lookahead.type === TokenType.EOS;
	    }
	  }, {
	    key: "lex",
	    value: function lex() {
	      var prevToken = this.lookahead;
	      this.lookahead = this.advance();
	      this.tokenIndex++;
	      return prevToken;
	    }
	  }], [{
	    key: "cse2",
	    value: function cse2(id, ch1, ch2) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2;
	    }
	  }, {
	    key: "cse3",
	    value: function cse3(id, ch1, ch2, ch3) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3;
	    }
	  }, {
	    key: "cse4",
	    value: function cse4(id, ch1, ch2, ch3, ch4) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4;
	    }
	  }, {
	    key: "cse5",
	    value: function cse5(id, ch1, ch2, ch3, ch4, ch5) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5;
	    }
	  }, {
	    key: "cse6",
	    value: function cse6(id, ch1, ch2, ch3, ch4, ch5, ch6) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6;
	    }
	  }, {
	    key: "cse7",
	    value: function cse7(id, ch1, ch2, ch3, ch4, ch5, ch6, ch7) {
	      return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6 && id.charAt(7) === ch7;
	    }
	  }]);

	  return Tokenizer;
	}();

	exports.default = Tokenizer;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isDecimalDigit = exports.isLineTerminator = exports.isWhiteSpace = exports.isIdentifierPart = exports.isIdentifierStart = exports.isRestrictedWord = undefined;
	exports.isStrictModeReservedWord = isStrictModeReservedWord;
	exports.getHexValue = getHexValue;

	var _esutils = __webpack_require__(4);

	var isReservedWordES6 = _esutils.keyword.isReservedWordES6; /**
	                                                             * Copyright 2014 Shape Security, Inc.
	                                                             *
	                                                             * Licensed under the Apache License, Version 2.0 (the "License")
	                                                             * you may not use this file except in compliance with the License.
	                                                             * You may obtain a copy of the License at
	                                                             *
	                                                             *     http://www.apache.org/licenses/LICENSE-2.0
	                                                             *
	                                                             * Unless required by applicable law or agreed to in writing, software
	                                                             * distributed under the License is distributed on an "AS IS" BASIS,
	                                                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                             * See the License for the specific language governing permissions and
	                                                             * limitations under the License.
	                                                             */

	var isRestrictedWord = _esutils.keyword.isRestrictedWord;
	var isIdentifierStartES6 = _esutils.code.isIdentifierStartES6;
	var isIdentifierPartES6 = _esutils.code.isIdentifierPartES6;
	var isWhiteSpace = _esutils.code.isWhiteSpace;
	var isLineTerminator = _esutils.code.isLineTerminator;
	var isDecimalDigit = _esutils.code.isDecimalDigit;
	exports.isRestrictedWord = isRestrictedWord;
	exports.isIdentifierStart = isIdentifierStartES6;
	exports.isIdentifierPart = isIdentifierPartES6;
	exports.isWhiteSpace = isWhiteSpace;
	exports.isLineTerminator = isLineTerminator;
	exports.isDecimalDigit = isDecimalDigit;
	function isStrictModeReservedWord(id) {
	  return isReservedWordES6(id, true);
	}

	function getHexValue(rune) {
	  if ("0" <= rune && rune <= "9") {
	    return rune.charCodeAt(0) - 48;
	  }
	  if ("a" <= rune && rune <= "f") {
	    return rune.charCodeAt(0) - 87;
	  }
	  if ("A" <= rune && rune <= "F") {
	    return rune.charCodeAt(0) - 55;
	  }
	  return -1;
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/


	(function () {
	    'use strict';

	    exports.ast = __webpack_require__(5);
	    exports.code = __webpack_require__(6);
	    exports.keyword = __webpack_require__(7);
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 5 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    function isExpression(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'ArrayExpression':
	            case 'AssignmentExpression':
	            case 'BinaryExpression':
	            case 'CallExpression':
	            case 'ConditionalExpression':
	            case 'FunctionExpression':
	            case 'Identifier':
	            case 'Literal':
	            case 'LogicalExpression':
	            case 'MemberExpression':
	            case 'NewExpression':
	            case 'ObjectExpression':
	            case 'SequenceExpression':
	            case 'ThisExpression':
	            case 'UnaryExpression':
	            case 'UpdateExpression':
	                return true;
	        }
	        return false;
	    }

	    function isIterationStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'DoWhileStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'WhileStatement':
	                return true;
	        }
	        return false;
	    }

	    function isStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'BlockStatement':
	            case 'BreakStatement':
	            case 'ContinueStatement':
	            case 'DebuggerStatement':
	            case 'DoWhileStatement':
	            case 'EmptyStatement':
	            case 'ExpressionStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'IfStatement':
	            case 'LabeledStatement':
	            case 'ReturnStatement':
	            case 'SwitchStatement':
	            case 'ThrowStatement':
	            case 'TryStatement':
	            case 'VariableDeclaration':
	            case 'WhileStatement':
	            case 'WithStatement':
	                return true;
	        }
	        return false;
	    }

	    function isSourceElement(node) {
	      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	    }

	    function trailingStatement(node) {
	        switch (node.type) {
	        case 'IfStatement':
	            if (node.alternate != null) {
	                return node.alternate;
	            }
	            return node.consequent;

	        case 'LabeledStatement':
	        case 'ForStatement':
	        case 'ForInStatement':
	        case 'WhileStatement':
	        case 'WithStatement':
	            return node.body;
	        }
	        return null;
	    }

	    function isProblematicIfStatement(node) {
	        var current;

	        if (node.type !== 'IfStatement') {
	            return false;
	        }
	        if (node.alternate == null) {
	            return false;
	        }
	        current = node.consequent;
	        do {
	            if (current.type === 'IfStatement') {
	                if (current.alternate == null)  {
	                    return true;
	                }
	            }
	            current = trailingStatement(current);
	        } while (current);

	        return false;
	    }

	    module.exports = {
	        isExpression: isExpression,
	        isStatement: isStatement,
	        isIterationStatement: isIterationStatement,
	        isSourceElement: isSourceElement,
	        isProblematicIfStatement: isProblematicIfStatement,

	        trailingStatement: trailingStatement
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 6 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

	    // See `tools/generate-identifier-regex.js`.
	    ES5Regex = {
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
	    };

	    ES6Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };

	    function isDecimalDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39;  // 0..9
	    }

	    function isHexDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
	            0x61 <= ch && ch <= 0x66 ||     // a..f
	            0x41 <= ch && ch <= 0x46;       // A..F
	    }

	    function isOctalDigit(ch) {
	        return ch >= 0x30 && ch <= 0x37;  // 0..7
	    }

	    // 7.2 White Space

	    NON_ASCII_WHITESPACES = [
	        0x1680, 0x180E,
	        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
	        0x202F, 0x205F,
	        0x3000,
	        0xFEFF
	    ];

	    function isWhiteSpace(ch) {
	        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
	            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	    }

	    // 7.6 Identifier Names and Identifiers

	    function fromCodePoint(cp) {
	        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
	        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
	        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
	        return cu1 + cu2;
	    }

	    IDENTIFIER_START = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_START[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }

	    IDENTIFIER_PART = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_PART[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch >= 0x30 && ch <= 0x39 ||  // 0..9
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }

	    function isIdentifierStartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }

	    function isIdentifierPartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }

	    function isIdentifierStartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }

	    function isIdentifierPartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }

	    module.exports = {
	        isDecimalDigit: isDecimalDigit,
	        isHexDigit: isHexDigit,
	        isOctalDigit: isOctalDigit,
	        isWhiteSpace: isWhiteSpace,
	        isLineTerminator: isLineTerminator,
	        isIdentifierStartES5: isIdentifierStartES5,
	        isIdentifierPartES5: isIdentifierPartES5,
	        isIdentifierStartES6: isIdentifierStartES6,
	        isIdentifierPartES6: isIdentifierPartES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var code = __webpack_require__(6);

	    function isStrictModeReservedWordES6(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isKeywordES5(id, strict) {
	        // yield should not be treated as keyword under non-strict mode.
	        if (!strict && id === 'yield') {
	            return false;
	        }
	        return isKeywordES6(id, strict);
	    }

	    function isKeywordES6(id, strict) {
	        if (strict && isStrictModeReservedWordES6(id)) {
	            return true;
	        }

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    function isReservedWordES5(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	    }

	    function isReservedWordES6(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    function isIdentifierNameES5(id) {
	        var i, iz, ch;

	        if (id.length === 0) { return false; }

	        ch = id.charCodeAt(0);
	        if (!code.isIdentifierStartES5(ch)) {
	            return false;
	        }

	        for (i = 1, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (!code.isIdentifierPartES5(ch)) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function decodeUtf16(lead, trail) {
	        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	    }

	    function isIdentifierNameES6(id) {
	        var i, iz, ch, lowCh, check;

	        if (id.length === 0) { return false; }

	        check = code.isIdentifierStartES6;
	        for (i = 0, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (0xD800 <= ch && ch <= 0xDBFF) {
	                ++i;
	                if (i >= iz) { return false; }
	                lowCh = id.charCodeAt(i);
	                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
	                    return false;
	                }
	                ch = decodeUtf16(ch, lowCh);
	            }
	            if (!check(ch)) {
	                return false;
	            }
	            check = code.isIdentifierPartES6;
	        }
	        return true;
	    }

	    function isIdentifierES5(id, strict) {
	        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
	    }

	    function isIdentifierES6(id, strict) {
	        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
	    }

	    module.exports = {
	        isKeywordES5: isKeywordES5,
	        isKeywordES6: isKeywordES6,
	        isReservedWordES5: isReservedWordES5,
	        isReservedWordES6: isReservedWordES6,
	        isRestrictedWord: isRestrictedWord,
	        isIdentifierNameES5: isIdentifierNameES5,
	        isIdentifierNameES6: isIdentifierNameES6,
	        isIdentifierES5: isIdentifierES5,
	        isIdentifierES6: isIdentifierES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Copyright 2014 Shape Security, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License")
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	var ErrorMessages = exports.ErrorMessages = {
	  UNEXPECTED_TOKEN: "Unexpected token {0}",
	  UNEXPECTED_ILLEGAL_TOKEN: "Unexpected {0}",
	  UNEXPECTED_NUMBER: "Unexpected number",
	  UNEXPECTED_STRING: "Unexpected string",
	  UNEXPECTED_IDENTIFIER: "Unexpected identifier",
	  UNEXPECTED_RESERVED_WORD: "Unexpected reserved word",
	  UNEXPECTED_TEMPLATE: "Unexpected template",
	  UNEXPECTED_EOS: "Unexpected end of input",
	  UNEXPECTED_LINE_TERMINATOR: "Unexpected line terminator",
	  NEWLINE_AFTER_THROW: "Illegal newline after throw",
	  UNTERMINATED_REGEXP: "Invalid regular expression: missing /",
	  INVALID_REGEXP_FLAGS: "Invalid regular expression flags",
	  INVALID_LHS_IN_ASSIGNMENT: "Invalid left-hand side in assignment",
	  INVALID_LHS_IN_FOR_IN: "Invalid left-hand side in for-in",
	  INVALID_LHS_IN_FOR_OF: "Invalid left-hand side in for-of",
	  INVALID_UPDATE_OPERAND: "Increment/decrement target must be an identifier or member expression",
	  MULTIPLE_DEFAULTS_IN_SWITCH: "More than one default clause in switch statement",
	  NO_CATCH_OR_FINALLY: "Missing catch or finally after try",
	  ILLEGAL_RETURN: "Illegal return statement",
	  ILLEGAL_ARROW_FUNCTION_PARAMS: "Illegal arrow function parameter list",
	  INVALID_VAR_INIT_FOR_IN: "Invalid variable declaration in for-in statement",
	  INVALID_VAR_INIT_FOR_OF: "Invalid variable declaration in for-of statement",
	  ILLEGAL_PROPERTY: "Illegal property initializer"
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  global.Immutable = factory();
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step > 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    findEntry: function(predicate, context) {
	      var found;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findLastEntry: function(predicate, context) {
	      return this.toSeq().reverse().findEntry(predicate, context);
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  // Temporary warning about using length
	  (function () {
	    try {
	      Object.defineProperty(IterablePrototype, 'length', {
	        get: function () {
	          if (!Iterable.noLengthWarning) {
	            var stack;
	            try {
	              throw new Error();
	            } catch (error) {
	              stack = error.stack;
	            }
	            if (stack.indexOf('_wrapObject') === -1) {
	              console && console.warn && console.warn(
	                'iterable.length has been deprecated, '+
	                'use iterable.size or iterable.count(). '+
	                'This warning will become a silent error in a future version. ' +
	                stack
	              );
	              return this.size;
	            }
	          }
	        }
	      });
	    } catch (e) {}
	  })();



	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLastKey: function(predicate, context) {
	      return this.toSeq().reverse().findKey(predicate, context);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    lastKeyOf: function(searchValue) {
	      return this.findLastKey(function(value ) {return is(value, searchValue)});
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.toKeyedSeq().keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.toKeyedSeq().reverse().keyOf(searchValue);
	      return key === undefined ? -1 : key;

	      // var index =
	      // return this.toSeq().reverse().indexOf(searchValue);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var key = this.toKeyedSeq().findLastKey(predicate, context);
	      return key === undefined ? -1 : key;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : value;
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(9);

	var _symbol = __webpack_require__(11);

	var _errors = __webpack_require__(12);

	var _bindingMap = __webpack_require__(13);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _ramdaFantasy = __webpack_require__(14);

	var _ramda = __webpack_require__(26);

	var _ = _interopRequireWildcard(_ramda);

	var _tokenizer = __webpack_require__(2);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Just = _ramdaFantasy.Maybe.Just;
	var Nothing = _ramdaFantasy.Maybe.Nothing;

	function sizeDecending(a, b) {
	  if (a.scopes.size > b.scopes.size) {
	    return -1;
	  } else if (b.scopes.size > a.scopes.size) {
	    return 1;
	  } else {
	    return 0;
	  }
	}

	var Syntax = function () {
	  // (Token or List<Syntax>, List<Scope>) -> Syntax

	  function Syntax(token) {
	    var context = arguments.length <= 1 || arguments[1] === undefined ? { bindings: new _bindingMap2.default(), scopeset: (0, _immutable.List)() } : arguments[1];

	    _classCallCheck(this, Syntax);

	    this.token = token;
	    this.context = {
	      bindings: context.bindings,
	      scopeset: context.scopeset
	    };
	    Object.freeze(this.context);
	    Object.freeze(this);
	  }

	  _createClass(Syntax, [{
	    key: "resolve",


	    // () -> string
	    value: function resolve() {
	      if (this.context.scopeset.size === 0 || !(this.isIdentifier() || this.isKeyword())) {
	        return this.token.value;
	      }
	      var scope = this.context.scopeset.last();
	      var stxScopes = this.context.scopeset;
	      var bindings = this.context.bindings;
	      if (scope) {
	        // List<{ scopes: List<Scope>, binding: Symbol }>
	        var scopesetBindingList = bindings.get(this);

	        if (scopesetBindingList) {
	          // { scopes: List<Scope>, binding: Symbol }
	          var biggestBindingPair = scopesetBindingList.filter(function (_ref) {
	            var scopes = _ref.scopes;
	            var binding = _ref.binding;

	            return scopes.isSubset(stxScopes);
	          }).sort(sizeDecending);

	          if (biggestBindingPair.size >= 2 && biggestBindingPair.get(0).scopes.size === biggestBindingPair.get(1).scopes.size) {
	            var debugBase = '{' + stxScopes.map(function (s) {
	              return s.toString();
	            }).join(', ') + '}';
	            var debugAmbigousScopesets = biggestBindingPair.map(function (_ref2) {
	              var scopes = _ref2.scopes;

	              return '{' + scopes.map(function (s) {
	                return s.toString();
	              }).join(', ') + '}';
	            }).join(', ');
	            throw new Error('Scopeset ' + debugBase + ' has ambiguous subsets ' + debugAmbigousScopesets);
	          } else if (biggestBindingPair.size !== 0) {
	            var bindingStr = biggestBindingPair.get(0).binding.toString();
	            if (_ramdaFantasy.Maybe.isJust(biggestBindingPair.get(0).alias)) {
	              // null never happens because we just checked if it is a Just
	              return biggestBindingPair.get(0).alias.getOrElse(null).resolve();
	            }
	            return bindingStr;
	            // if (Maybe.isJust(biggestBindingPair.get(0).alias)) {
	            //   return biggestBindingPair.get(0).alias.just().resolve();
	            // }
	            // return ;
	          }
	        }
	      }
	      return this.token.value;
	    }
	  }, {
	    key: "val",
	    value: function val() {
	      (0, _errors.assert)(!this.isDelimiter(), "cannot get the val of a delimiter");
	      if (this.isStringLiteral()) {
	        return this.token.str;
	      }
	      if (this.isTemplate()) {
	        return this.token.items.map(function (el) {
	          if (el instanceof Syntax && el.isDelimiter()) {
	            return '${...}';
	          }
	          return el.slice.text;
	        }).join('');
	      }
	      return this.token.value;
	    }
	  }, {
	    key: "lineNumber",
	    value: function lineNumber() {
	      if (!this.isDelimiter()) {
	        return this.token.slice.startLocation.line;
	      } else {
	        // TODO: this is the start of the delimiter...correct?
	        return this.token.get(0).lineNumber();
	      }
	    }

	    // () -> List<Syntax>

	  }, {
	    key: "inner",
	    value: function inner() {
	      (0, _errors.assert)(this.isDelimiter(), "can only get the inner of a delimiter");
	      return this.token.slice(1, this.token.size - 1);
	    }
	  }, {
	    key: "addScope",
	    value: function addScope(scope, bindings) {
	      var options = arguments.length <= 2 || arguments[2] === undefined ? { flip: false } : arguments[2];

	      var token = this.isDelimiter() ? this.token.map(function (s) {
	        return s.addScope(scope, bindings, options);
	      }) : this.token;
	      if (this.isTemplate()) {
	        token = {
	          type: this.token.type,
	          items: token.items.map(function (it) {
	            if (it instanceof Syntax && it.isDelimiter()) {
	              return it.addScope(scope, bindings, options);
	            }
	            return it;
	          })
	        };
	      }
	      var newScopeset = undefined;
	      // TODO: clean this logic up
	      if (options.flip) {
	        var index = this.context.scopeset.indexOf(scope);
	        if (index !== -1) {
	          newScopeset = this.context.scopeset.remove(index);
	        } else {
	          newScopeset = this.context.scopeset.push(scope);
	        }
	      } else {
	        newScopeset = this.context.scopeset.push(scope);
	      }
	      return new Syntax(token, { bindings: bindings, scopeset: newScopeset });
	    }
	  }, {
	    key: "removeScope",
	    value: function removeScope(scope) {
	      var token = this.isDelimiter() ? this.token.map(function (s) {
	        return s.removeScope(scope);
	      }) : this.token;
	      var newScopeset = this.context.scopeset;
	      var index = this.context.scopeset.indexOf(scope);
	      if (index !== -1) {
	        newScopeset = this.context.scopeset.remove(index);
	      }
	      return new Syntax(token, { bindings: this.context.bindings, scopeset: newScopeset });
	    }
	  }, {
	    key: "isIdentifier",
	    value: function isIdentifier() {
	      return !this.isDelimiter() && this.token.type.klass === _tokenizer.TokenClass.Ident;
	    }
	  }, {
	    key: "isAssign",
	    value: function isAssign() {
	      return !this.isDelimiter() && this.token.type === _tokenizer.TokenType.ASSIGN;
	    }
	  }, {
	    key: "isBooleanLiteral",
	    value: function isBooleanLiteral() {
	      return !this.isDelimiter() && this.token.type === _tokenizer.TokenType.TRUE || this.token.type === _tokenizer.TokenType.FALSE;
	    }
	  }, {
	    key: "isKeyword",
	    value: function isKeyword() {
	      return !this.isDelimiter() && this.token.type.klass === _tokenizer.TokenClass.Keyword;
	    }
	  }, {
	    key: "isNullLiteral",
	    value: function isNullLiteral() {
	      return !this.isDelimiter() && this.token.type === _tokenizer.TokenType.NULL;
	    }
	  }, {
	    key: "isNumericLiteral",
	    value: function isNumericLiteral() {
	      return !this.isDelimiter() && this.token.type.klass === _tokenizer.TokenClass.NumericLiteral;
	    }
	  }, {
	    key: "isPunctuator",
	    value: function isPunctuator() {
	      return !this.isDelimiter() && this.token.type.klass === _tokenizer.TokenClass.Punctuator;
	    }
	  }, {
	    key: "isStringLiteral",
	    value: function isStringLiteral() {
	      return !this.isDelimiter() && this.token.type.klass === _tokenizer.TokenClass.StringLiteral;
	    }
	  }, {
	    key: "isRegularExpression",
	    value: function isRegularExpression() {
	      return !this.isDelimiter() && this.token.type.klass === _tokenizer.TokenClass.RegularExpression;
	    }
	  }, {
	    key: "isTemplate",
	    value: function isTemplate() {
	      return !this.isDelimiter() && this.token.type === _tokenizer.TokenType.TEMPLATE;
	    }
	  }, {
	    key: "isDelimiter",
	    value: function isDelimiter() {
	      return _immutable.List.isList(this.token);
	    }
	  }, {
	    key: "isParens",
	    value: function isParens() {
	      return this.isDelimiter() && this.token.get(0).token.type === _tokenizer.TokenType.LPAREN;
	    }
	  }, {
	    key: "isBraces",
	    value: function isBraces() {
	      return this.isDelimiter() && this.token.get(0).token.type === _tokenizer.TokenType.LBRACE;
	    }
	  }, {
	    key: "isBrackets",
	    value: function isBrackets() {
	      return this.isDelimiter() && this.token.get(0).token.type === _tokenizer.TokenType.LBRACK;
	    }
	  }, {
	    key: "isSyntaxTemplate",
	    value: function isSyntaxTemplate() {
	      return this.isDelimiter() && this.token.get(0).val() === '#`';
	    }
	  }, {
	    key: "isEOF",
	    value: function isEOF() {
	      return !this.isDelimiter() && this.token.type === _tokenizer.TokenType.EOS;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      if (this.isDelimiter()) {
	        return this.token.map(function (s) {
	          return s.toString();
	        }).join(" ");
	      }
	      if (this.isStringLiteral()) {
	        return "'" + this.token.str;
	      }
	      if (this.isTemplate()) {
	        return this.val();
	      }
	      return this.token.value;
	    }
	  }], [{
	    key: "of",
	    value: function of(token) {
	      var stx = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      return new Syntax(token, stx.context);
	    }
	  }, {
	    key: "fromNumber",
	    value: function fromNumber(value) {
	      var stx = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      return new Syntax({
	        type: _tokenizer.TokenType.NUMBER,
	        value: value
	      }, stx.context);
	    }
	  }, {
	    key: "fromString",
	    value: function fromString(value) {
	      var stx = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      return new Syntax({
	        type: _tokenizer.TokenType.STRING,
	        str: value
	      }, stx.context);
	    }
	  }, {
	    key: "fromIdentifier",
	    value: function fromIdentifier(value) {
	      var stx = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      return new Syntax({
	        type: _tokenizer.TokenType.IDENTIFIER,
	        value: value
	      }, stx.context);
	    }
	  }, {
	    key: "fromBraces",
	    value: function fromBraces(inner) {
	      var stx = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var left = new Syntax({
	        type: _tokenizer.TokenType.LBRACE,
	        value: "{"
	      });
	      var right = new Syntax({
	        type: _tokenizer.TokenType.RBRACE,
	        value: "}"
	      });
	      return new Syntax(_immutable.List.of(left).concat(inner).push(right), stx.context);
	    }
	  }, {
	    key: "fromBrackets",
	    value: function fromBrackets(inner) {
	      var stx = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var left = new Syntax({
	        type: _tokenizer.TokenType.LBRACK,
	        value: "["
	      });
	      var right = new Syntax({
	        type: _tokenizer.TokenType.RBRACK,
	        value: "]"
	      });
	      return new Syntax(_immutable.List.of(left).concat(inner).push(right), stx.context);
	    }
	  }, {
	    key: "fromParens",
	    value: function fromParens(inner) {
	      var stx = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var left = new Syntax({
	        type: _tokenizer.TokenType.LPAREN,
	        value: "("
	      });
	      var right = new Syntax({
	        type: _tokenizer.TokenType.RPAREN,
	        value: ")"
	      });
	      return new Syntax(_immutable.List.of(left).concat(inner).push(right), stx.context);
	    }
	  }]);

	  return Syntax;
	}();

	exports.default = Syntax;
	//# sourceMappingURL=syntax.js.map


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.gensym = gensym;
	var internedMap = new Map();

	var counter = 0;

	function gensym(name) {
	  var prefix = name == null ? "s_" : name + "_";
	  var sym = new _Symbol(prefix + counter);
	  counter++;
	  return sym;
	}

	function _Symbol(name) {
	  this.name = name;
	}
	_Symbol.prototype.toString = function () {
	  return this.name;
	};

	function makeSymbol(name) {
	  if (internedMap.has(name)) {
	    return internedMap.get(name);
	  } else {
	    var sym = new _Symbol(name);
	    internedMap.set(name, sym);
	    return sym;
	  }
	}

	exports.Symbol = makeSymbol;
	exports.SymbolClass = _Symbol;
	//# sourceMappingURL=symbol.js.map


/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.expect = expect;
	exports.assert = assert;
	function expect(cond, message, offendingSyntax, rest) {
	  if (!cond) {
	    var ctx = "";
	    if (rest) {
	      var _ctx = rest.slice(0, 20).map(function (s) {
	        if (s === offendingSyntax) {
	          return "__" + s.val() + "__";
	        }
	        return s.val();
	      }).join(" ");
	    }
	    throw new Error("[error]: " + message + "\n" + ctx);
	  }
	}

	function assert(cond, message) {
	  if (!cond) {
	    throw new Error("[assertion error]: " + message);
	  }
	}
	//# sourceMappingURL=errors.js.map


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(9);

	var _errors = __webpack_require__(12);

	var _ramdaFantasy = __webpack_require__(14);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var BindingMap = function () {
	  function BindingMap() {
	    _classCallCheck(this, BindingMap);

	    this._map = new Map();
	  }

	  // given a syntax object and a binding,
	  // add the binding to the map associating the binding with the syntax object's
	  // scope set


	  _createClass(BindingMap, [{
	    key: "add",
	    value: function add(stx, _ref) {
	      var binding = _ref.binding;
	      var phase = _ref.phase;
	      var _ref$skipDup = _ref.skipDup;
	      var skipDup = _ref$skipDup === undefined ? false : _ref$skipDup;

	      var stxName = stx.val();

	      if (this._map.has(stxName)) {
	        var scopesetBindingList = this._map.get(stxName);
	        if (skipDup && scopesetBindingList.some(function (s) {
	          return s.scopes.equals(stx.context.scopeset);
	        })) {
	          return;
	        }
	        this._map.set(stxName, scopesetBindingList.push({
	          scopes: stx.context.scopeset,
	          binding: binding,
	          alias: _ramdaFantasy.Maybe.Nothing()
	        }));
	      } else {
	        this._map.set(stxName, _immutable.List.of({
	          scopes: stx.context.scopeset,
	          binding: binding,
	          alias: _ramdaFantasy.Maybe.Nothing()
	        }));
	      }
	    }
	  }, {
	    key: "addForward",
	    value: function addForward(stx, forwardStx, binding) {
	      var phase = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

	      var stxName = stx.token.value;

	      if (this._map.has(stxName)) {
	        var scopesetBindingList = this._map.get(stxName);
	        this._map.set(stxName, scopesetBindingList.push({
	          scopes: stx.context.scopeset,
	          binding: binding,
	          alias: _ramdaFantasy.Maybe.of(forwardStx)
	        }));
	      } else {
	        this._map.set(stxName, _immutable.List.of({
	          scopes: stx.context.scopeset,
	          binding: binding,
	          alias: _ramdaFantasy.Maybe.of(forwardStx)
	        }));
	      }
	    }

	    // Syntax -> ?List<{ scopes: ScopeSet, binding: Binding }>

	  }, {
	    key: "get",
	    value: function get(stx) {
	      return this._map.get(stx.token.value);
	    }
	  }]);

	  return BindingMap;
	}();

	exports.default = BindingMap;
	//# sourceMappingURL=binding-map.js.map


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    Either: __webpack_require__(15),
	    Future: __webpack_require__(18),
	    Identity: __webpack_require__(19),
	    IO: __webpack_require__(20),
	    lift2: __webpack_require__(21),
	    lift3: __webpack_require__(22),
	    Maybe: __webpack_require__(23),
	    Tuple: __webpack_require__(24),
	    Reader: __webpack_require__(25)
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);

	var util = __webpack_require__(17);


	function Either(left, right) {
	  switch (arguments.length) {
	    case 0:
	      throw new TypeError('no arguments to Either');
	    case 1:
	      return function(right) {
	        return right == null ? Either.Left(left) : Either.Right(right);
	      };
	    default:
	      return right == null ? Either.Left(left) : Either.Right(right);
	  }
	}

	Either.prototype.map = util.returnThis;

	Either.of = Either.prototype.of = function(value) {
	  return Either.Right(value);
	};

	Either.prototype.chain = util.returnThis; // throw?

	Either.equals = Either.prototype.equals = util.getEquals(Either);


	// Right
	function _Right(x) {
	  this.value = x;
	}
	util.extend(_Right, Either);

	_Right.prototype.map = function(fn) {
	  return new _Right(fn(this.value));
	};

	_Right.prototype.ap = function(that) {
	  return that.map(this.value);
	};

	_Right.prototype.chain = function(f) {
	  return f(this.value);
	};

	_Right.prototype.bimap = function(_, f) {
	  return new _Right(f(this.value));
	};

	_Right.prototype.extend = function(f) {
	  return new _Right(f(this));
	};

	_Right.prototype.toString = function() {
	  return 'Either.Right(' + R.toString(this.value) + ')';
	};

	Either.Right = function(value) {
	  return new _Right(value);
	};


	// Left
	function _Left(x) {
	  this.value = x;
	}
	util.extend(_Left, Either);

	_Left.prototype.ap = function(that) { return that; };

	_Left.prototype.bimap = function(f) {
	  return new _Left(f(this.value));
	};

	_Left.prototype.extend = util.returnThis;

	_Left.prototype.toString = function() {
	  return 'Either.Left(' + R.toString(this.value) + ')';
	};

	Either.Left = function(value) {
	  return new _Left(value);
	};


	module.exports = Either;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	//  Ramda v0.17.1
	//  https://github.com/ramda/ramda
	//  (c) 2013-2015 Scott Sauyet, Michael Hurley, and David Chambers
	//  Ramda may be freely distributed under the MIT license.

	;(function() {

	  'use strict';

	  /**
	     * A special placeholder value used to specify "gaps" within curried functions,
	     * allowing partial application of any combination of arguments,
	     * regardless of their positions.
	     *
	     * If `g` is a curried ternary function and `_` is `R.__`, the following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2, _)(1, 3)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @constant
	     * @memberOf R
	     * @category Function
	     * @example
	     *
	     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
	     *      greet('Alice'); //=> 'Hello, Alice!'
	     */
	    var __ = { '@@functional/placeholder': true };

	    // jshint unused:vars
	    var _arity = function _arity(n, fn) {
	        // jshint unused:vars
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.apply(this, arguments);
	            };
	        case 1:
	            return function (a0) {
	                return fn.apply(this, arguments);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.apply(this, arguments);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.apply(this, arguments);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.apply(this, arguments);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.apply(this, arguments);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.apply(this, arguments);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.apply(this, arguments);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.apply(this, arguments);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.apply(this, arguments);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.apply(this, arguments);
	            };
	        default:
	            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	        }
	    };

	    var _cloneRegExp = function _cloneRegExp(pattern) {
	        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
	    };

	    var _complement = function _complement(f) {
	        return function () {
	            return !f.apply(this, arguments);
	        };
	    };

	    /**
	     * Private `concat` function to merge two array-like objects.
	     *
	     * @private
	     * @param {Array|Arguments} [set1=[]] An array-like object.
	     * @param {Array|Arguments} [set2=[]] An array-like object.
	     * @return {Array} A new, merged array.
	     * @example
	     *
	     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     */
	    var _concat = function _concat(set1, set2) {
	        set1 = set1 || [];
	        set2 = set2 || [];
	        var idx;
	        var len1 = set1.length;
	        var len2 = set2.length;
	        var result = [];
	        idx = 0;
	        while (idx < len1) {
	            result[result.length] = set1[idx];
	            idx += 1;
	        }
	        idx = 0;
	        while (idx < len2) {
	            result[result.length] = set2[idx];
	            idx += 1;
	        }
	        return result;
	    };

	    var _containsWith = function _containsWith(pred, x, list) {
	        var idx = 0, len = list.length;
	        while (idx < len) {
	            if (pred(x, list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry1 = function _curry1(fn) {
	        return function f1(a) {
	            if (arguments.length === 0) {
	                return f1;
	            } else if (a != null && a['@@functional/placeholder'] === true) {
	                return f1;
	            } else {
	                return fn.apply(this, arguments);
	            }
	        };
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry2 = function _curry2(fn) {
	        return function f2(a, b) {
	            var n = arguments.length;
	            if (n === 0) {
	                return f2;
	            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
	                return f2;
	            } else if (n === 1) {
	                return _curry1(function (b) {
	                    return fn(a, b);
	                });
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
	                return f2;
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
	                return _curry1(function (a) {
	                    return fn(a, b);
	                });
	            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
	                return _curry1(function (b) {
	                    return fn(a, b);
	                });
	            } else {
	                return fn(a, b);
	            }
	        };
	    };

	    /**
	     * Optimized internal three-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry3 = function _curry3(fn) {
	        return function f3(a, b, c) {
	            var n = arguments.length;
	            if (n === 0) {
	                return f3;
	            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
	                return f3;
	            } else if (n === 1) {
	                return _curry2(function (b, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
	                return f3;
	            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
	                return _curry2(function (a, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
	                return _curry2(function (b, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 2) {
	                return _curry1(function (c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
	                return f3;
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
	                return _curry2(function (a, b) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
	                return _curry2(function (a, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
	                return _curry2(function (b, c) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {
	                return _curry1(function (a) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {
	                return _curry1(function (b) {
	                    return fn(a, b, c);
	                });
	            } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {
	                return _curry1(function (c) {
	                    return fn(a, b, c);
	                });
	            } else {
	                return fn(a, b, c);
	            }
	        };
	    };

	    /**
	     * Internal curryN function.
	     *
	     * @private
	     * @category Function
	     * @param {Number} length The arity of the curried function.
	     * @return {array} An array of arguments received thus far.
	     * @param {Function} fn The function to curry.
	     */
	    var _curryN = function _curryN(length, received, fn) {
	        return function () {
	            var combined = [];
	            var argsIdx = 0;
	            var left = length;
	            var combinedIdx = 0;
	            while (combinedIdx < received.length || argsIdx < arguments.length) {
	                var result;
	                if (combinedIdx < received.length && (received[combinedIdx] == null || received[combinedIdx]['@@functional/placeholder'] !== true || argsIdx >= arguments.length)) {
	                    result = received[combinedIdx];
	                } else {
	                    result = arguments[argsIdx];
	                    argsIdx += 1;
	                }
	                combined[combinedIdx] = result;
	                if (result == null || result['@@functional/placeholder'] !== true) {
	                    left -= 1;
	                }
	                combinedIdx += 1;
	            }
	            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	        };
	    };

	    var _filter = function _filter(fn, list) {
	        var idx = 0, len = list.length, result = [];
	        while (idx < len) {
	            if (fn(list[idx])) {
	                result[result.length] = list[idx];
	            }
	            idx += 1;
	        }
	        return result;
	    };

	    var _forceReduced = function _forceReduced(x) {
	        return {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * @private
	     * @param {Function} fn The strategy for extracting function names from an object
	     * @return {Function} A function that takes an object and returns an array of function names.
	     */
	    var _functionsWith = function _functionsWith(fn) {
	        return function (obj) {
	            return _filter(function (key) {
	                return typeof obj[key] === 'function';
	            }, fn(obj));
	        };
	    };

	    var _has = function _has(prop, obj) {
	        return Object.prototype.hasOwnProperty.call(obj, prop);
	    };

	    var _identity = function _identity(x) {
	        return x;
	    };

	    /**
	     * Tests whether or not an object is an array.
	     *
	     * @private
	     * @param {*} val The object to test.
	     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	     * @example
	     *
	     *      _isArray([]); //=> true
	     *      _isArray(null); //=> false
	     *      _isArray({}); //=> false
	     */
	    var _isArray = Array.isArray || function _isArray(val) {
	        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	    };

	    /**
	     * Determine if the passed argument is an integer.
	     *
	     * @private
	     * @param {*} n
	     * @category Type
	     * @return {Boolean}
	     */
	    var _isInteger = Number.isInteger || function _isInteger(n) {
	        return n << 0 === n;
	    };

	    var _isNumber = function _isNumber(x) {
	        return Object.prototype.toString.call(x) === '[object Number]';
	    };

	    var _isString = function _isString(x) {
	        return Object.prototype.toString.call(x) === '[object String]';
	    };

	    var _isTransformer = function _isTransformer(obj) {
	        return typeof obj['@@transducer/step'] === 'function';
	    };

	    var _map = function _map(fn, list) {
	        var idx = 0, len = list.length, result = Array(len);
	        while (idx < len) {
	            result[idx] = fn(list[idx]);
	            idx += 1;
	        }
	        return result;
	    };

	    var _pipe = function _pipe(f, g) {
	        return function () {
	            return g.call(this, f.apply(this, arguments));
	        };
	    };

	    var _pipeP = function _pipeP(f, g) {
	        return function () {
	            var ctx = this;
	            return f.apply(ctx, arguments).then(function (x) {
	                return g.call(ctx, x);
	            });
	        };
	    };

	    var _quote = function _quote(s) {
	        return '"' + s.replace(/"/g, '\\"') + '"';
	    };

	    var _reduced = function _reduced(x) {
	        return x && x['@@transducer/reduced'] ? x : {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * An optimized, private array `slice` implementation.
	     *
	     * @private
	     * @param {Arguments|Array} args The array or arguments object to consider.
	     * @param {Number} [from=0] The array index to slice from, inclusive.
	     * @param {Number} [to=args.length] The array index to slice to, exclusive.
	     * @return {Array} A new, sliced array.
	     * @example
	     *
	     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
	     *
	     *      var firstThreeArgs = function(a, b, c, d) {
	     *        return _slice(arguments, 0, 3);
	     *      };
	     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
	     */
	    var _slice = function _slice(args, from, to) {
	        switch (arguments.length) {
	        case 1:
	            return _slice(args, 0, args.length);
	        case 2:
	            return _slice(args, from, args.length);
	        default:
	            var list = [];
	            var idx = 0;
	            var len = Math.max(0, Math.min(args.length, to) - from);
	            while (idx < len) {
	                list[idx] = args[from + idx];
	                idx += 1;
	            }
	            return list;
	        }
	    };

	    /**
	     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
	     */
	    var _toISOString = function () {
	        var pad = function pad(n) {
	            return (n < 10 ? '0' : '') + n;
	        };
	        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
	            return d.toISOString();
	        } : function _toISOString(d) {
	            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
	        };
	    }();

	    var _xdropRepeatsWith = function () {
	        function XDropRepeatsWith(pred, xf) {
	            this.xf = xf;
	            this.pred = pred;
	            this.lastValue = undefined;
	            this.seenFirstValue = false;
	        }
	        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
	            return this.xf['@@transducer/init']();
	        };
	        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
	            var sameAsLast = false;
	            if (!this.seenFirstValue) {
	                this.seenFirstValue = true;
	            } else if (this.pred(this.lastValue, input)) {
	                sameAsLast = true;
	            }
	            this.lastValue = input;
	            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropRepeatsWith(pred, xf) {
	            return new XDropRepeatsWith(pred, xf);
	        });
	    }();

	    var _xfBase = {
	        init: function () {
	            return this.xf['@@transducer/init']();
	        },
	        result: function (result) {
	            return this.xf['@@transducer/result'](result);
	        }
	    };

	    var _xfilter = function () {
	        function XFilter(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFilter.prototype['@@transducer/init'] = _xfBase.init;
	        XFilter.prototype['@@transducer/result'] = _xfBase.result;
	        XFilter.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	        };
	        return _curry2(function _xfilter(f, xf) {
	            return new XFilter(f, xf);
	        });
	    }();

	    var _xfind = function () {
	        function XFind(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.found = false;
	        }
	        XFind.prototype['@@transducer/init'] = _xfBase.init;
	        XFind.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, void 0);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFind.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, input));
	            }
	            return result;
	        };
	        return _curry2(function _xfind(f, xf) {
	            return new XFind(f, xf);
	        });
	    }();

	    var _xfindIndex = function () {
	        function XFindIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.found = false;
	        }
	        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindIndex.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, -1);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	            }
	            return result;
	        };
	        return _curry2(function _xfindIndex(f, xf) {
	            return new XFindIndex(f, xf);
	        });
	    }();

	    var _xfindLast = function () {
	        function XFindLast(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLast.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
	        };
	        XFindLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.last = input;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLast(f, xf) {
	            return new XFindLast(f, xf);
	        });
	    }();

	    var _xfindLastIndex = function () {
	        function XFindLastIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.lastIdx = -1;
	        }
	        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
	        };
	        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.lastIdx = this.idx;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLastIndex(f, xf) {
	            return new XFindLastIndex(f, xf);
	        });
	    }();

	    var _xmap = function () {
	        function XMap(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XMap.prototype['@@transducer/init'] = _xfBase.init;
	        XMap.prototype['@@transducer/result'] = _xfBase.result;
	        XMap.prototype['@@transducer/step'] = function (result, input) {
	            return this.xf['@@transducer/step'](result, this.f(input));
	        };
	        return _curry2(function _xmap(f, xf) {
	            return new XMap(f, xf);
	        });
	    }();

	    var _xtake = function () {
	        function XTake(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XTake.prototype['@@transducer/init'] = _xfBase.init;
	        XTake.prototype['@@transducer/result'] = _xfBase.result;
	        XTake.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n === 0) {
	                return _reduced(result);
	            } else {
	                this.n -= 1;
	                return this.xf['@@transducer/step'](result, input);
	            }
	        };
	        return _curry2(function _xtake(n, xf) {
	            return new XTake(n, xf);
	        });
	    }();

	    var _xtakeWhile = function () {
	        function XTakeWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
	        };
	        return _curry2(function _xtakeWhile(f, xf) {
	            return new XTakeWhile(f, xf);
	        });
	    }();

	    var _xwrap = function () {
	        function XWrap(fn) {
	            this.f = fn;
	        }
	        XWrap.prototype['@@transducer/init'] = function () {
	            throw new Error('init not implemented on XWrap');
	        };
	        XWrap.prototype['@@transducer/result'] = function (acc) {
	            return acc;
	        };
	        XWrap.prototype['@@transducer/step'] = function (acc, x) {
	            return this.f(acc, x);
	        };
	        return function _xwrap(fn) {
	            return new XWrap(fn);
	        };
	    }();

	    /**
	     * Adds two numbers. Equivalent to `a + b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Number}
	     * @see R.subtract
	     * @example
	     *
	     *      R.add(2, 3);       //=>  5
	     *      R.add(7)(10);      //=> 17
	     */
	    var add = _curry2(function add(a, b) {
	        return a + b;
	    });

	    /**
	     * Applies a function to the value at the given index of an array,
	     * returning a new copy of the array with the element at the given
	     * index replaced with the result of the function application.
	     * @see R.update
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> a) -> Number -> [a] -> [a]
	     * @param {Function} fn The function to apply.
	     * @param {Number} idx The index.
	     * @param {Array|Arguments} list An array-like object whose value
	     *        at the supplied index will be replaced.
	     * @return {Array} A copy of the supplied array-like object with
	     *         the element at index `idx` replaced with the value
	     *         returned by applying `fn` to the existing element.
	     * @example
	     *
	     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var adjust = _curry3(function adjust(fn, idx, list) {
	        if (idx >= list.length || idx < -list.length) {
	            return list;
	        }
	        var start = idx < 0 ? list.length : 0;
	        var _idx = start + idx;
	        var _list = _concat(list);
	        _list[_idx] = fn(list[_idx]);
	        return _list;
	    });

	    /**
	     * Returns a function that always returns the given value. Note that for
	     * non-primitives the value returned is a reference to the original value.
	     *
	     * This function is known as `const`, `constant`, or `K` (for K combinator)
	     * in other languages and libraries.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> (* -> a)
	     * @param {*} val The value to wrap in a function
	     * @return {Function} A Function :: * -> val.
	     * @example
	     *
	     *      var t = R.always('Tee');
	     *      t(); //=> 'Tee'
	     */
	    var always = _curry1(function always(val) {
	        return function () {
	            return val;
	        };
	    });

	    /**
	     * Returns a new list, composed of n-tuples of consecutive elements
	     * If `n` is greater than the length of the list, an empty list is returned.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @param {Number} n The size of the tuples to create
	     * @param {Array} list The list to split into `n`-tuples
	     * @return {Array} The new list.
	     * @example
	     *
	     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
	     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
	     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
	     */
	    var aperture = _curry2(function aperture(n, list) {
	        var idx = 0;
	        var limit = list.length - (n - 1);
	        var acc = new Array(limit >= 0 ? limit : 0);
	        while (idx < limit) {
	            acc[idx] = _slice(list, idx, idx + n);
	            idx += 1;
	        }
	        return acc;
	    });

	    /**
	     * Returns a new list containing the contents of the given list, followed by the given
	     * element.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The element to add to the end of the new list.
	     * @param {Array} list The list whose contents will be added to the beginning of the output
	     *        list.
	     * @return {Array} A new list containing the contents of the old list followed by `el`.
	     * @see R.prepend
	     * @example
	     *
	     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
	     *      R.append('tests', []); //=> ['tests']
	     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
	     */
	    var append = _curry2(function append(el, list) {
	        return _concat(list, [el]);
	    });

	    /**
	     * Applies function `fn` to the argument list `args`. This is useful for
	     * creating a fixed-arity function from a variadic function. `fn` should
	     * be a bound function if context is significant.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (*... -> a) -> [*] -> a
	     * @param {Function} fn
	     * @param {Array} args
	     * @return {*}
	     * @see R.call, R.unapply
	     * @example
	     *
	     *      var nums = [1, 2, 3, -99, 42, 6, 7];
	     *      R.apply(Math.max, nums); //=> 42
	     */
	    var apply = _curry2(function apply(fn, args) {
	        return fn.apply(this, args);
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the specified
	     * property with the given value.  Note that this copies and flattens
	     * prototype properties onto the new object as well.  All non-primitive
	     * properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig String -> a -> {k: v} -> {k: v}
	     * @param {String} prop the property name to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except for the specified property.
	     * @see R.dissoc
	     * @example
	     *
	     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
	     */
	    var assoc = _curry3(function assoc(prop, val, obj) {
	        var result = {};
	        for (var p in obj) {
	            result[p] = obj[p];
	        }
	        result[prop] = val;
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the nodes
	     * required to create the given path, and placing the specific value at the
	     * tail end of that path.  Note that this copies and flattens prototype
	     * properties onto the new object as well.  All non-primitive properties
	     * are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> a -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except along the specified path.
	     * @see R.dissocPath
	     * @example
	     *
	     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
	     */
	    var assocPath = _curry3(function assocPath(path, val, obj) {
	        switch (path.length) {
	        case 0:
	            return obj;
	        case 1:
	            return assoc(path[0], val, obj);
	        default:
	            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
	        }
	    });

	    /**
	     * Creates a function that is bound to a context.
	     * Note: `R.bind` does not provide the additional argument-binding capabilities of
	     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @category Object
	     * @see R.partial
	     * @sig (* -> *) -> {*} -> (* -> *)
	     * @param {Function} fn The function to bind to context
	     * @param {Object} thisObj The context to bind `fn` to
	     * @return {Function} A function that will execute in the context of `thisObj`.
	     */
	    var bind = _curry2(function bind(fn, thisObj) {
	        return _arity(fn.length, function () {
	            return fn.apply(thisObj, arguments);
	        });
	    });

	    /**
	     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first
	     * function if it is false-y and the result of the second function otherwise.  Note that this is
	     * short-circuited, meaning that the second function will not be invoked if the first returns a false-y
	     * value.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
	     * @see R.and
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0 };
	     *      var f = R.both(gt10, even);
	     *      f(100); //=> true
	     *      f(101); //=> false
	     */
	    var both = _curry2(function both(f, g) {
	        return function _both() {
	            return f.apply(this, arguments) && g.apply(this, arguments);
	        };
	    });

	    /**
	     * Makes a comparator function out of a function that reports whether the first element is less than the second.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a, b -> Boolean) -> (a, b -> Number)
	     * @param {Function} pred A predicate function of arity two.
	     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
	     * @example
	     *
	     *      var cmp = R.comparator(function(a, b) {
	     *        return a.age < b.age;
	     *      });
	     *      var people = [
	     *        // ...
	     *      ];
	     *      R.sort(cmp, people);
	     */
	    var comparator = _curry1(function comparator(pred) {
	        return function (a, b) {
	            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
	        };
	    });

	    /**
	     * Takes a function `f` and returns a function `g` such that:
	     *
	     *   - applying `g` to zero or more arguments will give __true__ if applying
	     *     the same arguments to `f` gives a logical __false__ value; and
	     *
	     *   - applying `g` to zero or more arguments will give __false__ if applying
	     *     the same arguments to `f` gives a logical __true__ value.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> *) -> (*... -> Boolean)
	     * @param {Function} f
	     * @return {Function}
	     * @see R.not
	     * @example
	     *
	     *      var isEven = function(n) { return n % 2 === 0; };
	     *      var isOdd = R.complement(isEven);
	     *      isOdd(21); //=> true
	     *      isOdd(42); //=> false
	     */
	    var complement = _curry1(_complement);

	    /**
	     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
	     * `R.cond` takes a list of [predicate, transform] pairs. All of the
	     * arguments to `fn` are applied to each of the predicates in turn
	     * until one returns a "truthy" value, at which point `fn` returns the
	     * result of applying its arguments to the corresponding transformer.
	     * If none of the predicates matches, `fn` returns undefined.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
	     * @param {Array} pairs
	     * @return {Function}
	     * @example
	     *
	     *      var fn = R.cond([
	     *        [R.equals(0),   R.always('water freezes at 0°C')],
	     *        [R.equals(100), R.always('water boils at 100°C')],
	     *        [R.T,           function(temp) { return 'nothing special happens at ' + temp + '°C'; }]
	     *      ]);
	     *      fn(0); //=> 'water freezes at 0°C'
	     *      fn(50); //=> 'nothing special happens at 50°C'
	     *      fn(100); //=> 'water boils at 100°C'
	     */
	    var cond = _curry1(function cond(pairs) {
	        return function () {
	            var idx = 0;
	            while (idx < pairs.length) {
	                if (pairs[idx][0].apply(this, arguments)) {
	                    return pairs[idx][1].apply(this, arguments);
	                }
	                idx += 1;
	            }
	        };
	    });

	    /**
	     * Returns `true` if the `x` is found in the `list`, using `pred` as an
	     * equality predicate for `x`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {*} x The item to find
	     * @param {Array} list The list to iterate over
	     * @return {Boolean} `true` if `x` is in `list`, else `false`.
	     * @example
	     *
	     *      var xs = [{x: 12}, {x: 11}, {x: 10}];
	     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 10}, xs); //=> true
	     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 1}, xs); //=> false
	     */
	    var containsWith = _curry3(_containsWith);

	    /**
	     * Counts the elements of a list according to how many match each value
	     * of a key generated by the supplied function. Returns an object
	     * mapping the keys produced by `fn` to the number of occurrences in
	     * the list. Note that all keys are coerced to strings because of how
	     * JavaScript objects work.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a -> String) -> [a] -> {*}
	     * @param {Function} fn The function used to map values to keys.
	     * @param {Array} list The list to count elements from.
	     * @return {Object} An object mapping keys to number of occurrences in the list.
	     * @example
	     *
	     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
	     *      var letters = R.split('', 'abcABCaaaBBc');
	     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
	     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
	     */
	    var countBy = _curry2(function countBy(fn, list) {
	        var counts = {};
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            var key = fn(list[idx]);
	            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
	            idx += 1;
	        }
	        return counts;
	    });

	    /**
	     * Creates an object containing a single key:value pair.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig String -> a -> {String:a}
	     * @param {String} key
	     * @param {*} val
	     * @return {Object}
	     * @example
	     *
	     *      var matchPhrases = R.compose(
	     *        R.createMapEntry('must'),
	     *        R.map(R.createMapEntry('match_phrase'))
	     *      );
	     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
	     */
	    var createMapEntry = _curry2(function createMapEntry(key, val) {
	        var obj = {};
	        obj[key] = val;
	        return obj;
	    });

	    /**
	     * Returns a curried equivalent of the provided function, with the
	     * specified arity. The curried function has two unusual capabilities.
	     * First, its arguments needn't be provided one at a time. If `g` is
	     * `R.curryN(3, f)`, the following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`,
	     * the following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curry
	     * @example
	     *
	     *      var addFourNumbers = function() {
	     *        return R.sum([].slice.call(arguments, 0, 4));
	     *      };
	     *
	     *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curryN = _curry2(function curryN(length, fn) {
	        if (length === 1) {
	            return _curry1(fn);
	        }
	        return _arity(length, _curryN(length, [], fn));
	    });

	    /**
	     * Decrements its argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.inc
	     * @example
	     *
	     *      R.dec(42); //=> 41
	     */
	    var dec = add(-1);

	    /**
	     * Returns the second argument if it is not null or undefined. If it is null
	     * or undefined, the first (default) argument is returned.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig a -> b -> a | b
	     * @param {a} val The default value.
	     * @param {b} val The value to return if it is not null or undefined
	     * @return {*} The the second value or the default value
	     * @example
	     *
	     *      var defaultTo42 = defaultTo(42);
	     *
	     *      defaultTo42(null);  //=> 42
	     *      defaultTo42(undefined);  //=> 42
	     *      defaultTo42('Ramda');  //=> 'Ramda'
	     */
	    var defaultTo = _curry2(function defaultTo(d, v) {
	        return v == null ? d : v;
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
	     * Duplication is determined according to the value returned by applying the supplied predicate to two list
	     * elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @see R.difference
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @example
	     *
	     *      function cmp(x, y) { return x.a === y.a; }
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
	     *      var l2 = [{a: 3}, {a: 4}];
	     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
	     */
	    var differenceWith = _curry3(function differenceWith(pred, first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        var containsPred = containsWith(pred);
	        while (idx < firstLen) {
	            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
	                out[out.length] = first[idx];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object that does not contain a `prop` property.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig String -> {k: v} -> {k: v}
	     * @param {String} prop the name of the property to dissociate
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original but without the specified property
	     * @see R.assoc
	     * @example
	     *
	     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
	     */
	    var dissoc = _curry2(function dissoc(prop, obj) {
	        var result = {};
	        for (var p in obj) {
	            if (p !== prop) {
	                result[p] = obj[p];
	            }
	        }
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, omitting the property at the
	     * given path. Note that this copies and flattens prototype properties
	     * onto the new object as well.  All non-primitive properties are copied
	     * by reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object without the property at path
	     * @see R.assocPath
	     * @example
	     *
	     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
	     */
	    var dissocPath = _curry2(function dissocPath(path, obj) {
	        switch (path.length) {
	        case 0:
	            return obj;
	        case 1:
	            return dissoc(path[0], obj);
	        default:
	            var head = path[0];
	            var tail = _slice(path, 1);
	            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
	        }
	    });

	    /**
	     * Divides two numbers. Equivalent to `a / b`.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a / b`.
	     * @see R.multiply
	     * @example
	     *
	     *      R.divide(71, 100); //=> 0.71
	     *
	     *      var half = R.divide(R.__, 2);
	     *      half(42); //=> 21
	     *
	     *      var reciprocal = R.divide(1);
	     *      reciprocal(4);   //=> 0.25
	     */
	    var divide = _curry2(function divide(a, b) {
	        return a / b;
	    });

	    /**
	     * Returns a new list containing all but last the`n` elements of a given list,
	     * passing each value from the right to the supplied predicate function, skipping
	     * elements while the predicate function returns `true`. The predicate function
	     * is passed one argument: (value)*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeLastWhile
	     * @example
	     *
	     *      var lteThree = function(x) {
	     *        return x <= 3;
	     *      };
	     *
	     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2]
	     */
	    var dropLastWhile = _curry2(function dropLastWhile(pred, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && pred(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, 0, idx + 1);
	    });

	    /**
	     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first
	     * function if it is truth-y and the result of the second function otherwise.  Note that this is
	     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y
	     * value.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
	     * @see R.or
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0 };
	     *      var f = R.either(gt10, even);
	     *      f(101); //=> true
	     *      f(8); //=> true
	     */
	    var either = _curry2(function either(f, g) {
	        return function _either() {
	            return f.apply(this, arguments) || g.apply(this, arguments);
	        };
	    });

	    /**
	     * Returns the empty value of its argument's type. Ramda defines the empty
	     * value of Array (`[]`), Object (`{}`), and String (`''`). Other types are
	     * supported if they define `<Type>.empty` and/or `<Type>.prototype.empty`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> a
	     * @param {*} x
	     * @return {*}
	     * @example
	     *
	     *      R.empty(Just(42));      //=> Nothing()
	     *      R.empty([1, 2, 3]);     //=> []
	     *      R.empty('unicorns');    //=> ''
	     *      R.empty({x: 1, y: 2});  //=> {}
	     */
	    var empty = _curry1(function empty(x) {
	        if (x != null && typeof x.empty === 'function') {
	            return x.empty();
	        } else if (x != null && typeof x.constructor != null && typeof x.constructor.empty === 'function') {
	            return x.constructor.empty();
	        } else {
	            switch (Object.prototype.toString.call(x)) {
	            case '[object Array]':
	                return [];
	            case '[object Object]':
	                return {};
	            case '[object String]':
	                return '';
	            }
	        }
	    });

	    /**
	     * Creates a new object by recursively evolving a shallow copy of `object`, according to the
	     * `transformation` functions. All non-primitive properties are copied by reference.
	     *
	     * A `tranformation` function will not be invoked if its corresponding key does not exist in
	     * the evolved object.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
	     * @param {Object} transformations The object specifying transformation functions to apply
	     *        to the object.
	     * @param {Object} object The object to be transformed.
	     * @return {Object} The transformed object.
	     * @example
	     *
	     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
	     *      var transformations = {
	     *        firstName: R.trim,
	     *        lastName: R.trim, // Will not get invoked.
	     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
	     *      };
	     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
	     */
	    var evolve = _curry2(function evolve(transformations, object) {
	        var transformation, key, type, result = {};
	        for (key in object) {
	            transformation = transformations[key];
	            type = typeof transformation;
	            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
	        }
	        return result;
	    });

	    /**
	     * Creates a new object out of a list key-value pairs.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [[k,v]] -> {k: v}
	     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
	     * @return {Object} The object made by pairing up `keys` and `values`.
	     * @see R.toPairs
	     * @example
	     *
	     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
	     */
	    var fromPairs = _curry1(function fromPairs(pairs) {
	        var idx = 0, len = pairs.length, out = {};
	        while (idx < len) {
	            if (_isArray(pairs[idx]) && pairs[idx].length) {
	                out[pairs[idx][0]] = pairs[idx][1];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns `true` if the first argument is greater than the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.lt
	     * @example
	     *
	     *      R.gt(2, 1); //=> true
	     *      R.gt(2, 2); //=> false
	     *      R.gt(2, 3); //=> false
	     *      R.gt('a', 'z'); //=> false
	     *      R.gt('z', 'a'); //=> true
	     */
	    var gt = _curry2(function gt(a, b) {
	        return a > b;
	    });

	    /**
	     * Returns `true` if the first argument is greater than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.lte
	     * @example
	     *
	     *      R.gte(2, 1); //=> true
	     *      R.gte(2, 2); //=> true
	     *      R.gte(2, 3); //=> false
	     *      R.gte('a', 'z'); //=> false
	     *      R.gte('z', 'a'); //=> true
	     */
	    var gte = _curry2(function gte(a, b) {
	        return a >= b;
	    });

	    /**
	     * Returns whether or not an object has an own property with
	     * the specified name
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      var hasName = R.has('name');
	     *      hasName({name: 'alice'});   //=> true
	     *      hasName({name: 'bob'});     //=> true
	     *      hasName({});                //=> false
	     *
	     *      var point = {x: 0, y: 0};
	     *      var pointHas = R.has(R.__, point);
	     *      pointHas('x');  //=> true
	     *      pointHas('y');  //=> true
	     *      pointHas('z');  //=> false
	     */
	    var has = _curry2(_has);

	    /**
	     * Returns whether or not an object or its prototype chain has
	     * a property with the specified name
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      function Rectangle(width, height) {
	     *        this.width = width;
	     *        this.height = height;
	     *      }
	     *      Rectangle.prototype.area = function() {
	     *        return this.width * this.height;
	     *      };
	     *
	     *      var square = new Rectangle(2, 2);
	     *      R.hasIn('width', square);  //=> true
	     *      R.hasIn('area', square);  //=> true
	     */
	    var hasIn = _curry2(function hasIn(prop, obj) {
	        return prop in obj;
	    });

	    /**
	     * Returns true if its arguments are identical, false otherwise. Values are
	     * identical if they reference the same memory. `NaN` is identical to `NaN`;
	     * `0` and `-0` are not identical.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      var o = {};
	     *      R.identical(o, o); //=> true
	     *      R.identical(1, 1); //=> true
	     *      R.identical(1, '1'); //=> false
	     *      R.identical([], []); //=> false
	     *      R.identical(0, -0); //=> false
	     *      R.identical(NaN, NaN); //=> true
	     */
	    // SameValue algorithm
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Step 6.a: NaN == NaN
	    var identical = _curry2(function identical(a, b) {
	        // SameValue algorithm
	        if (a === b) {
	            // Steps 1-5, 7-10
	            // Steps 6.b-6.e: +0 != -0
	            return a !== 0 || 1 / a === 1 / b;
	        } else {
	            // Step 6.a: NaN == NaN
	            return a !== a && b !== b;
	        }
	    });

	    /**
	     * A function that does nothing but return the parameter supplied to it. Good as a default
	     * or placeholder function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> a
	     * @param {*} x The value to return.
	     * @return {*} The input value, `x`.
	     * @example
	     *
	     *      R.identity(1); //=> 1
	     *
	     *      var obj = {};
	     *      R.identity(obj) === obj; //=> true
	     */
	    var identity = _curry1(_identity);

	    /**
	     * Creates a function that will process either the `onTrue` or the `onFalse` function depending
	     * upon the result of the `condition` predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
	     * @param {Function} condition A predicate function
	     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
	     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
	     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
	     *                    function depending upon the result of the `condition` predicate.
	     * @example
	     *
	     *      // Flatten all arrays in the list but leave other values alone.
	     *      var flattenArrays = R.map(R.ifElse(Array.isArray, R.flatten, R.identity));
	     *
	     *      flattenArrays([[0], [[10], [8]], 1234, {}]); //=> [[0], [10, 8], 1234, {}]
	     *      flattenArrays([[[10], 123], [8, [10]], "hello"]); //=> [[10, 123], [8, 10], "hello"]
	     */
	    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
	        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
	            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
	        });
	    });

	    /**
	     * Increments its argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.dec
	     * @example
	     *
	     *      R.inc(42); //=> 43
	     */
	    var inc = add(1);

	    /**
	     * Inserts the supplied element into the list, at index `index`.  _Note
	     * that this is not destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} index The position to insert the element
	     * @param {*} elt The element to insert into the Array
	     * @param {Array} list The list to insert into
	     * @return {Array} A new Array with `elt` inserted at `index`.
	     * @example
	     *
	     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
	     */
	    var insert = _curry3(function insert(idx, elt, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        var result = _slice(list);
	        result.splice(idx, 0, elt);
	        return result;
	    });

	    /**
	     * Inserts the sub-list into the list, at index `index`.  _Note  that this
	     * is not destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a] -> [a]
	     * @param {Number} index The position to insert the sub-list
	     * @param {Array} elts The sub-list to insert into the Array
	     * @param {Array} list The list to insert the sub-list into
	     * @return {Array} A new Array with `elts` inserted starting at `index`.
	     * @example
	     *
	     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
	     */
	    var insertAll = _curry3(function insertAll(idx, elts, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
	    });

	    /**
	     * See if an object (`val`) is an instance of the supplied constructor.
	     * This function will check up the inheritance chain, if any.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig (* -> {*}) -> a -> Boolean
	     * @param {Object} ctor A constructor
	     * @param {*} val The value to test
	     * @return {Boolean}
	     * @example
	     *
	     *      R.is(Object, {}); //=> true
	     *      R.is(Number, 1); //=> true
	     *      R.is(Object, 1); //=> false
	     *      R.is(String, 's'); //=> true
	     *      R.is(String, new String('')); //=> true
	     *      R.is(Object, new String('')); //=> true
	     *      R.is(Object, 's'); //=> false
	     *      R.is(Number, {}); //=> false
	     */
	    var is = _curry2(function is(Ctor, val) {
	        return val != null && val.constructor === Ctor || val instanceof Ctor;
	    });

	    /**
	     * Tests whether or not an object is similar to an array.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @category List
	     * @sig * -> Boolean
	     * @param {*} x The object to test.
	     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	     * @example
	     *
	     *      R.isArrayLike([]); //=> true
	     *      R.isArrayLike(true); //=> false
	     *      R.isArrayLike({}); //=> false
	     *      R.isArrayLike({length: 10}); //=> false
	     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	     */
	    var isArrayLike = _curry1(function isArrayLike(x) {
	        if (_isArray(x)) {
	            return true;
	        }
	        if (!x) {
	            return false;
	        }
	        if (typeof x !== 'object') {
	            return false;
	        }
	        if (x instanceof String) {
	            return false;
	        }
	        if (x.nodeType === 1) {
	            return !!x.length;
	        }
	        if (x.length === 0) {
	            return true;
	        }
	        if (x.length > 0) {
	            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	        }
	        return false;
	    });

	    /**
	     * Reports whether the list has zero elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [a] -> Boolean
	     * @param {Array} list
	     * @return {Boolean}
	     * @example
	     *
	     *      R.isEmpty([1, 2, 3]);   //=> false
	     *      R.isEmpty([]);          //=> true
	     *      R.isEmpty('');          //=> true
	     *      R.isEmpty(null);        //=> false
	     *      R.isEmpty(R.keys({}));  //=> true
	     *      R.isEmpty({});          //=> false ({} does not have a length property)
	     *      R.isEmpty({length: 0}); //=> true
	     */
	    var isEmpty = _curry1(function isEmpty(list) {
	        return Object(list).length === 0;
	    });

	    /**
	     * Checks if the input value is `null` or `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig * -> Boolean
	     * @param {*} x The value to test.
	     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
	     * @example
	     *
	     *      R.isNil(null); //=> true
	     *      R.isNil(undefined); //=> true
	     *      R.isNil(0); //=> false
	     *      R.isNil([]); //=> false
	     */
	    var isNil = _curry1(function isNil(x) {
	        return x == null;
	    });

	    /**
	     * Returns a list containing the names of all the enumerable own
	     * properties of the supplied object.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own properties.
	     * @example
	     *
	     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	     */
	    // cover IE < 9 keys issues
	    var keys = function () {
	        // cover IE < 9 keys issues
	        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	        var nonEnumerableProps = [
	            'constructor',
	            'valueOf',
	            'isPrototypeOf',
	            'toString',
	            'propertyIsEnumerable',
	            'hasOwnProperty',
	            'toLocaleString'
	        ];
	        var contains = function contains(list, item) {
	            var idx = 0;
	            while (idx < list.length) {
	                if (list[idx] === item) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        };
	        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
	            return Object(obj) !== obj ? [] : Object.keys(obj);
	        }) : _curry1(function keys(obj) {
	            if (Object(obj) !== obj) {
	                return [];
	            }
	            var prop, ks = [], nIdx;
	            for (prop in obj) {
	                if (_has(prop, obj)) {
	                    ks[ks.length] = prop;
	                }
	            }
	            if (hasEnumBug) {
	                nIdx = nonEnumerableProps.length - 1;
	                while (nIdx >= 0) {
	                    prop = nonEnumerableProps[nIdx];
	                    if (_has(prop, obj) && !contains(ks, prop)) {
	                        ks[ks.length] = prop;
	                    }
	                    nIdx -= 1;
	                }
	            }
	            return ks;
	        });
	    }();

	    /**
	     * Returns a list containing the names of all the
	     * properties of the supplied object, including prototype properties.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.keysIn(f); //=> ['x', 'y']
	     */
	    var keysIn = _curry1(function keysIn(obj) {
	        var prop, ks = [];
	        for (prop in obj) {
	            ks[ks.length] = prop;
	        }
	        return ks;
	    });

	    /**
	     * Returns the number of elements in the array by returning `list.length`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> Number
	     * @param {Array} list The array to inspect.
	     * @return {Number} The length of the array.
	     * @example
	     *
	     *      R.length([]); //=> 0
	     *      R.length([1, 2, 3]); //=> 3
	     */
	    var length = _curry1(function length(list) {
	        return list != null && is(Number, list.length) ? list.length : NaN;
	    });

	    /**
	     * Returns `true` if the first argument is less than the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.gt
	     * @example
	     *
	     *      R.lt(2, 1); //=> false
	     *      R.lt(2, 2); //=> false
	     *      R.lt(2, 3); //=> true
	     *      R.lt('a', 'z'); //=> true
	     *      R.lt('z', 'a'); //=> false
	     */
	    var lt = _curry2(function lt(a, b) {
	        return a < b;
	    });

	    /**
	     * Returns `true` if the first argument is less than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.gte
	     * @example
	     *
	     *      R.lte(2, 1); //=> false
	     *      R.lte(2, 2); //=> true
	     *      R.lte(2, 3); //=> true
	     *      R.lte('a', 'z'); //=> true
	     *      R.lte('z', 'a'); //=> false
	     */
	    var lte = _curry2(function lte(a, b) {
	        return a <= b;
	    });

	    /**
	     * The mapAccum function behaves like a combination of map and reduce; it applies a
	     * function to each element of a list, passing an accumulating parameter from left to
	     * right, and returning a final value of this accumulator together with the new list.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should return
	     * a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = function(a, b) {
	     *        return [a + b, a + b];
	     *      }
	     *
	     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
	     */
	    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
	        var idx = 0, len = list.length, result = [], tuple = [acc];
	        while (idx < len) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx += 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * The mapAccumRight function behaves like a combination of map and reduce; it applies a
	     * function to each element of a list, passing an accumulating parameter from right
	     * to left, and returning a final value of this accumulator together with the new list.
	     *
	     * Similar to `mapAccum`, except moves through the input list from the right to the
	     * left.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should return
	     * a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = function(a, b) {
	     *        return [a + b, a + b];
	     *      }
	     *
	     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
	     */
	    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
	        var idx = list.length - 1, result = [], tuple = [acc];
	        while (idx >= 0) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx -= 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * Tests a regular expression against a String. Note that this function
	     * will return an empty array when there are no matches. This differs
	     * from [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
	     * which returns `null` when there are no matches.
	     *
	     * @func
	     * @memberOf R
	     * @see R.test
	     * @category String
	     * @sig RegExp -> String -> [String | Undefined]
	     * @param {RegExp} rx A regular expression.
	     * @param {String} str The string to match against
	     * @return {Array} The list of matches or empty array.
	     * @example
	     *
	     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
	     *      R.match(/a/, 'b'); //=> []
	     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
	     */
	    var match = _curry2(function match(rx, str) {
	        return str.match(rx) || [];
	    });

	    /**
	     * mathMod behaves like the modulo operator should mathematically, unlike the `%`
	     * operator (and by extension, R.modulo). So while "-17 % 5" is -2,
	     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
	     * when the modulus is zero or negative.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} m The dividend.
	     * @param {Number} p the modulus.
	     * @return {Number} The result of `b mod a`.
	     * @example
	     *
	     *      R.mathMod(-17, 5);  //=> 3
	     *      R.mathMod(17, 5);   //=> 2
	     *      R.mathMod(17, -5);  //=> NaN
	     *      R.mathMod(17, 0);   //=> NaN
	     *      R.mathMod(17.2, 5); //=> NaN
	     *      R.mathMod(17, 5.3); //=> NaN
	     *
	     *      var clock = R.mathMod(R.__, 12);
	     *      clock(15); //=> 3
	     *      clock(24); //=> 0
	     *
	     *      var seventeenMod = R.mathMod(17);
	     *      seventeenMod(3);  //=> 2
	     *      seventeenMod(4);  //=> 1
	     *      seventeenMod(10); //=> 7
	     */
	    var mathMod = _curry2(function mathMod(m, p) {
	        if (!_isInteger(m)) {
	            return NaN;
	        }
	        if (!_isInteger(p) || p < 1) {
	            return NaN;
	        }
	        return (m % p + p) % p;
	    });

	    /**
	     * Returns the larger of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.maxBy, R.min
	     * @example
	     *
	     *      R.max(789, 123); //=> 789
	     *      R.max('a', 'b'); //=> 'b'
	     */
	    var max = _curry2(function max(a, b) {
	        return b > a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces
	     * the larger result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.max, R.minBy
	     * @example
	     *
	     *      R.maxBy(function(n) { return n * n; }, -3, 2); //=> -3
	     */
	    var maxBy = _curry3(function maxBy(f, a, b) {
	        return f(b) > f(a) ? b : a;
	    });

	    /**
	     * Create a new object with the own properties of `a`
	     * merged with the own properties of object `b`.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> {k: v} -> {k: v}
	     * @param {Object} a
	     * @param {Object} b
	     * @return {Object}
	     * @example
	     *
	     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
	     *      //=> { 'name': 'fred', 'age': 40 }
	     *
	     *      var resetToDefault = R.merge(R.__, {x: 0});
	     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
	     */
	    var merge = _curry2(function merge(a, b) {
	        var result = {};
	        var ks = keys(a);
	        var idx = 0;
	        while (idx < ks.length) {
	            result[ks[idx]] = a[ks[idx]];
	            idx += 1;
	        }
	        ks = keys(b);
	        idx = 0;
	        while (idx < ks.length) {
	            result[ks[idx]] = b[ks[idx]];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns the smaller of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.minBy, R.max
	     * @example
	     *
	     *      R.min(789, 123); //=> 123
	     *      R.min('a', 'b'); //=> 'a'
	     */
	    var min = _curry2(function min(a, b) {
	        return b < a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces
	     * the smaller result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.min, R.maxBy
	     * @example
	     *
	     *      R.minBy(function(n) { return n * n; }, -3, 2); //=> 2
	     */
	    var minBy = _curry3(function minBy(f, a, b) {
	        return f(b) < f(a) ? b : a;
	    });

	    /**
	     * Divides the second parameter by the first and returns the remainder.
	     * Note that this functions preserves the JavaScript-style behavior for
	     * modulo. For mathematical modulo see `mathMod`
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The value to the divide.
	     * @param {Number} b The pseudo-modulus
	     * @return {Number} The result of `b % a`.
	     * @see R.mathMod
	     * @example
	     *
	     *      R.modulo(17, 3); //=> 2
	     *      // JS behavior:
	     *      R.modulo(-17, 3); //=> -2
	     *      R.modulo(17, -3); //=> 2
	     *
	     *      var isOdd = R.modulo(R.__, 2);
	     *      isOdd(42); //=> 0
	     *      isOdd(21); //=> 1
	     */
	    var modulo = _curry2(function modulo(a, b) {
	        return a % b;
	    });

	    /**
	     * Multiplies two numbers. Equivalent to `a * b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a * b`.
	     * @see R.divide
	     * @example
	     *
	     *      var double = R.multiply(2);
	     *      var triple = R.multiply(3);
	     *      double(3);       //=>  6
	     *      triple(4);       //=> 12
	     *      R.multiply(2, 5);  //=> 10
	     */
	    var multiply = _curry2(function multiply(a, b) {
	        return a * b;
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
	     * parameters. Any extraneous parameters will not be passed to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} n The desired arity of the new function.
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity `n`.
	     * @example
	     *
	     *      var takesTwoArgs = function(a, b) {
	     *        return [a, b];
	     *      };
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.nAry(1, takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only `n` arguments are passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var nAry = _curry2(function nAry(n, fn) {
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.call(this);
	            };
	        case 1:
	            return function (a0) {
	                return fn.call(this, a0);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.call(this, a0, a1);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.call(this, a0, a1, a2);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.call(this, a0, a1, a2, a3);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.call(this, a0, a1, a2, a3, a4);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	            };
	        default:
	            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
	        }
	    });

	    /**
	     * Negates its argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @example
	     *
	     *      R.negate(42); //=> -42
	     */
	    var negate = _curry1(function negate(n) {
	        return -n;
	    });

	    /**
	     * A function that returns the `!` of its argument. It will return `true` when
	     * passed false-y value, and `false` when passed a truth-y one.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig * -> Boolean
	     * @param {*} a any value
	     * @return {Boolean} the logical inverse of passed argument.
	     * @see R.complement
	     * @example
	     *
	     *      R.not(true); //=> false
	     *      R.not(false); //=> true
	     *      R.not(0); => true
	     *      R.not(1); => false
	     */
	    var not = _curry1(function not(a) {
	        return !a;
	    });

	    /**
	     * Returns the nth element of the given list or string.
	     * If n is negative the element at index length + n is returned.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> a | Undefined
	     * @sig Number -> String -> String
	     * @param {Number} offset
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      var list = ['foo', 'bar', 'baz', 'quux'];
	     *      R.nth(1, list); //=> 'bar'
	     *      R.nth(-1, list); //=> 'quux'
	     *      R.nth(-99, list); //=> undefined
	     *
	     *      R.nth('abc', 2); //=> 'c'
	     *      R.nth('abc', 3); //=> ''
	     */
	    var nth = _curry2(function nth(offset, list) {
	        var idx = offset < 0 ? list.length + offset : offset;
	        return _isString(list) ? list.charAt(idx) : list[idx];
	    });

	    /**
	     * Returns a function which returns its nth argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> *... -> *
	     * @param {Number} n
	     * @return {Function}
	     * @example
	     *
	     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
	     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
	     */
	    var nthArg = _curry1(function nthArg(n) {
	        return function () {
	            return nth(n, arguments);
	        };
	    });

	    /**
	     * Returns the nth character of the given string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {String} str
	     * @return {String}
	     * @deprecated since v0.16.0
	     * @example
	     *
	     *      R.nthChar(2, 'Ramda'); //=> 'm'
	     *      R.nthChar(-2, 'Ramda'); //=> 'd'
	     */
	    var nthChar = _curry2(function nthChar(n, str) {
	        return str.charAt(n < 0 ? str.length + n : n);
	    });

	    /**
	     * Returns the character code of the nth character of the given string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig Number -> String -> Number
	     * @param {Number} n
	     * @param {String} str
	     * @return {Number}
	     * @deprecated since v0.16.0
	     * @example
	     *
	     *      R.nthCharCode(2, 'Ramda'); //=> 'm'.charCodeAt(0)
	     *      R.nthCharCode(-2, 'Ramda'); //=> 'd'.charCodeAt(0)
	     */
	    var nthCharCode = _curry2(function nthCharCode(n, str) {
	        return str.charCodeAt(n < 0 ? str.length + n : n);
	    });

	    /**
	     * Returns a singleton array containing the value provided.
	     *
	     * Note this `of` is different from the ES6 `of`; See
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig a -> [a]
	     * @param {*} x any value
	     * @return {Array} An array wrapping `x`.
	     * @example
	     *
	     *      R.of(null); //=> [null]
	     *      R.of([42]); //=> [[42]]
	     */
	    var of = _curry1(function of(x) {
	        return [x];
	    });

	    /**
	     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
	     * `fn` can only ever be called once, no matter how many times the returned function is
	     * invoked.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a... -> b) -> (a... -> b)
	     * @param {Function} fn The function to wrap in a call-only-once wrapper.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var addOneOnce = R.once(function(x){ return x + 1; });
	     *      addOneOnce(10); //=> 11
	     *      addOneOnce(addOneOnce(50)); //=> 11
	     */
	    var once = _curry1(function once(fn) {
	        var called = false, result;
	        return function () {
	            if (called) {
	                return result;
	            }
	            called = true;
	            result = fn.apply(this, arguments);
	            return result;
	        };
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the given value.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> (a -> a) -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
	     */
	    var over = function () {
	        var Identity = function (x) {
	            return {
	                value: x,
	                map: function (f) {
	                    return Identity(f(x));
	                }
	            };
	        };
	        return _curry3(function over(lens, f, x) {
	            return lens(function (y) {
	                return Identity(f(y));
	            })(x).value;
	        });
	    }();

	    /**
	     * Retrieve the value at a given path.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> {k: v} -> v | Undefined
	     * @param {Array} path The path to use.
	     * @return {*} The data at `path`.
	     * @example
	     *
	     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
	     */
	    var path = _curry2(function path(paths, obj) {
	        if (obj == null) {
	            return;
	        } else {
	            var val = obj;
	            for (var idx = 0, len = paths.length; idx < len && val != null; idx += 1) {
	                val = val[paths[idx]];
	            }
	            return val;
	        }
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
	     * property is ignored.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.omit
	     * @example
	     *
	     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	     */
	    var pick = _curry2(function pick(names, obj) {
	        var result = {};
	        var idx = 0;
	        while (idx < names.length) {
	            if (names[idx] in obj) {
	                result[names[idx]] = obj[names[idx]];
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
	     */
	    var pickAll = _curry2(function pickAll(names, obj) {
	        var result = {};
	        var idx = 0;
	        var len = names.length;
	        while (idx < len) {
	            var name = names[idx];
	            result[name] = obj[name];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys that
	     * satisfy the supplied predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
	     * @param {Function} pred A predicate to determine whether or not a key
	     *        should be included on the output object.
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties that satisfy `pred`
	     *         on it.
	     * @see R.pick
	     * @example
	     *
	     *      var isUpperCase = function(val, key) { return key.toUpperCase() === key; }
	     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	     */
	    var pickBy = _curry2(function pickBy(test, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (test(obj[prop], prop, obj)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns a new list with the given element at the front, followed by the contents of the
	     * list.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The item to add to the head of the output list.
	     * @param {Array} list The array to add to the tail of the output list.
	     * @return {Array} A new array.
	     * @see R.append
	     * @example
	     *
	     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
	     */
	    var prepend = _curry2(function prepend(el, list) {
	        return _concat([el], list);
	    });

	    /**
	     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig s -> {s: a} -> a | Undefined
	     * @param {String} p The property name
	     * @param {Object} obj The object to query
	     * @return {*} The value at `obj.p`.
	     * @example
	     *
	     *      R.prop('x', {x: 100}); //=> 100
	     *      R.prop('x', {}); //=> undefined
	     */
	    var prop = _curry2(function prop(p, obj) {
	        return obj[p];
	    });

	    /**
	     * If the given, non-null object has an own property with the specified name,
	     * returns the value of that property.
	     * Otherwise returns the provided default value.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig a -> String -> Object -> a
	     * @param {*} val The default value.
	     * @param {String} p The name of the property to return.
	     * @param {Object} obj The object to query.
	     * @return {*} The value of given property of the supplied object or the default value.
	     * @example
	     *
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var favorite = R.prop('favoriteLibrary');
	     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
	     *
	     *      favorite(alice);  //=> undefined
	     *      favoriteWithDefault(alice);  //=> 'Ramda'
	     */
	    var propOr = _curry3(function propOr(val, p, obj) {
	        return obj != null && _has(p, obj) ? obj[p] : val;
	    });

	    /**
	     * Returns `true` if the specified object property satisfies the given
	     * predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
	     * @param {Function} pred
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propEq
	     * @see R.propIs
	     * @example
	     *
	     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
	     */
	    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
	        return pred(obj[name]);
	    });

	    /**
	     * Acts as multiple `prop`: array of keys in, array of values out. Preserves order.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [k] -> {k: v} -> [v]
	     * @param {Array} ps The property names to fetch
	     * @param {Object} obj The object to query
	     * @return {Array} The corresponding values or partially applied function.
	     * @example
	     *
	     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	     *
	     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	     */
	    var props = _curry2(function props(ps, obj) {
	        var len = ps.length;
	        var out = [];
	        var idx = 0;
	        while (idx < len) {
	            out[idx] = obj[ps[idx]];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a list of numbers from `from` (inclusive) to `to`
	     * (exclusive).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> Number -> [Number]
	     * @param {Number} from The first number in the list.
	     * @param {Number} to One more than the last number in the list.
	     * @return {Array} The list of numbers in tthe set `[a, b)`.
	     * @example
	     *
	     *      R.range(1, 5);    //=> [1, 2, 3, 4]
	     *      R.range(50, 53);  //=> [50, 51, 52]
	     */
	    var range = _curry2(function range(from, to) {
	        if (!(_isNumber(from) && _isNumber(to))) {
	            throw new TypeError('Both arguments to range must be numbers');
	        }
	        var result = [];
	        var n = from;
	        while (n < to) {
	            result.push(n);
	            n += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling the iterator
	     * function and passing it an accumulator value and the current value from the array, and
	     * then passing the result to the next call.
	     *
	     * Similar to `reduce`, except moves through the input list from the right to the left.
	     *
	     * The iterator function receives two values: *(acc, value)*
	     *
	     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse arrays), unlike
	     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
	     *      var flattenPairs = function(acc, pair) {
	     *        return acc.concat(pair);
	     *      };
	     *
	     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
	     */
	    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            acc = fn(acc, list[idx]);
	            idx -= 1;
	        }
	        return acc;
	    });

	    /**
	     * Returns a value wrapped to indicate that it is the final value of the
	     * reduce and transduce functions.  The returned value
	     * should be considered a black box: the internal structure is not
	     * guaranteed to be stable.
	     *
	     * Note: this optimization is unavailable to functions not explicitly listed
	     * above.  For instance, it is not currently supported by reduceIndexed,
	     * reduceRight, or reduceRightIndexed.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.reduce, R.transduce
	     * @sig a -> *
	     * @param {*} x The final value of the reduce.
	     * @return {*} The wrapped value.
	     * @example
	     *
	     *      R.reduce(
	     *        R.pipe(R.add, R.ifElse(R.lte(10), R.reduced, R.identity)),
	     *        0,
	     *        [1, 2, 3, 4, 5]) // 10
	     */
	    var reduced = _curry1(_reduced);

	    /**
	     * Removes the sub-list of `list` starting at index `start` and containing
	     * `count` elements.  _Note that this is not destructive_: it returns a
	     * copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @param {Number} start The position to start removing elements
	     * @param {Number} count The number of elements to remove
	     * @param {Array} list The list to remove from
	     * @return {Array} A new Array with `count` elements from `start` removed.
	     * @example
	     *
	     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
	     */
	    var remove = _curry3(function remove(start, count, list) {
	        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
	    });

	    /**
	     * Replace a substring or regex match in a string with a replacement.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig RegExp|String -> String -> String -> String
	     * @param {RegExp|String} pattern A regular expression or a substring to match.
	     * @param {String} replacement The string to replace the matches with.
	     * @param {String} str The String to do the search and replacement in.
	     * @return {String} The result.
	     * @example
	     *
	     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *
	     *      // Use the "g" (global) flag to replace all occurrences:
	     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
	     */
	    var replace = _curry3(function replace(regex, replacement, str) {
	        return str.replace(regex, replacement);
	    });

	    /**
	     * Returns a new list with the same elements as the original list, just
	     * in the reverse order.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The list to reverse.
	     * @return {Array} A copy of the list in reverse order.
	     * @example
	     *
	     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	     *      R.reverse([1, 2]);     //=> [2, 1]
	     *      R.reverse([1]);        //=> [1]
	     *      R.reverse([]);         //=> []
	     */
	    var reverse = _curry1(function reverse(list) {
	        return _slice(list).reverse();
	    });

	    /**
	     * Scan is similar to reduce, but returns a list of successively reduced values from the left
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> [a]
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} A list of all intermediately reduced values.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
	     */
	    var scan = _curry3(function scan(fn, acc, list) {
	        var idx = 0, len = list.length, result = [acc];
	        while (idx < len) {
	            acc = fn(acc, list[idx]);
	            result[idx + 1] = acc;
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the given value.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> a -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
	     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
	     */
	    var set = _curry3(function set(lens, v, x) {
	        return over(lens, always(v), x);
	    });

	    /**
	     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
	     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero
	     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,a -> Number) -> [a] -> [a]
	     * @param {Function} comparator A sorting function :: a -> b -> Int
	     * @param {Array} list The list to sort
	     * @return {Array} a new array with its elements sorted by the comparator function.
	     * @example
	     *
	     *      var diff = function(a, b) { return a - b; };
	     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
	     */
	    var sort = _curry2(function sort(comparator, list) {
	        return _slice(list).sort(comparator);
	    });

	    /**
	     * Sorts the list according to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig Ord b => (a -> b) -> [a] -> [a]
	     * @param {Function} fn
	     * @param {Array} list The list to sort.
	     * @return {Array} A new list sorted by the keys generated by `fn`.
	     * @example
	     *
	     *      var sortByFirstItem = R.sortBy(prop(0));
	     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
	     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
	     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var bob = {
	     *        name: 'Bob',
	     *        age: -10
	     *      };
	     *      var clara = {
	     *        name: 'clara',
	     *        age: 314.159
	     *      };
	     *      var people = [clara, bob, alice];
	     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
	     */
	    var sortBy = _curry2(function sortBy(fn, list) {
	        return _slice(list).sort(function (a, b) {
	            var aa = fn(a);
	            var bb = fn(b);
	            return aa < bb ? -1 : aa > bb ? 1 : 0;
	        });
	    });

	    /**
	     * Subtracts two numbers. Equivalent to `a - b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a - b`.
	     * @see R.add
	     * @example
	     *
	     *      R.subtract(10, 8); //=> 2
	     *
	     *      var minus5 = R.subtract(R.__, 5);
	     *      minus5(17); //=> 12
	     *
	     *      var complementaryAngle = R.subtract(90);
	     *      complementaryAngle(30); //=> 60
	     *      complementaryAngle(72); //=> 18
	     */
	    var subtract = _curry2(function subtract(a, b) {
	        return a - b;
	    });

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing each value
	     * to the supplied predicate function, and terminating when the predicate function returns
	     * `false`. Excludes the element that caused the predicate function to fail. The predicate
	     * function is passed one argument: *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropLastWhile
	     * @example
	     *
	     *      var isNotOne = function(x) {
	     *        return !(x === 1);
	     *      };
	     *
	     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
	     */
	    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && fn(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, idx + 1, Infinity);
	    });

	    /**
	     * Runs the given function with the supplied object, then returns the object.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> *) -> a -> a
	     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
	     * @param {*} x
	     * @return {*} `x`.
	     * @example
	     *
	     *      var sayX = function(x) { console.log('x is ' + x); };
	     *      R.tap(sayX, 100); //=> 100
	     *      //-> 'x is 100'
	     */
	    var tap = _curry2(function tap(fn, x) {
	        fn(x);
	        return x;
	    });

	    /**
	     * Determines whether a given string matches a given regular expression.
	     *
	     * @func
	     * @memberOf R
	     * @see R.match
	     * @category String
	     * @sig RegExp -> String -> Boolean
	     * @param {RegExp} pattern
	     * @param {String} str
	     * @return {Boolean}
	     * @example
	     *
	     *      R.test(/^x/, 'xyz'); //=> true
	     *      R.test(/^y/, 'xyz'); //=> false
	     */
	    var test = _curry2(function test(pattern, str) {
	        return _cloneRegExp(pattern).test(str);
	    });

	    /**
	     * Calls an input function `n` times, returning an array containing the results of those
	     * function calls.
	     *
	     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
	     * gradually incremented to `n - 1`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (i -> a) -> i -> [a]
	     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
	     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
	     * @return {Array} An array containing the return values of all calls to `fn`.
	     * @example
	     *
	     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
	     */
	    var times = _curry2(function times(fn, n) {
	        var len = Number(n);
	        var list = new Array(len);
	        var idx = 0;
	        while (idx < len) {
	            list[idx] = fn(idx);
	            idx += 1;
	        }
	        return list;
	    });

	    /**
	     * Converts an object into an array of key, value arrays.
	     * Only the object's own properties are used.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own properties.
	     * @see R.fromPairs
	     * @example
	     *
	     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
	     */
	    var toPairs = _curry1(function toPairs(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            if (_has(prop, obj)) {
	                pairs[pairs.length] = [
	                    prop,
	                    obj[prop]
	                ];
	            }
	        }
	        return pairs;
	    });

	    /**
	     * Converts an object into an array of key, value arrays.
	     * The object's own properties and prototype properties are used.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own
	     *         and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
	     */
	    var toPairsIn = _curry1(function toPairsIn(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            pairs[pairs.length] = [
	                prop,
	                obj[prop]
	            ];
	        }
	        return pairs;
	    });

	    /**
	     * Removes (strips) whitespace from both ends of the string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to trim.
	     * @return {String} Trimmed version of `str`.
	     * @example
	     *
	     *      R.trim('   xyz  '); //=> 'xyz'
	     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
	     */
	    var trim = function () {
	        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
	        var zeroWidth = '\u200B';
	        var hasProtoTrim = typeof String.prototype.trim === 'function';
	        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
	            return _curry1(function trim(str) {
	                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
	                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
	                return str.replace(beginRx, '').replace(endRx, '');
	            });
	        } else {
	            return _curry1(function trim(str) {
	                return str.trim();
	            });
	        }
	    }();

	    /**
	     * Gives a single-word string description of the (native) type of a value, returning such
	     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
	     * Object types any further, reporting them all as 'Object'.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig (* -> {*}) -> String
	     * @param {*} val The value to test
	     * @return {String}
	     * @example
	     *
	     *      R.type({}); //=> "Object"
	     *      R.type(1); //=> "Number"
	     *      R.type(false); //=> "Boolean"
	     *      R.type('s'); //=> "String"
	     *      R.type(null); //=> "Null"
	     *      R.type([]); //=> "Array"
	     *      R.type(/[A-z]/); //=> "RegExp"
	     */
	    var type = _curry1(function type(val) {
	        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	    });

	    /**
	     * Takes a function `fn`, which takes a single array argument, and returns
	     * a function which:
	     *
	     *   - takes any number of positional arguments;
	     *   - passes these arguments to `fn` as an array; and
	     *   - returns the result.
	     *
	     * In other words, R.unapply derives a variadic function from a function
	     * which takes an array. R.unapply is the inverse of R.apply.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ([*...] -> a) -> (*... -> a)
	     * @param {Function} fn
	     * @return {Function}
	     * @see R.apply
	     * @example
	     *
	     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
	     */
	    var unapply = _curry1(function unapply(fn) {
	        return function () {
	            return fn(_slice(arguments));
	        };
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
	     * parameter. Any extraneous parameters will not be passed to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> b) -> (a -> b)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 1.
	     * @example
	     *
	     *      var takesTwoArgs = function(a, b) {
	     *        return [a, b];
	     *      };
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.unary(takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only 1 argument is passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var unary = _curry1(function unary(fn) {
	        return nAry(1, fn);
	    });

	    /**
	     * Returns a function of arity `n` from a (manually) curried function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (a -> b) -> (a -> c)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to uncurry.
	     * @return {Function} A new function.
	     * @see R.curry
	     * @example
	     *
	     *      var addFour = function(a) {
	     *        return function(b) {
	     *          return function(c) {
	     *            return function(d) {
	     *              return a + b + c + d;
	     *            };
	     *          };
	     *        };
	     *      };
	     *
	     *      var uncurriedAddFour = R.uncurryN(4, addFour);
	     *      curriedAddFour(1, 2, 3, 4); //=> 10
	     */
	    var uncurryN = _curry2(function uncurryN(depth, fn) {
	        return curryN(depth, function () {
	            var currentDepth = 1;
	            var value = fn;
	            var idx = 0;
	            var endIdx;
	            while (currentDepth <= depth && typeof value === 'function') {
	                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
	                value = value.apply(this, _slice(arguments, idx, endIdx));
	                currentDepth += 1;
	                idx = endIdx;
	            }
	            return value;
	        });
	    });

	    /**
	     * Builds a list from a seed value. Accepts an iterator function, which returns either false
	     * to stop iteration or an array of length 2 containing the value to add to the resulting
	     * list and the seed to be used in the next call to the iterator function.
	     *
	     * The iterator function receives one argument: *(seed)*.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> [b]) -> * -> [b]
	     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
	     *        either false to quit iteration or an array of length two to proceed. The element
	     *        at index 0 of this array will be added to the resulting array, and the element
	     *        at index 1 will be passed to the next call to `fn`.
	     * @param {*} seed The seed value.
	     * @return {Array} The final list.
	     * @example
	     *
	     *      var f = function(n) { return n > 50 ? false : [-n, n + 10] };
	     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
	     */
	    var unfold = _curry2(function unfold(fn, seed) {
	        var pair = fn(seed);
	        var result = [];
	        while (pair && pair.length) {
	            result[result.length] = pair[0];
	            pair = fn(pair[1]);
	        }
	        return result;
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original list, based
	     * upon the value returned by applying the supplied predicate to two list elements. Prefers
	     * the first item if two items compare equal based on the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      var strEq = function(a, b) { return String(a) === String(b); };
	     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
	     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
	     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
	     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
	     */
	    var uniqWith = _curry2(function uniqWith(pred, list) {
	        var idx = 0, len = list.length;
	        var result = [], item;
	        while (idx < len) {
	            item = list[idx];
	            if (!_containsWith(pred, item, result)) {
	                result[result.length] = item;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a new copy of the array with the element at the
	     * provided index replaced with the given value.
	     * @see R.adjust
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} idx The index to update.
	     * @param {*} x The value to exist at the given index of the returned array.
	     * @param {Array|Arguments} list The source array-like object to be updated.
	     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
	     * @example
	     *
	     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var update = _curry3(function update(idx, x, list) {
	        return adjust(always(x), idx, list);
	    });

	    /**
	     * Returns a list of all the enumerable own properties of the supplied object.
	     * Note that the order of the output array is not guaranteed across
	     * different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own properties.
	     * @example
	     *
	     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	     */
	    var values = _curry1(function values(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var vals = [];
	        var idx = 0;
	        while (idx < len) {
	            vals[idx] = obj[props[idx]];
	            idx += 1;
	        }
	        return vals;
	    });

	    /**
	     * Returns a list of all the properties, including prototype properties,
	     * of the supplied object.
	     * Note that the order of the output array is not guaranteed to be
	     * consistent across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.valuesIn(f); //=> ['X', 'Y']
	     */
	    var valuesIn = _curry1(function valuesIn(obj) {
	        var prop, vs = [];
	        for (prop in obj) {
	            vs[vs.length] = obj[prop];
	        }
	        return vs;
	    });

	    /**
	     * Returns a "view" of the given data structure, determined by the given lens.
	     * The lens's focus determines which portion of the data structure is visible.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> s -> a
	     * @param {Lens} lens
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});  //=> 1
	     *      R.view(xLens, {x: 4, y: 2});  //=> 4
	     */
	    var view = function () {
	        var Const = function (x) {
	            return {
	                value: x,
	                map: function () {
	                    return this;
	                }
	            };
	        };
	        return _curry2(function view(lens, x) {
	            return lens(Const)(x).value;
	        });
	    }();

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec. Each of the spec's own properties must be a predicate function.
	     * Each predicate is applied to the value of the corresponding property of
	     * the test object. `where` returns true if all the predicates return true,
	     * false otherwise.
	     *
	     * `where` is well suited to declaratively expressing constraints for other
	     * functions such as `filter` and `find`.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.where({
	     *        a: R.equals('foo'),
	     *        b: R.complement(R.equals('bar')),
	     *        x: R.gt(_, 10),
	     *        y: R.lt(_, 20)
	     *      });
	     *
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
	     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
	     */
	    var where = _curry2(function where(spec, testObj) {
	        for (var prop in spec) {
	            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
	                return false;
	            }
	        }
	        return true;
	    });

	    /**
	     * Wrap a function inside another to allow you to make adjustments to the parameters, or do
	     * other processing either before the internal function is called or with its results.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
	     * @param {Function} fn The function to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var greet = function(name) {return 'Hello ' + name;};
	     *
	     *      var shoutedGreet = R.wrap(greet, function(gr, name) {
	     *        return gr(name).toUpperCase();
	     *      });
	     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
	     *
	     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
	     *        return gr(name.substring(0, 3));
	     *      });
	     *      shortenedGreet("Robert"); //=> "Hello Rob"
	     */
	    var wrap = _curry2(function wrap(fn, wrapper) {
	        return curryN(fn.length, function () {
	            return wrapper.apply(this, _concat([fn], arguments));
	        });
	    });

	    /**
	     * Creates a new list out of the two supplied by creating each possible
	     * pair from the lists.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The list made by combining each possible pair from
	     *         `as` and `bs` into pairs (`[a, b]`).
	     * @example
	     *
	     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
	     */
	    // = xprodWith(prepend); (takes about 3 times as long...)
	    var xprod = _curry2(function xprod(a, b) {
	        // = xprodWith(prepend); (takes about 3 times as long...)
	        var idx = 0;
	        var ilen = a.length;
	        var j;
	        var jlen = b.length;
	        var result = [];
	        while (idx < ilen) {
	            j = 0;
	            while (j < jlen) {
	                result[result.length] = [
	                    a[idx],
	                    b[j]
	                ];
	                j += 1;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Creates a new list out of the two supplied by pairing up
	     * equally-positioned items from both lists.  The returned list is
	     * truncated to the length of the shorter of the two input lists.
	     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
	     * @example
	     *
	     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     */
	    var zip = _curry2(function zip(a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = [
	                a[idx],
	                b[idx]
	            ];
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * Creates a new object out of a list of keys and a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [String] -> [*] -> {String: *}
	     * @param {Array} keys The array that will be properties on the output object.
	     * @param {Array} values The list of values on the output object.
	     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
	     * @example
	     *
	     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
	     */
	    var zipObj = _curry2(function zipObj(keys, values) {
	        var idx = 0, len = keys.length, out = {};
	        while (idx < len) {
	            out[keys[idx]] = values[idx];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Creates a new list out of the two supplied by applying the function to
	     * each equally-positioned pair in the lists. The returned list is
	     * truncated to the length of the shorter of the two input lists.
	     *
	     * @function
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> c) -> [a] -> [b] -> [c]
	     * @param {Function} fn The function used to combine the two elements into one value.
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
	     *         using `fn`.
	     * @example
	     *
	     *      var f = function(x, y) {
	     *        // ...
	     *      };
	     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
	     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
	     */
	    var zipWith = _curry3(function zipWith(fn, a, b) {
	        var rv = [], idx = 0, len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = fn(a[idx], b[idx]);
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * A function that always returns `false`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig * -> false
	     * @return {Boolean} false
	     * @see R.always, R.T
	     * @example
	     *
	     *      R.F(); //=> false
	     */
	    var F = always(false);

	    /**
	     * A function that always returns `true`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig * -> true
	     * @return {Boolean} `true`.
	     * @see R.always, R.F
	     * @example
	     *
	     *      R.T(); //=> true
	     */
	    var T = always(true);

	    /**
	     * Similar to hasMethod, this checks whether a function has a [methodname]
	     * function. If it isn't an array it will execute that function otherwise it will
	     * default to the ramda implementation.
	     *
	     * @private
	     * @param {Function} fn ramda implemtation
	     * @param {String} methodname property to check for a custom implementation
	     * @return {Object} Whatever the return value of the method is.
	     */
	    var _checkForMethod = function _checkForMethod(methodname, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
	        };
	    };

	    /**
	     * Copies an object.
	     *
	     * @private
	     * @param {*} value The value to be copied
	     * @param {Array} refFrom Array containing the source references
	     * @param {Array} refTo Array containing the copied source references
	     * @return {*} The copied value.
	     */
	    var _clone = function _clone(value, refFrom, refTo) {
	        var copy = function copy(copiedValue) {
	            var len = refFrom.length;
	            var idx = 0;
	            while (idx < len) {
	                if (value === refFrom[idx]) {
	                    return refTo[idx];
	                }
	                idx += 1;
	            }
	            refFrom[idx + 1] = value;
	            refTo[idx + 1] = copiedValue;
	            for (var key in value) {
	                copiedValue[key] = _clone(value[key], refFrom, refTo);
	            }
	            return copiedValue;
	        };
	        switch (type(value)) {
	        case 'Object':
	            return copy({});
	        case 'Array':
	            return copy([]);
	        case 'Date':
	            return new Date(value);
	        case 'RegExp':
	            return _cloneRegExp(value);
	        default:
	            return value;
	        }
	    };

	    var _createPartialApplicator = function _createPartialApplicator(concat) {
	        return function (fn) {
	            var args = _slice(arguments, 1);
	            return _arity(Math.max(0, fn.length - args.length), function () {
	                return fn.apply(this, concat(args, arguments));
	            });
	        };
	    };

	    /**
	     * Returns a function that dispatches with different strategies based on the
	     * object in list position (last argument). If it is an array, executes [fn].
	     * Otherwise, if it has a  function with [methodname], it will execute that
	     * function (functor case). Otherwise, if it is a transformer, uses transducer
	     * [xf] to return a new transformer (transducer case). Otherwise, it will
	     * default to executing [fn].
	     *
	     * @private
	     * @param {String} methodname property to check for a custom implementation
	     * @param {Function} xf transducer to initialize if object is transformer
	     * @param {Function} fn default ramda implementation
	     * @return {Function} A function that dispatches on object in list position
	     */
	    var _dispatchable = function _dispatchable(methodname, xf, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            if (!_isArray(obj)) {
	                var args = _slice(arguments, 0, length - 1);
	                if (typeof obj[methodname] === 'function') {
	                    return obj[methodname].apply(obj, args);
	                }
	                if (_isTransformer(obj)) {
	                    var transducer = xf.apply(null, args);
	                    return transducer(obj);
	                }
	            }
	            return fn.apply(this, arguments);
	        };
	    };

	    // The algorithm used to handle cyclic structures is
	    // inspired by underscore's isEqual
	    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
	    var _equals = function _equals(a, b, stackA, stackB) {
	        var typeA = type(a);
	        if (typeA !== type(b)) {
	            return false;
	        }
	        if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
	            return typeof a === 'object' ? typeof b === 'object' && identical(a.valueOf(), b.valueOf()) : identical(a, b);
	        }
	        if (identical(a, b)) {
	            return true;
	        }
	        if (typeA === 'RegExp') {
	            // RegExp equality algorithm: http://stackoverflow.com/a/10776635
	            return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;
	        }
	        if (Object(a) === a) {
	            if (typeA === 'Date' && a.getTime() !== b.getTime()) {
	                return false;
	            }
	            var keysA = keys(a);
	            if (keysA.length !== keys(b).length) {
	                return false;
	            }
	            var idx = stackA.length - 1;
	            while (idx >= 0) {
	                if (stackA[idx] === a) {
	                    return stackB[idx] === b;
	                }
	                idx -= 1;
	            }
	            stackA[stackA.length] = a;
	            stackB[stackB.length] = b;
	            idx = keysA.length - 1;
	            while (idx >= 0) {
	                var key = keysA[idx];
	                if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
	                    return false;
	                }
	                idx -= 1;
	            }
	            stackA.pop();
	            stackB.pop();
	            return true;
	        }
	        return false;
	    };

	    /**
	     * Private function that determines whether or not a provided object has a given method.
	     * Does not ignore methods stored on the object's prototype chain. Used for dynamically
	     * dispatching Ramda methods to non-Array objects.
	     *
	     * @private
	     * @param {String} methodName The name of the method to check for.
	     * @param {Object} obj The object to test.
	     * @return {Boolean} `true` has a given method, `false` otherwise.
	     * @example
	     *
	     *      var person = { name: 'John' };
	     *      person.shout = function() { alert(this.name); };
	     *
	     *      _hasMethod('shout', person); //=> true
	     *      _hasMethod('foo', person); //=> false
	     */
	    var _hasMethod = function _hasMethod(methodName, obj) {
	        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
	    };

	    /**
	     * `_makeFlat` is a helper function that returns a one-level or fully recursive function
	     * based on the flag passed in.
	     *
	     * @private
	     */
	    var _makeFlat = function _makeFlat(recursive) {
	        return function flatt(list) {
	            var value, result = [], idx = 0, j, ilen = list.length, jlen;
	            while (idx < ilen) {
	                if (isArrayLike(list[idx])) {
	                    value = recursive ? flatt(list[idx]) : list[idx];
	                    j = 0;
	                    jlen = value.length;
	                    while (j < jlen) {
	                        result[result.length] = value[j];
	                        j += 1;
	                    }
	                } else {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	            return result;
	        };
	    };

	    var _reduce = function () {
	        function _arrayReduce(xf, acc, list) {
	            var idx = 0, len = list.length;
	            while (idx < len) {
	                acc = xf['@@transducer/step'](acc, list[idx]);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                idx += 1;
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _iterableReduce(xf, acc, iter) {
	            var step = iter.next();
	            while (!step.done) {
	                acc = xf['@@transducer/step'](acc, step.value);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                step = iter.next();
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _methodReduce(xf, acc, obj) {
	            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
	        }
	        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	        return function _reduce(fn, acc, list) {
	            if (typeof fn === 'function') {
	                fn = _xwrap(fn);
	            }
	            if (isArrayLike(list)) {
	                return _arrayReduce(fn, acc, list);
	            }
	            if (typeof list.reduce === 'function') {
	                return _methodReduce(fn, acc, list);
	            }
	            if (list[symIterator] != null) {
	                return _iterableReduce(fn, acc, list[symIterator]());
	            }
	            if (typeof list.next === 'function') {
	                return _iterableReduce(fn, acc, list);
	            }
	            throw new TypeError('reduce: list must be array or iterable');
	        };
	    }();

	    var _stepCat = function () {
	        var _stepCatArray = {
	            '@@transducer/init': Array,
	            '@@transducer/step': function (xs, x) {
	                return _concat(xs, [x]);
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatString = {
	            '@@transducer/init': String,
	            '@@transducer/step': function (a, b) {
	                return a + b;
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatObject = {
	            '@@transducer/init': Object,
	            '@@transducer/step': function (result, input) {
	                return merge(result, isArrayLike(input) ? createMapEntry(input[0], input[1]) : input);
	            },
	            '@@transducer/result': _identity
	        };
	        return function _stepCat(obj) {
	            if (_isTransformer(obj)) {
	                return obj;
	            }
	            if (isArrayLike(obj)) {
	                return _stepCatArray;
	            }
	            if (typeof obj === 'string') {
	                return _stepCatString;
	            }
	            if (typeof obj === 'object') {
	                return _stepCatObject;
	            }
	            throw new Error('Cannot create transformer for ' + obj);
	        };
	    }();

	    var _xall = function () {
	        function XAll(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.all = true;
	        }
	        XAll.prototype['@@transducer/init'] = _xfBase.init;
	        XAll.prototype['@@transducer/result'] = function (result) {
	            if (this.all) {
	                result = this.xf['@@transducer/step'](result, true);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAll.prototype['@@transducer/step'] = function (result, input) {
	            if (!this.f(input)) {
	                this.all = false;
	                result = _reduced(this.xf['@@transducer/step'](result, false));
	            }
	            return result;
	        };
	        return _curry2(function _xall(f, xf) {
	            return new XAll(f, xf);
	        });
	    }();

	    var _xany = function () {
	        function XAny(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.any = false;
	        }
	        XAny.prototype['@@transducer/init'] = _xfBase.init;
	        XAny.prototype['@@transducer/result'] = function (result) {
	            if (!this.any) {
	                result = this.xf['@@transducer/step'](result, false);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAny.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.any = true;
	                result = _reduced(this.xf['@@transducer/step'](result, true));
	            }
	            return result;
	        };
	        return _curry2(function _xany(f, xf) {
	            return new XAny(f, xf);
	        });
	    }();

	    var _xdrop = function () {
	        function XDrop(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XDrop.prototype['@@transducer/init'] = _xfBase.init;
	        XDrop.prototype['@@transducer/result'] = _xfBase.result;
	        XDrop.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n > 0) {
	                this.n -= 1;
	                return result;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdrop(n, xf) {
	            return new XDrop(n, xf);
	        });
	    }();

	    var _xdropWhile = function () {
	        function XDropWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f) {
	                if (this.f(input)) {
	                    return result;
	                }
	                this.f = null;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropWhile(f, xf) {
	            return new XDropWhile(f, xf);
	        });
	    }();

	    var _xgroupBy = function () {
	        function XGroupBy(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.inputs = {};
	        }
	        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
	        XGroupBy.prototype['@@transducer/result'] = function (result) {
	            var key;
	            for (key in this.inputs) {
	                if (_has(key, this.inputs)) {
	                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
	                    if (result['@@transducer/reduced']) {
	                        result = result['@@transducer/value'];
	                        break;
	                    }
	                }
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
	            var key = this.f(input);
	            this.inputs[key] = this.inputs[key] || [
	                key,
	                []
	            ];
	            this.inputs[key][1] = append(input, this.inputs[key][1]);
	            return result;
	        };
	        return _curry2(function _xgroupBy(f, xf) {
	            return new XGroupBy(f, xf);
	        });
	    }();

	    /**
	     * Creates a new list iteration function from an existing one by adding two new parameters
	     * to its callback function: the current index, and the entire list.
	     *
	     * This would turn, for instance, Ramda's simple `map` function into one that more closely
	     * resembles `Array.prototype.map`.  Note that this will only work for functions in which
	     * the iteration callback function is the first parameter, and where the list is the last
	     * parameter.  (This latter might be unimportant if the list parameter is not used.)
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @category List
	     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	     * @param {Function} fn A list iteration function that does not pass index or list to its callback
	     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	     * @example
	     *
	     *      var mapIndexed = R.addIndex(R.map);
	     *      mapIndexed(function(val, idx) {return idx + '-' + val;}, ['f', 'o', 'o', 'b', 'a', 'r']);
	     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	     */
	    var addIndex = _curry1(function addIndex(fn) {
	        return curryN(fn.length, function () {
	            var idx = 0;
	            var origFn = arguments[0];
	            var list = arguments[arguments.length - 1];
	            var args = _slice(arguments);
	            args[0] = function () {
	                var result = origFn.apply(this, _concat(arguments, [
	                    idx,
	                    list
	                ]));
	                idx += 1;
	                return result;
	            };
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Returns `true` if all elements of the list match the predicate, `false` if there are any
	     * that don't.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	     *         otherwise.
	     * @see R.any, R.none
	     * @example
	     *
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      var lessThan3 = R.flip(R.lt)(3);
	     *      R.all(lessThan2)([1, 2]); //=> false
	     *      R.all(lessThan3)([1, 2]); //=> true
	     */
	    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (!fn(list[idx])) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    }));

	    /**
	     * A function that returns the first argument if it's falsy otherwise the second
	     * argument. Note that this is NOT short-circuited, meaning that if expressions
	     * are passed they are both evaluated.
	     *
	     * Dispatches to the `and` method of the first argument if applicable.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {*} a any value
	     * @param {*} b any other value
	     * @return {*} the first argument if falsy otherwise the second argument.
	     * @see R.both
	     * @example
	     *
	     *      R.and(false, true); //=> false
	     *      R.and(0, []); //=> 0
	     *      R.and(null, ''); => null
	     */
	    var and = _curry2(function and(a, b) {
	        return _hasMethod('and', a) ? a.and(b) : a && b;
	    });

	    /**
	     * Returns `true` if at least one of elements of the list match the predicate, `false`
	     * otherwise.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
	     *         otherwise.
	     * @see R.all, R.none
	     * @example
	     *
	     *      var lessThan0 = R.flip(R.lt)(0);
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      R.any(lessThan0)([1, 2]); //=> false
	     *      R.any(lessThan2)([1, 2]); //=> true
	     */
	    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (fn(list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    }));

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
	     * parameters. Any extraneous parameters will not be passed to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> c) -> (a, b -> c)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 2.
	     * @example
	     *
	     *      var takesThreeArgs = function(a, b, c) {
	     *        return [a, b, c];
	     *      };
	     *      takesThreeArgs.length; //=> 3
	     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      var takesTwoArgs = R.binary(takesThreeArgs);
	     *      takesTwoArgs.length; //=> 2
	     *      // Only 2 arguments are passed to the wrapped function
	     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
	     */
	    var binary = _curry1(function binary(fn) {
	        return nAry(2, fn);
	    });

	    /**
	     * Creates a deep copy of the value which may contain (nested) `Array`s and
	     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
	     * not copied, but assigned by their reference.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {*} -> {*}
	     * @param {*} value The object or array to clone
	     * @return {*} A new object or array.
	     * @example
	     *
	     *      var objects = [{}, {}, {}];
	     *      var objectsClone = R.clone(objects);
	     *      objects[0] === objectsClone[0]; //=> false
	     */
	    var clone = _curry1(function clone(value) {
	        return _clone(value, [], []);
	    });

	    /**
	     * Returns a new list consisting of the elements of the first list followed by the elements
	     * of the second.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The first list to merge.
	     * @param {Array} list2 The second set to merge.
	     * @return {Array} A new array consisting of the contents of `list1` followed by the
	     *         contents of `list2`. If, instead of an Array for `list1`, you pass an
	     *         object with a `concat` method on it, `concat` will call `list1.concat`
	     *         and pass it the value of `list2`.
	     *
	     * @example
	     *
	     *      R.concat([], []); //=> []
	     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
	     */
	    var concat = _curry2(function concat(set1, set2) {
	        if (_isArray(set2)) {
	            return _concat(set1, set2);
	        } else if (_hasMethod('concat', set1)) {
	            return set1.concat(set2);
	        } else {
	            throw new TypeError('can\'t concat ' + typeof set1);
	        }
	    });

	    /**
	     * Returns a curried equivalent of the provided function. The curried
	     * function has two unusual capabilities. First, its arguments needn't
	     * be provided one at a time. If `f` is a ternary function and `g` is
	     * `R.curry(f)`, the following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`,
	     * the following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> a) -> (* -> a)
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curryN
	     * @example
	     *
	     *      var addFourNumbers = function(a, b, c, d) {
	     *        return a + b + c + d;
	     *      };
	     *
	     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curry = _curry1(function curry(fn) {
	        return curryN(fn.length, fn);
	    });

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing each value
	     * to the supplied predicate function, skipping elements while the predicate function returns
	     * `true`. The predicate function is passed one argument: *(value)*.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeWhile
	     * @example
	     *
	     *      var lteTwo = function(x) {
	     *        return x <= 2;
	     *      };
	     *
	     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
	     */
	    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
	        var idx = 0, len = list.length;
	        while (idx < len && pred(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, idx);
	    }));

	    /**
	     * Returns `true` if its arguments are equivalent, `false` otherwise.
	     * Dispatches to an `equals` method if present. Handles cyclical data
	     * structures.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig a -> b -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      R.equals(1, 1); //=> true
	     *      R.equals(1, '1'); //=> false
	     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	     *
	     *      var a = {}; a.v = a;
	     *      var b = {}; b.v = b;
	     *      R.equals(a, b); //=> true
	     */
	    var equals = _curry2(function equals(a, b) {
	        return _hasMethod('equals', a) ? a.equals(b) : _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
	    });

	    /**
	     * Returns a new list containing only those items that match a given predicate function.
	     * The predicate function is passed one argument: *(value)*.
	     *
	     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native
	     * `Array.prototype.filter` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} The new filtered array.
	     * @see R.reject
	     * @example
	     *
	     *      var isEven = function(n) {
	     *        return n % 2 === 0;
	     *      };
	     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	     */
	    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));

	    /**
	     * Returns the first element of the list which matches the predicate, or `undefined` if no
	     * element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     *        desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	     *      R.find(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx += 1;
	        }
	    }));

	    /**
	     * Returns the index of the first element of the list which matches the predicate, or `-1`
	     * if no element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    }));

	    /**
	     * Returns the last element of the list which matches the predicate, or `undefined` if no
	     * element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
	     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx -= 1;
	        }
	    }));

	    /**
	     * Returns the index of the last element of the list which matches the predicate, or
	     * `-1` if no element matches.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
	     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx -= 1;
	        }
	        return -1;
	    }));

	    /**
	     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
	     * them in a new array, depth-first.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.unnest
	     * @example
	     *
	     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	     */
	    var flatten = _curry1(_makeFlat(true));

	    /**
	     * Returns a new function much like the supplied one, except that the first two arguments'
	     * order is reversed.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
	     * @param {Function} fn The function to invoke with its first two parameters reversed.
	     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
	     * @example
	     *
	     *      var mergeThree = function(a, b, c) {
	     *        return ([]).concat(a, b, c);
	     *      };
	     *
	     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
	     */
	    var flip = _curry1(function flip(fn) {
	        return curry(function (a, b) {
	            var args = _slice(arguments);
	            args[0] = b;
	            args[1] = a;
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Iterate over an input `list`, calling a provided function `fn` for each element in the
	     * list.
	     *
	     * `fn` receives one argument: *(value)*.
	     *
	     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike
	     * the native `Array.prototype.forEach` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	     *
	     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original
	     * array. In some libraries this function is named `each`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> *) -> [a] -> [a]
	     * @param {Function} fn The function to invoke. Receives one argument, `value`.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} The original list.
	     * @example
	     *
	     *      var printXPlusFive = function(x) { console.log(x + 5); };
	     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	     *      //-> 6
	     *      //-> 7
	     *      //-> 8
	     */
	    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            fn(list[idx]);
	            idx += 1;
	        }
	        return list;
	    }));

	    /**
	     * Returns a list of function names of object's own functions
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {*} -> [String]
	     * @param {Object} obj The objects with functions in it
	     * @return {Array} A list of the object's own properties that map to functions.
	     * @example
	     *
	     *      R.functions(R); // returns list of ramda's own function names
	     *
	     *      var F = function() { this.x = function(){}; this.y = 1; }
	     *      F.prototype.z = function() {};
	     *      F.prototype.a = 100;
	     *      R.functions(new F()); //=> ["x"]
	     */
	    var functions = _curry1(_functionsWith(keys));

	    /**
	     * Returns a list of function names of object's own and prototype functions
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {*} -> [String]
	     * @param {Object} obj The objects with functions in it
	     * @return {Array} A list of the object's own properties and prototype
	     *         properties that map to functions.
	     * @example
	     *
	     *      R.functionsIn(R); // returns list of ramda's own and prototype function names
	     *
	     *      var F = function() { this.x = function(){}; this.y = 1; }
	     *      F.prototype.z = function() {};
	     *      F.prototype.a = 100;
	     *      R.functionsIn(new F()); //=> ["x", "z"]
	     */
	    var functionsIn = _curry1(_functionsWith(keysIn));

	    /**
	     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function
	     * on each element, and grouping the results according to values returned.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> String) -> [a] -> {String: [a]}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} list The array to group
	     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
	     *         that produced that key when passed to `fn`.
	     * @example
	     *
	     *      var byGrade = R.groupBy(function(student) {
	     *        var score = student.score;
	     *        return score < 65 ? 'F' :
	     *               score < 70 ? 'D' :
	     *               score < 80 ? 'C' :
	     *               score < 90 ? 'B' : 'A';
	     *      });
	     *      var students = [{name: 'Abby', score: 84},
	     *                      {name: 'Eddy', score: 58},
	     *                      // ...
	     *                      {name: 'Jack', score: 69}];
	     *      byGrade(students);
	     *      // {
	     *      //   'A': [{name: 'Dianne', score: 99}],
	     *      //   'B': [{name: 'Abby', score: 84}]
	     *      //   // ...,
	     *      //   'F': [{name: 'Eddy', score: 58}]
	     *      // }
	     */
	    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
	        return _reduce(function (acc, elt) {
	            var key = fn(elt);
	            acc[key] = append(elt, acc[key] || (acc[key] = []));
	            return acc;
	        }, {}, list);
	    }));

	    /**
	     * Returns the first element of the given list or string. In some libraries
	     * this function is named `first`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.tail, R.init, R.last
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
	     *      R.head([]); //=> undefined
	     *
	     *      R.head('abc'); //=> 'a'
	     *      R.head(''); //=> ''
	     */
	    var head = nth(0);

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists.  Duplication is determined according
	     * to the value returned by applying the supplied predicate to two list
	     * elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate function that determines whether
	     *        the two supplied elements are equal.
	     * @param {Array} list1 One list of items to compare
	     * @param {Array} list2 A second list of items to compare
	     * @see R.intersection
	     * @return {Array} A new list containing those elements common to both lists.
	     * @example
	     *
	     *      var buffaloSpringfield = [
	     *        {id: 824, name: 'Richie Furay'},
	     *        {id: 956, name: 'Dewey Martin'},
	     *        {id: 313, name: 'Bruce Palmer'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *      var csny = [
	     *        {id: 204, name: 'David Crosby'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 539, name: 'Graham Nash'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *
	     *      var sameId = function(o1, o2) {return o1.id === o2.id;};
	     *
	     *      R.intersectionWith(sameId, buffaloSpringfield, csny);
	     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
	     */
	    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
	        var results = [], idx = 0;
	        while (idx < list1.length) {
	            if (_containsWith(pred, list1[idx], list2)) {
	                results[results.length] = list1[idx];
	            }
	            idx += 1;
	        }
	        return uniqWith(pred, results);
	    });

	    /**
	     * Creates a new list with the separator interposed between elements.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} separator The element to add to the list.
	     * @param {Array} list The list to be interposed.
	     * @return {Array} The new list.
	     * @example
	     *
	     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
	     */
	    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
	        var out = [];
	        var idx = 0;
	        var length = list.length;
	        while (idx < length) {
	            if (idx === length - 1) {
	                out.push(list[idx]);
	            } else {
	                out.push(list[idx], separator);
	            }
	            idx += 1;
	        }
	        return out;
	    }));

	    /**
	     * Transforms the items of the list with the transducer and appends the transformed items to
	     * the accumulator using an appropriate iterator function based on the accumulator type.
	     *
	     * The accumulator can be an array, string, object or a transformer. Iterated items will
	     * be appended to arrays and concatenated to strings. Objects will be merged directly or 2-item
	     * arrays will be merged as key, value pairs.
	     *
	     * The accumulator can also be a transformer object that provides a 2-arity reducing iterator
	     * function, step, 0-arity initial value function, init, and 1-arity result extraction function
	     * result. The step function is used as the iterator function in reduce. The result function is
	     * used to convert the final accumulator into the return type and in most cases is R.identity.
	     * The init function is used to provide the initial accumulator.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> (b -> b) -> [c] -> a
	     * @param {*} acc The initial accumulator value.
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.into([], transducer, numbers); //=> [2, 3]
	     *
	     *      var intoArray = R.into([]);
	     *      intoArray(transducer, numbers); //=> [2, 3]
	     */
	    var into = _curry3(function into(acc, xf, list) {
	        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
	    });

	    /**
	     * Same as R.invertObj, however this accounts for objects
	     * with duplicate values by putting the values into an
	     * array.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {s: x} -> {x: [ s, ... ]}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object with keys
	     * in an array.
	     * @example
	     *
	     *      var raceResultsByFirstName = {
	     *        first: 'alice',
	     *        second: 'jake',
	     *        third: 'alice',
	     *      };
	     *      R.invert(raceResultsByFirstName);
	     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
	     */
	    var invert = _curry1(function invert(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            var val = obj[key];
	            var list = _has(val, out) ? out[val] : out[val] = [];
	            list[list.length] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object with the keys of the given object
	     * as values, and the values of the given object as keys.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {s: x} -> {x: s}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object
	     * @example
	     *
	     *      var raceResults = {
	     *        first: 'alice',
	     *        second: 'jake'
	     *      };
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': 'first', 'jake':'second' }
	     *
	     *      // Alternatively:
	     *      var raceResults = ['alice', 'jake'];
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': '0', 'jake':'1' }
	     */
	    var invertObj = _curry1(function invertObj(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            out[obj[key]] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.init, R.head, R.tail
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
	     *      R.last([]); //=> undefined
	     *
	     *      R.last('abc'); //=> 'c'
	     *      R.last(''); //=> ''
	     */
	    var last = nth(-1);

	    /**
	     * Returns the position of the last occurrence of an item in
	     * an array, or -1 if the item is not included in the array.
	     * `R.equals` is used to determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.indexOf
	     * @example
	     *
	     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
	     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
	     */
	    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
	        if (_hasMethod('lastIndexOf', xs)) {
	            return xs.lastIndexOf(target);
	        } else {
	            var idx = xs.length - 1;
	            while (idx >= 0) {
	                if (equals(xs[idx], target)) {
	                    return idx;
	                }
	                idx -= 1;
	            }
	            return -1;
	        }
	    });

	    /**
	     * Returns a new list, constructed by applying the supplied function to every element of the
	     * supplied list.
	     *
	     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
	     * native `Array.prototype.map` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> b) -> [a] -> [b]
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {Array} list The list to be iterated over.
	     * @return {Array} The new list.
	     * @example
	     *
	     *      var double = function(x) {
	     *        return x * 2;
	     *      };
	     *
	     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	     */
	    var map = _curry2(_dispatchable('map', _xmap, _map));

	    /**
	     * Map, but for objects. Creates an object with the same keys as `obj` and values
	     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
	     * *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig (v -> v) -> {k: v} -> {k: v}
	     * @param {Function} fn A function called for each property in `obj`. Its return value will
	     * become a new property on the return object.
	     * @param {Object} obj The object to iterate over.
	     * @return {Object} A new object with the same keys as `obj` and values that are the result
	     *         of running each property through `fn`.
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var double = function(num) {
	     *        return num * 2;
	     *      };
	     *
	     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }
	     */
	    var mapObj = _curry2(function mapObj(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key]);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Like `mapObj`, but but passes additional arguments to the predicate function. The
	     * predicate function is passed three arguments: *(value, key, obj)*.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
	     * @param {Function} fn A function called for each property in `obj`. Its return value will
	     *        become a new property on the return object.
	     * @param {Object} obj The object to iterate over.
	     * @return {Object} A new object with the same keys as `obj` and values that are the result
	     *         of running each property through `fn`.
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var prependKeyAndDouble = function(num, key, obj) {
	     *        return key + (num * 2);
	     *      };
	     *
	     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	     */
	    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key], key, obj);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Returns `true` if no elements of the list match the predicate,
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
	     * @see R.all, R.any
	     * @example
	     *
	     *      R.none(R.isNaN, [1, 2, 3]); //=> true
	     *      R.none(R.isNaN, [1, 2, 3, NaN]); //=> false
	     */
	    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

	    /**
	     * A function that returns the first truthy of two arguments otherwise the
	     * last argument. Note that this is NOT short-circuited, meaning that if
	     * expressions are passed they are both evaluated.
	     *
	     * Dispatches to the `or` method of the first argument if applicable.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {*} a any value
	     * @param {*} b any other value
	     * @return {*} the first truthy argument, otherwise the last argument.
	     * @see R.either
	     * @example
	     *
	     *      R.or(false, true); //=> true
	     *      R.or(0, []); //=> []
	     *      R.or(null, ''); => ''
	     */
	    var or = _curry2(function or(a, b) {
	        return _hasMethod('or', a) ? a.or(b) : a || b;
	    });

	    /**
	     * Accepts as its arguments a function and any number of values and returns a function that,
	     * when invoked, calls the original function with all of the values prepended to the
	     * original function's arguments list. In some libraries this function is named `applyLeft`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> b -> ... -> i -> j -> ... -> m -> n) -> a -> b-> ... -> i -> (j -> ... -> m -> n)
	     * @param {Function} fn The function to invoke.
	     * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.
	     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`
	     *         with `args` prepended to `fn`'s arguments list.
	     * @example
	     *
	     *      var multiply = function(a, b) { return a * b; };
	     *      var double = R.partial(multiply, 2);
	     *      double(2); //=> 4
	     *
	     *      var greet = function(salutation, title, firstName, lastName) {
	     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *      };
	     *      var sayHello = R.partial(greet, 'Hello');
	     *      var sayHelloToMs = R.partial(sayHello, 'Ms.');
	     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partial = curry(_createPartialApplicator(_concat));

	    /**
	     * Accepts as its arguments a function and any number of values and returns a function that,
	     * when invoked, calls the original function with all of the values appended to the original
	     * function's arguments list.
	     *
	     * Note that `partialRight` is the opposite of `partial`: `partialRight` fills `fn`'s arguments
	     * from the right to the left.  In some libraries this function is named `applyRight`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (a -> b-> ... -> i -> j -> ... -> m -> n) -> j -> ... -> m -> n -> (a -> b-> ... -> i)
	     * @param {Function} fn The function to invoke.
	     * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.
	     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with
	     *         `args` appended to `fn`'s arguments list.
	     * @example
	     *
	     *      var greet = function(salutation, title, firstName, lastName) {
	     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *      };
	     *      var greetMsJaneJones = R.partialRight(greet, 'Ms.', 'Jane', 'Jones');
	     *
	     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partialRight = curry(_createPartialApplicator(flip(_concat)));

	    /**
	     * Takes a predicate and a list and returns the pair of lists of
	     * elements which do and do not satisfy the predicate, respectively.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
	     * @param {Function} pred A predicate to determine which array the element belongs to.
	     * @param {Array} list The array to partition.
	     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
	     *         and second an array of elements that did not satisfy.
	     * @example
	     *
	     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
	     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
	     */
	    var partition = _curry2(function partition(pred, list) {
	        return _reduce(function (acc, elt) {
	            var xs = acc[pred(elt) ? 0 : 1];
	            xs[xs.length] = elt;
	            return acc;
	        }, [
	            [],
	            []
	        ], list);
	    });

	    /**
	     * Determines whether a nested path on an object has a specific value,
	     * in `R.equals` terms. Most likely used to filter a list.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [String] -> * -> {String: *} -> Boolean
	     * @param {Array} path The path of the nested property to use
	     * @param {*} val The value to compare the nested property with
	     * @param {Object} obj The object to check the nested property in
	     * @return {Boolean} `true` if the value equals the nested object property,
	     *         `false` otherwise.
	     * @example
	     *
	     *      var user1 = { address: { zipCode: 90210 } };
	     *      var user2 = { address: { zipCode: 55555 } };
	     *      var user3 = { name: 'Bob' };
	     *      var users = [ user1, user2, user3 ];
	     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
	     *      R.filter(isFamous, users); //=> [ user1 ]
	     */
	    var pathEq = _curry3(function pathEq(_path, val, obj) {
	        return equals(path(_path, obj), val);
	    });

	    /**
	     * Returns a new list by plucking the same named property off all objects in the list supplied.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig k -> [{k: v}] -> [v]
	     * @param {Number|String} key The key name to pluck off of each object.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of values for the given key.
	     * @example
	     *
	     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
	     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
	     */
	    var pluck = _curry2(function pluck(p, list) {
	        return map(prop(p), list);
	    });

	    /**
	     * Returns `true` if the specified object property is equal, in `R.equals`
	     * terms, to the given value; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig String -> a -> Object -> Boolean
	     * @param {String} name
	     * @param {*} val
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.equals, R.propSatisfies
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
	     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
	     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
	     *      var kids = [abby, fred, rusty, alois];
	     *      var hasBrownHair = R.propEq('hair', 'brown');
	     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
	     */
	    var propEq = _curry3(function propEq(name, val, obj) {
	        return propSatisfies(equals(val), name, obj);
	    });

	    /**
	     * Returns `true` if the specified object property is of the given type;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category Type
	     * @sig Type -> String -> Object -> Boolean
	     * @param {Function} type
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.is
	     * @see R.propSatisfies
	     * @example
	     *
	     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
	     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
	     *      R.propIs(Number, 'x', {});            //=> false
	     */
	    var propIs = _curry3(function propIs(type, name, obj) {
	        return propSatisfies(is(type), name, obj);
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling the iterator
	     * function and passing it an accumulator value and the current value from the array, and
	     * then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*.  It may use `R.reduced` to
	     * shortcut the iteration.
	     *
	     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse arrays), unlike
	     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	     * @see R.reduced
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3];
	     *      var add = function(a, b) {
	     *        return a + b;
	     *      };
	     *
	     *      R.reduce(add, 10, numbers); //=> 16
	     */
	    var reduce = _curry3(_reduce);

	    /**
	     * Similar to `filter`, except that it keeps only values for which the given predicate
	     * function returns falsy. The predicate function is passed one argument: *(value)*.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} The new filtered array.
	     * @see R.filter
	     * @example
	     *
	     *      var isOdd = function(n) {
	     *        return n % 2 === 1;
	     *      };
	     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
	     */
	    var reject = _curry2(function reject(fn, list) {
	        return filter(_complement(fn), list);
	    });

	    /**
	     * Returns a fixed list of size `n` containing a specified identical value.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> n -> [a]
	     * @param {*} value The value to repeat.
	     * @param {Number} n The desired size of the output list.
	     * @return {Array} A new array containing `n` `value`s.
	     * @example
	     *
	     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
	     *
	     *      var obj = {};
	     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
	     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
	     */
	    var repeat = _curry2(function repeat(value, n) {
	        return times(always(value), n);
	    });

	    /**
	     * Returns the elements of the given list or string (or object with a `slice`
	     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @sig Number -> Number -> String -> String
	     * @param {Number} fromIndex The start index (inclusive).
	     * @param {Number} toIndex The end index (exclusive).
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	     */
	    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	        return Array.prototype.slice.call(list, fromIndex, toIndex);
	    }));

	    /**
	     * Splits a collection into slices of the specified length.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @sig Number -> String -> [String]
	     * @param {Number} n
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
	     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
	     */
	    var splitEvery = _curry2(function splitEvery(n, list) {
	        if (n <= 0) {
	            throw new Error('First argument to splitEvery must be a positive integer');
	        }
	        var result = [];
	        var idx = 0;
	        while (idx < list.length) {
	            result.push(slice(idx, idx += n, list));
	        }
	        return result;
	    });

	    /**
	     * Adds together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The sum of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.sum([2,4,6,8,100,1]); //=> 121
	     */
	    var sum = reduce(add, 0);

	    /**
	     * Returns all but the first element of the given list or string (or object
	     * with a `tail` method).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.head, R.init, R.last
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.tail([1, 2, 3]);  //=> [2, 3]
	     *      R.tail([1, 2]);     //=> [2]
	     *      R.tail([1]);        //=> []
	     *      R.tail([]);         //=> []
	     *
	     *      R.tail('abc');  //=> 'bc'
	     *      R.tail('ab');   //=> 'b'
	     *      R.tail('a');    //=> ''
	     *      R.tail('');     //=> ''
	     */
	    var tail = _checkForMethod('tail', slice(1, Infinity));

	    /**
	     * Returns the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `take` method).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.drop
	     * @example
	     *
	     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(3, 'ramda');               //=> 'ram'
	     *
	     *      var personnel = [
	     *        'Dave Brubeck',
	     *        'Paul Desmond',
	     *        'Eugene Wright',
	     *        'Joe Morello',
	     *        'Gerry Mulligan',
	     *        'Bob Bates',
	     *        'Joe Dodge',
	     *        'Ron Crotty'
	     *      ];
	     *
	     *      var takeFive = R.take(5);
	     *      takeFive(personnel);
	     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
	     */
	    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
	        return slice(0, n < 0 ? Infinity : n, xs);
	    }));

	    /**
	     * Returns a new list containing the first `n` elements of a given list, passing each value
	     * to the supplied predicate function, and terminating when the predicate function returns
	     * `false`. Excludes the element that caused the predicate function to fail. The predicate
	     * function is passed one argument: *(value)*.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropWhile
	     * @example
	     *
	     *      var isNotFour = function(x) {
	     *        return !(x === 4);
	     *      };
	     *
	     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]
	     */
	    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
	        var idx = 0, len = list.length;
	        while (idx < len && fn(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, 0, idx);
	    }));

	    /**
	     * Initializes a transducer using supplied iterator function. Returns a single item by
	     * iterating through the list, successively calling the transformed iterator function and
	     * passing it an accumulator value and the current value from the array, and then passing
	     * the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It will be wrapped as a
	     * transformer to initialize the transducer. A transformer can be passed directly in place
	     * of an iterator function.  In both cases, iteration may be stopped early with the
	     * `R.reduced` function.
	     *
	     * A transducer is a function that accepts a transformer and returns a transformer and can
	     * be composed directly.
	     *
	     * A transformer is an an object that provides a 2-arity reducing iterator function, step,
	     * 0-arity initial value function, init, and 1-arity result extraction function, result.
	     * The step function is used as the iterator function in reduce. The result function is used
	     * to convert the final accumulator into the return type and in most cases is R.identity.
	     * The init function can be used to provide an initial accumulator, but is ignored by transduce.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.reduce, R.reduced, R.into
	     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array. Wrapped as transformer, if necessary, and used to
	     *        initialize the transducer
	     * @param {*} acc The initial accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
	     */
	    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
	        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
	     * determined according to the value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @see R.union
	     * @example
	     *
	     *      function cmp(x, y) { return x.a === y.a; }
	     *      var l1 = [{a: 1}, {a: 2}];
	     *      var l2 = [{a: 1}, {a: 4}];
	     *      R.unionWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
	     */
	    var unionWith = _curry3(function unionWith(pred, list1, list2) {
	        return uniqWith(pred, _concat(list1, list2));
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original list.
	     * `R.equals` is used to determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
	     *      R.uniq([1, '1']);     //=> [1, '1']
	     *      R.uniq([[42], [42]]); //=> [[42]]
	     */
	    var uniq = uniqWith(equals);

	    /**
	     * Returns a new list by pulling every item at the first level of nesting out, and putting
	     * them in a new array.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.flatten
	     * @example
	     *
	     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
	     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
	     */
	    var unnest = _curry1(_makeFlat(false));

	    /**
	     * Accepts a function `fn` and any number of transformer functions and returns a new
	     * function. When the new function is invoked, it calls the function `fn` with parameters
	     * consisting of the result of calling each supplied handler on successive arguments to the
	     * new function.
	     *
	     * If more arguments are passed to the returned function than transformer functions, those
	     * arguments are passed directly to `fn` as additional parameters. If you expect additional
	     * arguments that don't need to be transformed, although you can ignore them, it's best to
	     * pass an identity function so that the new function reports the correct arity.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> ((a -> x1), (b -> x2), ...) -> (a -> b -> ... -> z)
	     * @param {Function} fn The function to wrap.
	     * @param {...Function} transformers A variable number of transformer functions
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var double = function(y) { return y * 2; };
	     *      var square = function(x) { return x * x; };
	     *      var add = function(a, b) { return a + b; };
	     *      // Adds any number of arguments together
	     *      var addAll = function() {
	     *        return R.reduce(add, 0, arguments);
	     *      };
	     *
	     *      // Basic example
	     *      var addDoubleAndSquare = R.useWith(addAll, double, square);
	     *
	     *      //≅ addAll(double(10), square(5));
	     *      addDoubleAndSquare(10, 5); //=> 45
	     *
	     *      // Example of passing more arguments than transformers
	     *      //≅ addAll(double(10), square(5), 100);
	     *      addDoubleAndSquare(10, 5, 100); //=> 145
	     *
	     *      // If there are extra _expected_ arguments that don't need to be transformed, although
	     *      // you can ignore them, it might be best to pass in the identity function so that the new
	     *      // function correctly reports arity.
	     *      var addDoubleAndSquareWithExtraParams = R.useWith(addAll, double, square, R.identity);
	     *      // addDoubleAndSquareWithExtraParams.length //=> 3
	     *      //≅ addAll(double(10), square(5), R.identity(100));
	     *      addDoubleAndSquare(10, 5, 100); //=> 145
	     */
	    /*, transformers */
	    var useWith = curry(function useWith(fn) {
	        var transformers = _slice(arguments, 1);
	        var tlen = transformers.length;
	        return curry(_arity(tlen, function () {
	            var args = [], idx = 0;
	            while (idx < tlen) {
	                args[idx] = transformers[idx](arguments[idx]);
	                idx += 1;
	            }
	            return fn.apply(this, args.concat(_slice(arguments, tlen)));
	        }));
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec, false otherwise. An object satisfies the spec if, for each of the
	     * spec's own properties, accessing that property of the object gives the same
	     * value (in `R.equals` terms) as accessing that property of the spec.
	     *
	     * `whereEq` is a specialization of [`where`](#where).
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig {String: *} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @see R.where
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.whereEq({a: 1, b: 2});
	     *
	     *      pred({a: 1});              //=> false
	     *      pred({a: 1, b: 2});        //=> true
	     *      pred({a: 1, b: 2, c: 3});  //=> true
	     *      pred({a: 1, b: 1});        //=> false
	     */
	    var whereEq = _curry2(function whereEq(spec, testObj) {
	        return where(mapObj(equals, spec), testObj);
	    });

	    var _flatCat = function () {
	        var preservingReduced = function (xf) {
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return xf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    var ret = xf['@@transducer/step'](result, input);
	                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	                }
	            };
	        };
	        return function _xcat(xf) {
	            var rxf = preservingReduced(xf);
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return rxf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	                }
	            };
	        };
	    }();

	    var _indexOf = function _indexOf(list, item, from) {
	        var idx = from;
	        while (idx < list.length) {
	            if (equals(list[idx], item)) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    };

	    /**
	     * Create a predicate wrapper which will call a pick function (all/any) for each predicate
	     *
	     * @private
	     * @see R.all
	     * @see R.any
	     */
	    // Call function immediately if given arguments
	    // Return a function which will call the predicates with the provided arguments
	    var _predicateWrap = function _predicateWrap(predPicker) {
	        return function (preds) {
	            var predIterator = function () {
	                var args = arguments;
	                return predPicker(function (predicate) {
	                    return predicate.apply(null, args);
	                }, preds);
	            };
	            return arguments.length > 1 ? // Call function immediately if given arguments
	            predIterator.apply(null, _slice(arguments, 1)) : // Return a function which will call the predicates with the provided arguments
	            _arity(Math.max.apply(Math, pluck('length', preds)), predIterator);
	        };
	    };

	    var _xchain = _curry2(function _xchain(f, xf) {
	        return map(f, _flatCat(xf));
	    });

	    /**
	     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} list An array of predicate functions
	     * @param {*} optional Any arguments to pass into the predicates
	     * @return {Function} a function that applies its arguments to each of
	     *         the predicates, returning `true` if all are satisfied.
	     * @see R.anyPass
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0};
	     *      var f = R.allPass([gt10, even]);
	     *      f(11); //=> false
	     *      f(12); //=> true
	     */
	    var allPass = _curry1(_predicateWrap(all));

	    /**
	     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.
	     *
	     * @func
	     * @memberOf R
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} list An array of predicate functions
	     * @param {*} optional Any arguments to pass into the predicates
	     * @return {Function} A function that applies its arguments to each of the predicates, returning
	     *         `true` if all are satisfied.
	     * @see R.allPass
	     * @example
	     *
	     *      var gt10 = function(x) { return x > 10; };
	     *      var even = function(x) { return x % 2 === 0};
	     *      var f = R.anyPass([gt10, even]);
	     *      f(11); //=> true
	     *      f(8); //=> true
	     *      f(9); //=> false
	     */
	    var anyPass = _curry1(_predicateWrap(any));

	    /**
	     * ap applies a list of functions to a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig [f] -> [a] -> [f a]
	     * @param {Array} fns An array of functions
	     * @param {Array} vs An array of values
	     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
	     * @example
	     *
	     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
	     */
	    var ap = _curry2(function ap(fns, vs) {
	        return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function (acc, fn) {
	            return _concat(acc, map(fn, vs));
	        }, [], fns);
	    });

	    /**
	     * Returns the result of calling its first argument with the remaining
	     * arguments. This is occasionally useful as a converging function for
	     * `R.converge`: the left branch can produce a function while the right
	     * branch produces a value to be passed to that function as an argument.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (*... -> a),*... -> a
	     * @param {Function} fn The function to apply to the remaining arguments.
	     * @param {...*} args Any number of positional arguments.
	     * @return {*}
	     * @see R.apply
	     * @example
	     *
	     *      var indentN = R.pipe(R.times(R.always(' ')),
	     *                           R.join(''),
	     *                           R.replace(/^(?!$)/gm));
	     *
	     *      var format = R.converge(R.call,
	     *                              R.pipe(R.prop('indent'), indentN),
	     *                              R.prop('value'));
	     *
	     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
	     */
	    var call = curry(function call(fn) {
	        return fn.apply(this, _slice(arguments, 1));
	    });

	    /**
	     * `chain` maps a function over a list and concatenates the results.
	     * This implementation is compatible with the
	     * Fantasy-land Chain spec, and will work with types that implement that spec.
	     * `chain` is also known as `flatMap` in some libraries
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> [b]) -> [a] -> [b]
	     * @param {Function} fn
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      var duplicate = function(n) {
	     *        return [n, n];
	     *      };
	     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	     */
	    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, list) {
	        return unnest(map(fn, list));
	    }));

	    /**
	     * Turns a list of Functors into a Functor of a list, applying
	     * a mapping function to the elements of the list along the way.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.commute
	     * @sig Functor f => (f a -> f b) -> (x -> f x) -> [f a] -> f [b]
	     * @param {Function} fn The transformation function
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @example
	     *
	     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
	     *      R.commuteMap(R.map(R.add(10)), R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
	     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
	     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
	     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     */
	    var commuteMap = _curry3(function commuteMap(fn, of, list) {
	        function consF(acc, ftor) {
	            return ap(map(append, fn(ftor)), acc);
	        }
	        return _reduce(consF, of([]), list);
	    });

	    /**
	     * Wraps a constructor function inside a curried function that can be called with the same
	     * arguments and returns the same type. The arity of the function returned is specified
	     * to allow using variadic constructor functions.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> (* -> {*}) -> (* -> {*})
	     * @param {Number} n The arity of the constructor function.
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Variadic constructor function
	     *      var Widget = function() {
	     *        this.children = Array.prototype.slice.call(arguments);
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
	     */
	    var constructN = _curry2(function constructN(n, Fn) {
	        if (n > 10) {
	            throw new Error('Constructor with greater than ten arguments');
	        }
	        if (n === 0) {
	            return function () {
	                return new Fn();
	            };
	        }
	        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
	            switch (arguments.length) {
	            case 1:
	                return new Fn($0);
	            case 2:
	                return new Fn($0, $1);
	            case 3:
	                return new Fn($0, $1, $2);
	            case 4:
	                return new Fn($0, $1, $2, $3);
	            case 5:
	                return new Fn($0, $1, $2, $3, $4);
	            case 6:
	                return new Fn($0, $1, $2, $3, $4, $5);
	            case 7:
	                return new Fn($0, $1, $2, $3, $4, $5, $6);
	            case 8:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
	            case 9:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
	            case 10:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
	            }
	        }));
	    });

	    /**
	     * Accepts at least three functions and returns a new function. When invoked, this new
	     * function will invoke the first function, `after`, passing as its arguments the
	     * results of invoking the subsequent functions with whatever arguments are passed to
	     * the new function.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> ((a -> b -> ... -> x1), (a -> b -> ... -> x2), ...) -> (a -> b -> ... -> z)
	     * @param {Function} after A function. `after` will be invoked with the return values of
	     *        `fn1` and `fn2` as its arguments.
	     * @param {...Function} functions A variable number of functions.
	     * @return {Function} A new function.
	     * @example
	     *
	     *      var add = function(a, b) { return a + b; };
	     *      var multiply = function(a, b) { return a * b; };
	     *      var subtract = function(a, b) { return a - b; };
	     *
	     *      //≅ multiply( add(1, 2), subtract(1, 2) );
	     *      R.converge(multiply, add, subtract)(1, 2); //=> -3
	     *
	     *      var add3 = function(a, b, c) { return a + b + c; };
	     *      R.converge(add3, multiply, add, subtract)(1, 2); //=> 4
	     */
	    var converge = curryN(3, function converge(after) {
	        var fns = _slice(arguments, 1);
	        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
	            var args = arguments;
	            var context = this;
	            return after.apply(context, _map(function (fn) {
	                return fn.apply(context, args);
	            }, fns));
	        });
	    });

	    /**
	     * Returns all but the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `drop` method).
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.transduce
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.take
	     * @example
	     *
	     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(3, 'ramda');               //=> 'da'
	     */
	    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
	        return slice(Math.max(0, n), Infinity, xs);
	    }));

	    /**
	     * Returns a list containing all but the last `n` elements of the given `list`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements of `xs` to skip.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.takeLast
	     * @example
	     *
	     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(3, 'ramda');               //=> 'ra'
	     */
	    var dropLast = _curry2(function dropLast(n, xs) {
	        return take(n < xs.length ? xs.length - n : 0, xs);
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements. Equality is
	     * determined by applying the supplied predicate two consecutive elements.
	     * The first element in a series of equal element is the one being preserved.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @example
	     *
	     *      function lengthEq(x, y) { return Math.abs(x) === Math.abs(y); };
	     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
	     *      R.dropRepeatsWith(lengthEq, l); //=> [1, 3, 4, -5, 3]
	     */
	    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
	        var result = [];
	        var idx = 1;
	        var len = list.length;
	        if (len !== 0) {
	            result[0] = list[0];
	            while (idx < len) {
	                if (!pred(last(result), list[idx])) {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	        }
	        return result;
	    }));

	    /**
	     * Reports whether two objects have the same value, in `R.equals` terms,
	     * for the specified property. Useful as a curried predicate.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig k -> {k: v} -> {k: v} -> Boolean
	     * @param {String} prop The name of the property to compare
	     * @param {Object} obj1
	     * @param {Object} obj2
	     * @return {Boolean}
	     *
	     * @example
	     *
	     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
	     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
	     *      R.eqProps('a', o1, o2); //=> false
	     *      R.eqProps('c', o1, o2); //=> true
	     */
	    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
	        return equals(obj1[prop], obj2[prop]);
	    });

	    /**
	     * Returns the position of the first occurrence of an item in an array,
	     * or -1 if the item is not included in the array. `R.equals` is used to
	     * determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.lastIndexOf
	     * @example
	     *
	     *      R.indexOf(3, [1,2,3,4]); //=> 2
	     *      R.indexOf(10, [1,2,3,4]); //=> -1
	     */
	    var indexOf = _curry2(function indexOf(target, xs) {
	        return _hasMethod('indexOf', xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
	    });

	    /**
	     * Returns all but the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.last, R.head, R.tail
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.init([1, 2, 3]);  //=> [1, 2]
	     *      R.init([1, 2]);     //=> [1]
	     *      R.init([1]);        //=> []
	     *      R.init([]);         //=> []
	     *
	     *      R.init('abc');  //=> 'ab'
	     *      R.init('ab');   //=> 'a'
	     *      R.init('a');    //=> ''
	     *      R.init('');     //=> ''
	     */
	    var init = slice(0, -1);

	    /**
	     * Returns `true` if all elements are unique, in `R.equals` terms,
	     * otherwise `false`.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> Boolean
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if all elements are unique, else `false`.
	     * @example
	     *
	     *      R.isSet(['1', 1]); //=> true
	     *      R.isSet([1, 1]);   //=> false
	     *      R.isSet([[42], [42]]); //=> false
	     */
	    var isSet = _curry1(function isSet(list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            if (_indexOf(list, list[idx], idx + 1) >= 0) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    });

	    /**
	     * Returns a lens for the given getter and setter functions. The getter "gets"
	     * the value of the focus; the setter "sets" the value of the focus. The setter
	     * should not mutate the data structure.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
	     * @param {Function} getter
	     * @param {Function} setter
	     * @return {Lens}
	     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lens = _curry2(function lens(getter, setter) {
	        return function (f) {
	            return function (s) {
	                return map(function (v) {
	                    return setter(v, s);
	                }, f(getter(s)));
	            };
	        };
	    });

	    /**
	     * Returns a lens whose focus is the specified index.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Number -> Lens s a
	     * @param {Number} n
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
	     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
	     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
	     */
	    var lensIndex = _curry1(function lensIndex(n) {
	        return lens(nth(n), update(n));
	    });

	    /**
	     * Returns a lens whose focus is the specified property.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig String -> Lens s a
	     * @param {String} k
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lensProp = _curry1(function lensProp(k) {
	        return lens(prop(k), assoc(k));
	    });

	    /**
	     * "lifts" a function to be the specified arity, so that it may "map over" that many
	     * lists (or other Functors).
	     *
	     * @func
	     * @memberOf R
	     * @see R.lift
	     * @category Function
	     * @sig Number -> (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The function `fn` applicable to mappable objects.
	     * @example
	     *
	     *      var madd3 = R.liftN(3, R.curryN(3, function() {
	     *        return R.reduce(R.add, 0, arguments);
	     *      }));
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     */
	    var liftN = _curry2(function liftN(arity, fn) {
	        var lifted = curryN(arity, fn);
	        return curryN(arity, function () {
	            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
	        });
	    });

	    /**
	     * Returns the mean of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.mean([2, 7, 9]); //=> 6
	     *      R.mean([]); //=> NaN
	     */
	    var mean = _curry1(function mean(list) {
	        return sum(list) / list.length;
	    });

	    /**
	     * Returns the median of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.median([2, 9, 7]); //=> 7
	     *      R.median([7, 2, 10, 9]); //=> 8
	     *      R.median([]); //=> NaN
	     */
	    var median = _curry1(function median(list) {
	        var len = list.length;
	        if (len === 0) {
	            return NaN;
	        }
	        var width = 2 - len % 2;
	        var idx = (len - width) / 2;
	        return mean(_slice(list).sort(function (a, b) {
	            return a < b ? -1 : a > b ? 1 : 0;
	        }).slice(idx, idx + width));
	    });

	    /**
	     * Merges a list of objects together into one object.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [{k: v}] -> {k: v}
	     * @param {Array} list An array of objects
	     * @return {Object} A merged object.
	     * @see R.reduce
	     * @example
	     *
	     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
	     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
	     */
	    var mergeAll = _curry1(function mergeAll(list) {
	        return reduce(merge, {}, list);
	    });

	    /**
	     * Performs left-to-right function composition. The leftmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * In some libraries this function is named `sequence`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a -> b -> ... -> n -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.compose
	     * @example
	     *
	     *      var f = R.pipe(Math.pow, R.negate, R.inc);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var pipe = function pipe() {
	        if (arguments.length === 0) {
	            throw new Error('pipe requires at least one argument');
	        }
	        return curryN(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	    };

	    /**
	     * Performs left-to-right composition of one or more Promise-returning
	     * functions. The leftmost function may have any arity; the remaining
	     * functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.composeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
	     */
	    var pipeP = function pipeP() {
	        if (arguments.length === 0) {
	            throw new Error('pipeP requires at least one argument');
	        }
	        return curryN(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
	    };

	    /**
	     * Multiplies together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The product of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.product([2,4,6,8,100,1]); //=> 38400
	     */
	    var product = reduce(multiply, 1);

	    /**
	     * Reasonable analog to SQL `select` statement.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @category Relation
	     * @sig [k] -> [{k: v}] -> [{k: v}]
	     * @param {Array} props The property names to project
	     * @param {Array} objs The objects to query
	     * @return {Array} An array of objects with just the `props` properties.
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
	     *      var kids = [abby, fred];
	     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
	     */
	    // passing `identity` gives correct arity
	    var project = useWith(_map, pickAll, identity);

	    /**
	     * Returns a new list containing the last `n` elements of the given list.
	     * If `n > list.length`, returns a list of `list.length` elements.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements to return.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.dropLast
	     * @example
	     *
	     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['for', 'baz']
	     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(3, 'ramda');               //=> 'mda'
	     */
	    var takeLast = _curry2(function takeLast(n, xs) {
	        return drop(n >= 0 ? xs.length - n : 0, xs);
	    });

	    var _contains = function _contains(a, list) {
	        return _indexOf(list, a, 0) >= 0;
	    };

	    //  mapPairs :: (Object, [String]) -> [String]
	    // Function, RegExp, user-defined types
	    var _toString = function _toString(x, seen) {
	        var recur = function recur(y) {
	            var xs = seen.concat([x]);
	            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
	        };
	        //  mapPairs :: (Object, [String]) -> [String]
	        var mapPairs = function (obj, keys) {
	            return _map(function (k) {
	                return _quote(k) + ': ' + recur(obj[k]);
	            }, keys.slice().sort());
	        };
	        switch (Object.prototype.toString.call(x)) {
	        case '[object Arguments]':
	            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
	        case '[object Array]':
	            return '[' + _map(recur, x).concat(mapPairs(x, reject(test(/^\d+$/), keys(x)))).join(', ') + ']';
	        case '[object Boolean]':
	            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
	        case '[object Date]':
	            return 'new Date(' + _quote(_toISOString(x)) + ')';
	        case '[object Null]':
	            return 'null';
	        case '[object Number]':
	            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
	        case '[object String]':
	            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
	        case '[object Undefined]':
	            return 'undefined';
	        default:
	            return typeof x.constructor === 'function' && x.constructor.name !== 'Object' && typeof x.toString === 'function' && x.toString() !== '[object Object]' ? x.toString() : // Function, RegExp, user-defined types
	            '{' + mapPairs(x, keys(x)).join(', ') + '}';
	        }
	    };

	    /**
	     * Turns a list of Functors into a Functor of a list.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @see R.commuteMap
	     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @example
	     *
	     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
	     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
	     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
	     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     */
	    var commute = commuteMap(identity);

	    /**
	     * Performs right-to-left function composition. The rightmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> (a -> b -> ... -> n -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipe
	     * @example
	     *
	     *      var f = R.compose(R.inc, R.negate, Math.pow);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var compose = function compose() {
	        if (arguments.length === 0) {
	            throw new Error('compose requires at least one argument');
	        }
	        return pipe.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the right-to-left Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @see R.pipeK
	     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.composeK(
	     *        R.compose(Maybe.of, R.toUpper),
	     *        get('state'),
	     *        get('address'),
	     *        get('user'),
	     *        parseJson
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var composeK = function composeK() {
	        return arguments.length === 0 ? identity : compose.apply(this, map(chain, arguments));
	    };

	    /**
	     * Performs right-to-left composition of one or more Promise-returning
	     * functions. The rightmost function may have any arity; the remaining
	     * functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
	     */
	    var composeP = function composeP() {
	        if (arguments.length === 0) {
	            throw new Error('composeP requires at least one argument');
	        }
	        return pipeP.apply(this, reverse(arguments));
	    };

	    /**
	     * Wraps a constructor function inside a curried function that can be called with the same
	     * arguments and returns the same type.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (* -> {*}) -> (* -> {*})
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Constructor function
	     *      var Widget = function(config) {
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
	     */
	    var construct = _curry1(function construct(Fn) {
	        return constructN(Fn.length, Fn);
	    });

	    /**
	     * Returns `true` if the specified value is equal, in `R.equals` terms,
	     * to at least one element of the given list; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig a -> [a] -> Boolean
	     * @param {Object} a The item to compare against.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
	     *
	     * @example
	     *
	     *      R.contains(3, [1, 2, 3]); //=> true
	     *      R.contains(4, [1, 2, 3]); //=> false
	     *      R.contains([42], [[42]]); //=> true
	     */
	    var contains = _curry2(_contains);

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.differenceWith
	     * @example
	     *
	     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
	     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
	     */
	    var difference = _curry2(function difference(first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
	                out[out.length] = first[idx];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements.
	     * `R.equals` is used to determine equality.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     * @see R.transduce
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @example
	     *
	     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
	     */
	    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @see R.intersectionWith
	     * @return {Array} The list of elements found in both `list1` and `list2`.
	     * @example
	     *
	     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
	     */
	    var intersection = _curry2(function intersection(list1, list2) {
	        return uniq(_filter(flip(_contains)(list1), list2));
	    });

	    /**
	     * "lifts" a function of arity > 1 so that it may "map over" an Array or
	     * other Functor.
	     *
	     * @func
	     * @memberOf R
	     * @see R.liftN
	     * @category Function
	     * @sig (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The function `fn` applicable to mappable objects.
	     * @example
	     *
	     *      var madd3 = R.lift(R.curry(function(a, b, c) {
	     *        return a + b + c;
	     *      }));
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     *
	     *      var madd5 = R.lift(R.curry(function(a, b, c, d, e) {
	     *        return a + b + c + d + e;
	     *      }));
	     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
	     */
	    var lift = _curry1(function lift(fn) {
	        return liftN(fn.length, fn);
	    });

	    /**
	     * Returns a partial copy of an object omitting the keys specified.
	     *
	     * @func
	     * @memberOf R
	     * @category Object
	     * @sig [String] -> {String: *} -> {String: *}
	     * @param {Array} names an array of String property names to omit from the new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with properties from `names` not on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	     */
	    var omit = _curry2(function omit(names, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (!_contains(prop, names)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the left-to-right Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @see R.composeK
	     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.pipeK(
	     *        parseJson,
	     *        get('user'),
	     *        get('address'),
	     *        get('state'),
	     *        R.compose(Maybe.of, R.toUpper)
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var pipeK = function pipeK() {
	        return composeK.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the string representation of the given value. `eval`'ing the output
	     * should result in a value equivalent to the input value. Many of the built-in
	     * `toString` methods do not satisfy this requirement.
	     *
	     * If the given value is an `[object Object]` with a `toString` method other
	     * than `Object.prototype.toString`, this method is invoked with no arguments
	     * to produce the return value. This means user-defined constructor functions
	     * can provide a suitable `toString` method. For example:
	     *
	     *     function Point(x, y) {
	     *       this.x = x;
	     *       this.y = y;
	     *     }
	     *
	     *     Point.prototype.toString = function() {
	     *       return 'new Point(' + this.x + ', ' + this.y + ')';
	     *     };
	     *
	     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig * -> String
	     * @param {*} val
	     * @return {String}
	     * @example
	     *
	     *      R.toString(42); //=> '42'
	     *      R.toString('abc'); //=> '"abc"'
	     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
	     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
	     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
	     */
	    var toString = _curry1(function toString(val) {
	        return _toString(val, []);
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the
	     * elements of each list.
	     *
	     * @func
	     * @memberOf R
	     * @category Relation
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @example
	     *
	     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
	     */
	    var union = _curry2(compose(uniq, _concat));

	    /**
	     * Returns a new list containing only one copy of each element in the
	     * original list, based upon the value returned by applying the supplied
	     * function to each list element. Prefers the first item if the supplied
	     * function produces the same value on two items. `R.equals` is used for
	     * comparison.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig (a -> b) -> [a] -> [a]
	     * @param {Function} fn A function used to produce a value to use during comparisons.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
	     */
	    var uniqBy = _curry2(function uniqBy(fn, list) {
	        var idx = 0, applied = [], result = [], appliedItem, item;
	        while (idx < list.length) {
	            item = list[idx];
	            appliedItem = fn(item);
	            if (!_contains(appliedItem, applied)) {
	                result.push(item);
	                applied.push(appliedItem);
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Turns a named method with a specified arity into a function
	     * that can be called directly supplied with arguments and a target object.
	     *
	     * The returned function is curried and accepts `arity + 1` parameters where
	     * the final parameter is the target object.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
	     * @param {Number} arity Number of arguments the returned function should take
	     *        before the target object.
	     * @param {Function} method Name of the method to call.
	     * @return {Function} A new curried function.
	     * @example
	     *
	     *      var sliceFrom = R.invoker(1, 'slice');
	     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
	     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
	     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
	     */
	    var invoker = _curry2(function invoker(arity, method) {
	        return curryN(arity + 1, function () {
	            var target = arguments[arity];
	            if (target != null && is(Function, target[method])) {
	                return target[method].apply(target, _slice(arguments, 0, arity));
	            }
	            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
	        });
	    });

	    /**
	     * Returns a string made by inserting the `separator` between each
	     * element and concatenating all the elements into a single string.
	     *
	     * @func
	     * @memberOf R
	     * @category List
	     * @sig String -> [a] -> String
	     * @param {Number|String} separator The string used to separate the elements.
	     * @param {Array} xs The elements to join into a string.
	     * @return {String} str The string made by concatenating `xs` with `separator`.
	     * @see R.split
	     * @example
	     *
	     *      var spacer = R.join(' ');
	     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
	     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
	     */
	    var join = invoker(1, 'join');

	    /**
	     * Creates a new function that, when invoked, caches the result of calling `fn` for a given
	     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
	     * argument set will not result in an additional call to `fn`; instead, the cached result
	     * for that set of arguments will be returned.
	     *
	     * @func
	     * @memberOf R
	     * @category Function
	     * @sig (*... -> a) -> (*... -> a)
	     * @param {Function} fn The function to memoize.
	     * @return {Function} Memoized version of `fn`.
	     * @example
	     *
	     *      var count = 0;
	     *      var factorial = R.memoize(function(n) {
	     *        count += 1;
	     *        return R.product(R.range(1, n + 1));
	     *      });
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      count; //=> 1
	     */
	    var memoize = _curry1(function memoize(fn) {
	        var cache = {};
	        return function () {
	            var key = toString(arguments);
	            if (!_has(key, cache)) {
	                cache[key] = fn.apply(this, arguments);
	            }
	            return cache[key];
	        };
	    });

	    /**
	     * Splits a string into an array of strings based on the given
	     * separator.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String -> [String]
	     * @param {String} sep The separator string.
	     * @param {String} str The string to separate into an array.
	     * @return {Array} The array of strings from `str` separated by `str`.
	     * @see R.join
	     * @example
	     *
	     *      var pathComponents = R.split('/');
	     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
	     *
	     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
	     */
	    var split = invoker(1, 'split');

	    /**
	     * The lower case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to lower case.
	     * @return {String} The lower case version of `str`.
	     * @see R.toUpper
	     * @example
	     *
	     *      R.toLower('XYZ'); //=> 'xyz'
	     */
	    var toLower = invoker(0, 'toLowerCase');

	    /**
	     * The upper case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to upper case.
	     * @return {String} The upper case version of `str`.
	     * @see R.toLower
	     * @example
	     *
	     *      R.toUpper('abc'); //=> 'ABC'
	     */
	    var toUpper = invoker(0, 'toUpperCase');

	    var R = {
	        F: F,
	        T: T,
	        __: __,
	        add: add,
	        addIndex: addIndex,
	        adjust: adjust,
	        all: all,
	        allPass: allPass,
	        always: always,
	        and: and,
	        any: any,
	        anyPass: anyPass,
	        ap: ap,
	        aperture: aperture,
	        append: append,
	        apply: apply,
	        assoc: assoc,
	        assocPath: assocPath,
	        binary: binary,
	        bind: bind,
	        both: both,
	        call: call,
	        chain: chain,
	        clone: clone,
	        commute: commute,
	        commuteMap: commuteMap,
	        comparator: comparator,
	        complement: complement,
	        compose: compose,
	        composeK: composeK,
	        composeP: composeP,
	        concat: concat,
	        cond: cond,
	        construct: construct,
	        constructN: constructN,
	        contains: contains,
	        containsWith: containsWith,
	        converge: converge,
	        countBy: countBy,
	        createMapEntry: createMapEntry,
	        curry: curry,
	        curryN: curryN,
	        dec: dec,
	        defaultTo: defaultTo,
	        difference: difference,
	        differenceWith: differenceWith,
	        dissoc: dissoc,
	        dissocPath: dissocPath,
	        divide: divide,
	        drop: drop,
	        dropLast: dropLast,
	        dropLastWhile: dropLastWhile,
	        dropRepeats: dropRepeats,
	        dropRepeatsWith: dropRepeatsWith,
	        dropWhile: dropWhile,
	        either: either,
	        empty: empty,
	        eqProps: eqProps,
	        equals: equals,
	        evolve: evolve,
	        filter: filter,
	        find: find,
	        findIndex: findIndex,
	        findLast: findLast,
	        findLastIndex: findLastIndex,
	        flatten: flatten,
	        flip: flip,
	        forEach: forEach,
	        fromPairs: fromPairs,
	        functions: functions,
	        functionsIn: functionsIn,
	        groupBy: groupBy,
	        gt: gt,
	        gte: gte,
	        has: has,
	        hasIn: hasIn,
	        head: head,
	        identical: identical,
	        identity: identity,
	        ifElse: ifElse,
	        inc: inc,
	        indexOf: indexOf,
	        init: init,
	        insert: insert,
	        insertAll: insertAll,
	        intersection: intersection,
	        intersectionWith: intersectionWith,
	        intersperse: intersperse,
	        into: into,
	        invert: invert,
	        invertObj: invertObj,
	        invoker: invoker,
	        is: is,
	        isArrayLike: isArrayLike,
	        isEmpty: isEmpty,
	        isNil: isNil,
	        isSet: isSet,
	        join: join,
	        keys: keys,
	        keysIn: keysIn,
	        last: last,
	        lastIndexOf: lastIndexOf,
	        length: length,
	        lens: lens,
	        lensIndex: lensIndex,
	        lensProp: lensProp,
	        lift: lift,
	        liftN: liftN,
	        lt: lt,
	        lte: lte,
	        map: map,
	        mapAccum: mapAccum,
	        mapAccumRight: mapAccumRight,
	        mapObj: mapObj,
	        mapObjIndexed: mapObjIndexed,
	        match: match,
	        mathMod: mathMod,
	        max: max,
	        maxBy: maxBy,
	        mean: mean,
	        median: median,
	        memoize: memoize,
	        merge: merge,
	        mergeAll: mergeAll,
	        min: min,
	        minBy: minBy,
	        modulo: modulo,
	        multiply: multiply,
	        nAry: nAry,
	        negate: negate,
	        none: none,
	        not: not,
	        nth: nth,
	        nthArg: nthArg,
	        nthChar: nthChar,
	        nthCharCode: nthCharCode,
	        of: of,
	        omit: omit,
	        once: once,
	        or: or,
	        over: over,
	        partial: partial,
	        partialRight: partialRight,
	        partition: partition,
	        path: path,
	        pathEq: pathEq,
	        pick: pick,
	        pickAll: pickAll,
	        pickBy: pickBy,
	        pipe: pipe,
	        pipeK: pipeK,
	        pipeP: pipeP,
	        pluck: pluck,
	        prepend: prepend,
	        product: product,
	        project: project,
	        prop: prop,
	        propEq: propEq,
	        propIs: propIs,
	        propOr: propOr,
	        propSatisfies: propSatisfies,
	        props: props,
	        range: range,
	        reduce: reduce,
	        reduceRight: reduceRight,
	        reduced: reduced,
	        reject: reject,
	        remove: remove,
	        repeat: repeat,
	        replace: replace,
	        reverse: reverse,
	        scan: scan,
	        set: set,
	        slice: slice,
	        sort: sort,
	        sortBy: sortBy,
	        split: split,
	        splitEvery: splitEvery,
	        subtract: subtract,
	        sum: sum,
	        tail: tail,
	        take: take,
	        takeLast: takeLast,
	        takeLastWhile: takeLastWhile,
	        takeWhile: takeWhile,
	        tap: tap,
	        test: test,
	        times: times,
	        toLower: toLower,
	        toPairs: toPairs,
	        toPairsIn: toPairsIn,
	        toString: toString,
	        toUpper: toUpper,
	        transduce: transduce,
	        trim: trim,
	        type: type,
	        unapply: unapply,
	        unary: unary,
	        uncurryN: uncurryN,
	        unfold: unfold,
	        union: union,
	        unionWith: unionWith,
	        uniq: uniq,
	        uniqBy: uniqBy,
	        uniqWith: uniqWith,
	        unnest: unnest,
	        update: update,
	        useWith: useWith,
	        values: values,
	        valuesIn: valuesIn,
	        view: view,
	        where: where,
	        whereEq: whereEq,
	        wrap: wrap,
	        xprod: xprod,
	        zip: zip,
	        zipObj: zipObj,
	        zipWith: zipWith
	    };

	  /* TEST_ENTRY_POINT */

	  if (true) {
	    module.exports = R;
	  } else if (typeof define === 'function' && define.amd) {
	    define(function() { return R; });
	  } else {
	    this.R = R;
	  }

	}.call(this));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var _equals = __webpack_require__(16).equals;


	module.exports = {

	  baseMap: function(f) {
	    return f(this.value);
	  },

	  getEquals: function(constructor) {
	    return function equals(that) {
	      return that instanceof constructor && _equals(this.value, that.value);
	    };
	  },

	  extend: function(Child, Parent) {
	    function Ctor() {
	      this.constructor = Child;
	    }
	    Ctor.prototype = Parent.prototype;
	    Child.prototype = new Ctor();
	    Child.super_ = Parent.prototype;
	  },

	  identity: function(x) { return x; },

	  notImplemented: function(str) {
	    return function() {
	      throw new Error(str + ' is not implemented');
	    };
	  },

	  notCallable: function(fn) {
	    return function() {
	      throw new Error(fn + ' cannot be called directly');
	    };
	  },

	  returnThis: function() { return this; }

	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);

	// `f` is a function that takes two function arguments: `reject` (failure) and `resolve` (success)
	function Future(f) {
	  if (!(this instanceof Future)) {
	    return new Future(f);
	  }
	  this._fork = f;
	}

	Future.prototype.fork = function(reject, resolve) {
	  try {
	    this._fork(reject, resolve);
	  } catch(e) {
	    reject(e);
	  }
	};

	// functor
	Future.prototype.map = function(f) {
	  return this.chain(function(a) { return Future.of(f(a)); });
	};

	// apply
	Future.prototype.ap = function(m) {
	  var self = this;

	  return new Future(function(rej, res) {
	    var applyFn, val;
	    var doReject = R.once(rej);

	    function resolveIfDone() {
	      if (applyFn != null && val != null) {
	        return res(applyFn(val));
	      }
	    }

	    self.fork(doReject, function(fn) {
	      applyFn = fn;
	      resolveIfDone();
	    });

	    m.fork(doReject, function(v) {
	      val = v;
	      resolveIfDone();
	    });

	  });

	};

	// applicative
	Future.of = function(x) {
	  // should include a default rejection?
	  return new Future(function(_, resolve) { return resolve(x); });
	};

	Future.prototype.of = Future.of;

	// chain
	//  f must be a function which returns a value
	//  f must return a value of the same Chain
	//  chain must return a value of the same Chain
	//:: Future a, b => (b -> Future c) -> Future c
	Future.prototype.chain = function(f) {  // Sorella's:
	  return new Future(function(reject, resolve) {
	    return this.fork(function(a) { return reject(a); },
	                     function(b) { return f(b).fork(reject, resolve); });
	  }.bind(this));
	};

	// chainReject
	// Like chain but operates on the reject instead of the resolve case.
	//:: Future a, b => (a -> Future c) -> Future c
	Future.prototype.chainReject = function(f) {
	  return new Future(function(reject, resolve) {
	    return this.fork(function(a) { return f(a).fork(reject, resolve); },
	                     function(b) { return resolve(b);
	    });
	  }.bind(this));
	};

	// monad
	// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
	// see above.

	Future.prototype.bimap = function(errFn, successFn) {
	  var self = this;
	  return new Future(function(reject, resolve) {
	    self.fork(function(err) {
	      reject(errFn(err));
	    }, function(val) {
	      resolve(successFn(val));
	    });
	  });
	};

	Future.reject = function(val) {
	  return new Future(function(reject) {
	    reject(val);
	  });
	};

	Future.prototype.toString = function() {
	  return 'Future(' + R.toString(this._fork) + ')';
	};

	Future.cache = function(f) {
	  var status = 'IDLE';
	  var listeners = [];
	  var cachedValue;

	  var handleCompletion = R.curry(function(newStatus, cb, val) {
	    status = newStatus;
	    cachedValue = val;
	    cb(val);
	    R.forEach(function(listener) {
	      listener[status](cachedValue);
	    }, listeners);
	  });

	  function addListeners(reject, resolve) {
	    listeners.push({ REJECTED: reject, RESOLVED: resolve } );
	  }

	  function doResolve(reject, resolve) {
	    status = 'PENDING';
	    return f.fork(
	      handleCompletion('REJECTED', reject),
	      handleCompletion('RESOLVED', resolve)
	    );
	  }

	  return new Future(function(reject, resolve) {

	    switch(status) {
	      case 'IDLE': doResolve(reject, resolve); break;
	      case 'PENDING': addListeners(reject, resolve); break;
	      case 'REJECTED': reject(cachedValue); break;
	      case 'RESOLVED': resolve(cachedValue); break;
	    }

	  });
	};

	module.exports = Future;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);

	var util = __webpack_require__(17);


	/**
	 * A data type that holds a value and exposes a monadic api.
	 */

	/**
	 * Constructs a new `Identity[a]` data type that holds a single
	 * value `a`.
	 * @param {*} a Value of any type
	 * @sig a -> Identity[a]
	 */
	function Identity(x) {
	  if (!(this instanceof Identity)) {
	    return new Identity(x);
	  }
	  this.value = x;
	}

	/**
	 * Applicative specification. Creates a new `Identity[a]` holding the value `a`.
	 * @param {*} a Value of any type
	 * @returns Identity[a]
	 * @sig a -> Identity[a]
	 */
	Identity.of = function(x) {
	  return new Identity(x);
	};
	Identity.prototype.of = Identity.of;

	/**
	 * Functor specification. Creates a new `Identity[a]` mapping function `f` onto
	 * `a` returning any value b.
	 * @param {Function} f Maps `a` to any value `b`
	 * @returns Identity[b]
	 * @sig @Identity[a] => (a -> b) -> Identity[b]
	 */
	Identity.prototype.map = function(f) {
	  return new Identity(f(this.value));
	};

	/**
	 * Apply specification. Applies the function inside the `Identity[a]`
	 * type to another applicative type.
	 * @param {Applicative[a]} app Applicative that will apply its function
	 * @returns Applicative[b]
	 * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]
	 */
	Identity.prototype.ap = function(app) {
	  return app.map(this.value);
	};

	/**
	 * Chain specification. Transforms the value of the `Identity[a]`
	 * type using an unary function to monads. The `Identity[a]` type
	 * should contain a function, otherwise an error is thrown.
	 *
	 * @param {Function} fn Transforms `a` into a `Monad[b]`
	 * @returns Monad[b]
	 * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]
	 */
	Identity.prototype.chain = function(fn) {
	  return fn(this.value);
	};

	/**
	 * Returns the value of `Identity[a]`
	 *
	 * @returns a
	 * @sig (Identity[a]) => a
	 */
	Identity.prototype.get = function() {
	  return this.value;
	};

	// equality method to enable testing
	Identity.prototype.equals = util.getEquals(Identity);

	Identity.prototype.toString = function() {
	  return 'Identity(' + R.toString(this.value) + ')';
	};

	module.exports = Identity;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);

	module.exports = IO;

	var compose = R.compose;

	function IO(fn) {
	  if (!(this instanceof IO)) {
	    return new IO(fn);
	  }
	  this.fn = fn;
	}

	// `f` must return an IO
	IO.prototype.chain = function(f) {
	  var io = this;
	  return new IO(function() {
	    var next = f(io.fn.apply(io, arguments));
	    return next.fn.apply(next, arguments);
	  });
	};

	IO.prototype.map = function(f) {
	  var io = this;
	  return new IO(compose(f, io.fn));
	};

	// `this` IO must wrap a function `f` that takes an IO (`thatIo`) as input
	// `f` must return an IO
	IO.prototype.ap = function(thatIo) {
	  return this.chain(function(f) {
	    return thatIo.map(f);
	  });
	};

	IO.runIO = function(io) {
	  return io.runIO.apply(io, [].slice.call(arguments, 1));
	};

	IO.prototype.runIO = function() {
	  return this.fn.apply(this, arguments);
	};

	IO.prototype.of = function(x) {
	  return new IO(function() { return x; });
	};

	IO.of = IO.prototype.of;

	IO.prototype.toString = function() {
	  return 'IO(' + R.toString(this.fn) + ')';
	};


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);

	module.exports = R.curryN(3, function lift2(f, a1, a2) {
	  return a1.map(f).ap(a2);
	});


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);

	module.exports = R.curryN(4, function lift3(f, a1, a2, a3) {
	  return a1.map(f).ap(a2).ap(a3);
	});


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);

	var util = __webpack_require__(17);

	function Maybe(x) {
	  return x == null ? _nothing : Maybe.Just(x);
	}

	function _Just(x) {
	  this.value = x;
	}
	util.extend(_Just, Maybe);

	function _Nothing() {}
	util.extend(_Nothing, Maybe);

	var _nothing = new _Nothing();

	Maybe.Nothing = function() {
	  return _nothing;
	};

	Maybe.Just = function(x) {
	  return new _Just(x);
	};

	Maybe.of = Maybe.Just;

	Maybe.prototype.of = Maybe.Just;

	Maybe.isJust = function(x) {
	  return x instanceof _Just;
	};

	Maybe.isNothing = function(x) {
	  return x === _nothing;
	};

	Maybe.maybe = R.curry(function(nothingVal, justFn, m) {
	  return m.reduce(function(_, x) {
	    return justFn(x);
	  }, nothingVal);
	});

	// functor
	_Just.prototype.map = function(f) {
	  return this.of(f(this.value));
	};

	_Nothing.prototype.map = util.returnThis;

	// apply
	// takes a Maybe that wraps a function (`app`) and applies its `map`
	// method to this Maybe's value, which must be a function.
	_Just.prototype.ap = function(m) {
	  return m.map(this.value);
	};

	_Nothing.prototype.ap = util.returnThis;

	// applicative
	// `of` inherited from `Maybe`


	// chain
	//  f must be a function which returns a value
	//  f must return a value of the same Chain
	//  chain must return a value of the same Chain
	_Just.prototype.chain = util.baseMap;

	_Nothing.prototype.chain = util.returnThis;


	//
	_Just.prototype.datatype = _Just;

	_Nothing.prototype.datatype = _Nothing;

	// monad
	// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
	// see above.

	// equality method to enable testing
	_Just.prototype.equals = util.getEquals(_Just);

	_Nothing.prototype.equals = function(that) {
	  return that === _nothing;
	};

	Maybe.prototype.isNothing = function() {
	  return this === _nothing;
	};

	Maybe.prototype.isJust = function() {
	  return this instanceof _Just;
	};

	_Just.prototype.getOrElse = function() {
	  return this.value;
	};

	_Nothing.prototype.getOrElse = function(a) {
	  return a;
	};

	_Just.prototype.reduce = function(f, x) {
	  return f(x, this.value);
	};

	_Nothing.prototype.reduce = function(f, x) {
	  return x;
	};

	_Just.prototype.toString = function() {
	  return 'Maybe.Just(' + R.toString(this.value) + ')';
	};

	_Nothing.prototype.toString = function() {
	  return 'Maybe.Nothing()';
	};

	module.exports = Maybe;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);


	function Tuple(x, y) {
	  switch (arguments.length) {
	    case 0:
	      throw new TypeError('no arguments to Tuple');
	    case 1:
	      return function(y) {
	        return new _Tuple(x, y);
	      };
	    default:
	      return new _Tuple(x, y);
	  }
	}

	function _Tuple(x, y) {
	  this[0] = x;
	  this[1] = y;
	  this.length = 2;
	}

	function ensureConcat(xs) {
	  xs.forEach(function(x) {
	    if (typeof x.concat != 'function') {
	      throw new TypeError(R.toString(x) + ' must be a semigroup to perform this operation');
	    }
	  });
	}

	Tuple.fst = function(x) {
	  return x[0];
	};

	Tuple.snd = function(x) {
	  return x[1];
	};

	// semigroup
	_Tuple.prototype.concat = function(x) {
	  ensureConcat([this[0], this[1]]);
	  return Tuple(this[0].concat(x[0]), this[1].concat(x[1]));
	};

	// functor
	_Tuple.prototype.map = function(f) {
	  return Tuple(this[0], f(this[1]));
	};

	// apply
	_Tuple.prototype.ap = function(m) {
	  ensureConcat([this[0]]);
	  return Tuple(this[0].concat(m[0]), this[1](m[1]));
	};

	// setoid
	_Tuple.prototype.equals = function(that) {
	  return that instanceof _Tuple && R.equals(this[0], that[0]) && R.equals(this[1], that[1]);
	};

	_Tuple.prototype.toString = function() {
	  return 'Tuple(' + R.toString(this[0]) + ', ' + R.toString(this[1]) + ')';
	};

	module.exports = Tuple;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(16);


	function Reader(run) {
	  if (!(this instanceof Reader)) {
	    return new Reader(run);
	  }
	  this.run = run;
	}

	Reader.run = function(reader) {
	  return reader.run.apply(reader, [].slice.call(arguments, 1));
	};

	Reader.prototype.chain = function(f) {
	  var reader = this;
	  return new Reader(function(r) {
	    return f(reader.run(r)).run(r);
	  });
	};

	Reader.prototype.ap = function(a) {
	  return this.chain(function(f) {
	    return a.map(f);
	  });
	};

	Reader.prototype.map = function(f) {
	  return this.chain(function(a) {
	    return Reader.of(f(a));
	  });
	};

	Reader.prototype.of = function(a) {
	  return new Reader(function() {
	    return a;
	  });
	};
	Reader.of = Reader.prototype.of;

	Reader.ask = Reader(R.identity);

	Reader.prototype.toString = function() {
	  return 'Reader(' + R.toString(this.run) + ')';
	};

	Reader.T = function(M) {
	  var ReaderT = function ReaderT(run) {
	    if (!(this instanceof ReaderT)) {
	      return new ReaderT(run);
	    }
	    this.run = run;
	  };

	  ReaderT.lift = R.compose(ReaderT, R.always);

	  ReaderT.ask = ReaderT(M.of);

	  ReaderT.prototype.of = ReaderT.of = function(a) {
	    return ReaderT(function() {
	      return M.of(a);
	    });
	  };

	  ReaderT.prototype.chain = function(f) {
	    var readerT = this;
	    return ReaderT(function(e) {
	      var m = readerT.run(e);
	      return m.chain(function(a) {
	        return f(a).run(e);
	      });
	    });
	  };

	  ReaderT.prototype.map = function(f) {
	    return this.chain(function(a) {
	      return ReaderT.of(f(a));
	    });
	  };

	  ReaderT.prototype.ap = function(a) {
	    var readerT = this;
	    return ReaderT(function(e) {
	      return readerT.run(e).ap(a.run(e));
	    });
	  };

	  ReaderT.prototype.equals = function(that) {
	    return this === that ||
	      this.run === that.run ||
	      R.equals(this.run().get(), that.run().get());
	  };

	  ReaderT.prototype.toString = function() {
	    return 'ReaderT[' + M.name + '](' + R.toString(this.run) + ')';
	  };

	  return ReaderT;
	};

	module.exports = Reader;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	//  Ramda v0.19.1
	//  https://github.com/ramda/ramda
	//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
	//  Ramda may be freely distributed under the MIT license.

	;(function() {

	  'use strict';

	  /**
	     * A special placeholder value used to specify "gaps" within curried functions,
	     * allowing partial application of any combination of arguments, regardless of
	     * their positions.
	     *
	     * If `g` is a curried ternary function and `_` is `R.__`, the following are
	     * equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2, _)(1, 3)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @constant
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @example
	     *
	     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
	     *      greet('Alice'); //=> 'Hello, Alice!'
	     */
	    var __ = { '@@functional/placeholder': true };

	    /* eslint-disable no-unused-vars */
	    var _arity = function _arity(n, fn) {
	        /* eslint-disable no-unused-vars */
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.apply(this, arguments);
	            };
	        case 1:
	            return function (a0) {
	                return fn.apply(this, arguments);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.apply(this, arguments);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.apply(this, arguments);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.apply(this, arguments);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.apply(this, arguments);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.apply(this, arguments);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.apply(this, arguments);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.apply(this, arguments);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.apply(this, arguments);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.apply(this, arguments);
	            };
	        default:
	            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	        }
	    };

	    var _arrayFromIterator = function _arrayFromIterator(iter) {
	        var list = [];
	        var next;
	        while (!(next = iter.next()).done) {
	            list.push(next.value);
	        }
	        return list;
	    };

	    var _cloneRegExp = function _cloneRegExp(pattern) {
	        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
	    };

	    var _complement = function _complement(f) {
	        return function () {
	            return !f.apply(this, arguments);
	        };
	    };

	    /**
	     * Private `concat` function to merge two array-like objects.
	     *
	     * @private
	     * @param {Array|Arguments} [set1=[]] An array-like object.
	     * @param {Array|Arguments} [set2=[]] An array-like object.
	     * @return {Array} A new, merged array.
	     * @example
	     *
	     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     */
	    var _concat = function _concat(set1, set2) {
	        set1 = set1 || [];
	        set2 = set2 || [];
	        var idx;
	        var len1 = set1.length;
	        var len2 = set2.length;
	        var result = [];
	        idx = 0;
	        while (idx < len1) {
	            result[result.length] = set1[idx];
	            idx += 1;
	        }
	        idx = 0;
	        while (idx < len2) {
	            result[result.length] = set2[idx];
	            idx += 1;
	        }
	        return result;
	    };

	    var _containsWith = function _containsWith(pred, x, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (pred(x, list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    };

	    var _filter = function _filter(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        while (idx < len) {
	            if (fn(list[idx])) {
	                result[result.length] = list[idx];
	            }
	            idx += 1;
	        }
	        return result;
	    };

	    var _forceReduced = function _forceReduced(x) {
	        return {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    var _has = function _has(prop, obj) {
	        return Object.prototype.hasOwnProperty.call(obj, prop);
	    };

	    var _identity = function _identity(x) {
	        return x;
	    };

	    var _isArguments = function () {
	        var toString = Object.prototype.toString;
	        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
	            return toString.call(x) === '[object Arguments]';
	        } : function _isArguments(x) {
	            return _has('callee', x);
	        };
	    }();

	    /**
	     * Tests whether or not an object is an array.
	     *
	     * @private
	     * @param {*} val The object to test.
	     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	     * @example
	     *
	     *      _isArray([]); //=> true
	     *      _isArray(null); //=> false
	     *      _isArray({}); //=> false
	     */
	    var _isArray = Array.isArray || function _isArray(val) {
	        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	    };

	    /**
	     * Determine if the passed argument is an integer.
	     *
	     * @private
	     * @param {*} n
	     * @category Type
	     * @return {Boolean}
	     */
	    var _isInteger = Number.isInteger || function _isInteger(n) {
	        return n << 0 === n;
	    };

	    var _isNumber = function _isNumber(x) {
	        return Object.prototype.toString.call(x) === '[object Number]';
	    };

	    var _isObject = function _isObject(x) {
	        return Object.prototype.toString.call(x) === '[object Object]';
	    };

	    var _isPlaceholder = function _isPlaceholder(a) {
	        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
	    };

	    var _isRegExp = function _isRegExp(x) {
	        return Object.prototype.toString.call(x) === '[object RegExp]';
	    };

	    var _isString = function _isString(x) {
	        return Object.prototype.toString.call(x) === '[object String]';
	    };

	    var _isTransformer = function _isTransformer(obj) {
	        return typeof obj['@@transducer/step'] === 'function';
	    };

	    var _map = function _map(fn, functor) {
	        var idx = 0;
	        var len = functor.length;
	        var result = Array(len);
	        while (idx < len) {
	            result[idx] = fn(functor[idx]);
	            idx += 1;
	        }
	        return result;
	    };

	    var _of = function _of(x) {
	        return [x];
	    };

	    var _pipe = function _pipe(f, g) {
	        return function () {
	            return g.call(this, f.apply(this, arguments));
	        };
	    };

	    var _pipeP = function _pipeP(f, g) {
	        return function () {
	            var ctx = this;
	            return f.apply(ctx, arguments).then(function (x) {
	                return g.call(ctx, x);
	            });
	        };
	    };

	    // \b matches word boundary; [\b] matches backspace
	    var _quote = function _quote(s) {
	        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
	    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
	        return '"' + escaped.replace(/"/g, '\\"') + '"';
	    };

	    var _reduced = function _reduced(x) {
	        return x && x['@@transducer/reduced'] ? x : {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * An optimized, private array `slice` implementation.
	     *
	     * @private
	     * @param {Arguments|Array} args The array or arguments object to consider.
	     * @param {Number} [from=0] The array index to slice from, inclusive.
	     * @param {Number} [to=args.length] The array index to slice to, exclusive.
	     * @return {Array} A new, sliced array.
	     * @example
	     *
	     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
	     *
	     *      var firstThreeArgs = function(a, b, c, d) {
	     *        return _slice(arguments, 0, 3);
	     *      };
	     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
	     */
	    var _slice = function _slice(args, from, to) {
	        switch (arguments.length) {
	        case 1:
	            return _slice(args, 0, args.length);
	        case 2:
	            return _slice(args, from, args.length);
	        default:
	            var list = [];
	            var idx = 0;
	            var len = Math.max(0, Math.min(args.length, to) - from);
	            while (idx < len) {
	                list[idx] = args[from + idx];
	                idx += 1;
	            }
	            return list;
	        }
	    };

	    /**
	     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
	     */
	    var _toISOString = function () {
	        var pad = function pad(n) {
	            return (n < 10 ? '0' : '') + n;
	        };
	        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
	            return d.toISOString();
	        } : function _toISOString(d) {
	            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
	        };
	    }();

	    var _xfBase = {
	        init: function () {
	            return this.xf['@@transducer/init']();
	        },
	        result: function (result) {
	            return this.xf['@@transducer/result'](result);
	        }
	    };

	    var _xwrap = function () {
	        function XWrap(fn) {
	            this.f = fn;
	        }
	        XWrap.prototype['@@transducer/init'] = function () {
	            throw new Error('init not implemented on XWrap');
	        };
	        XWrap.prototype['@@transducer/result'] = function (acc) {
	            return acc;
	        };
	        XWrap.prototype['@@transducer/step'] = function (acc, x) {
	            return this.f(acc, x);
	        };
	        return function _xwrap(fn) {
	            return new XWrap(fn);
	        };
	    }();

	    var _aperture = function _aperture(n, list) {
	        var idx = 0;
	        var limit = list.length - (n - 1);
	        var acc = new Array(limit >= 0 ? limit : 0);
	        while (idx < limit) {
	            acc[idx] = _slice(list, idx, idx + n);
	            idx += 1;
	        }
	        return acc;
	    };

	    /**
	     * Similar to hasMethod, this checks whether a function has a [methodname]
	     * function. If it isn't an array it will execute that function otherwise it
	     * will default to the ramda implementation.
	     *
	     * @private
	     * @param {Function} fn ramda implemtation
	     * @param {String} methodname property to check for a custom implementation
	     * @return {Object} Whatever the return value of the method is.
	     */
	    var _checkForMethod = function _checkForMethod(methodname, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
	        };
	    };

	    /**
	     * Optimized internal one-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry1 = function _curry1(fn) {
	        return function f1(a) {
	            if (arguments.length === 0 || _isPlaceholder(a)) {
	                return f1;
	            } else {
	                return fn.apply(this, arguments);
	            }
	        };
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry2 = function _curry2(fn) {
	        return function f2(a, b) {
	            switch (arguments.length) {
	            case 0:
	                return f2;
	            case 1:
	                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
	                    return fn(a, _b);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b);
	                }) : fn(a, b);
	            }
	        };
	    };

	    /**
	     * Optimized internal three-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry3 = function _curry3(fn) {
	        return function f3(a, b, c) {
	            switch (arguments.length) {
	            case 0:
	                return f3;
	            case 1:
	                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                });
	            case 2:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _curry1(function (_c) {
	                    return fn(a, b, _c);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
	                    return fn(_a, _b, c);
	                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b, c);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b, c);
	                }) : _isPlaceholder(c) ? _curry1(function (_c) {
	                    return fn(a, b, _c);
	                }) : fn(a, b, c);
	            }
	        };
	    };

	    /**
	     * Internal curryN function.
	     *
	     * @private
	     * @category Function
	     * @param {Number} length The arity of the curried function.
	     * @param {Array} received An array of arguments received thus far.
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curryN = function _curryN(length, received, fn) {
	        return function () {
	            var combined = [];
	            var argsIdx = 0;
	            var left = length;
	            var combinedIdx = 0;
	            while (combinedIdx < received.length || argsIdx < arguments.length) {
	                var result;
	                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
	                    result = received[combinedIdx];
	                } else {
	                    result = arguments[argsIdx];
	                    argsIdx += 1;
	                }
	                combined[combinedIdx] = result;
	                if (!_isPlaceholder(result)) {
	                    left -= 1;
	                }
	                combinedIdx += 1;
	            }
	            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	        };
	    };

	    /**
	     * Returns a function that dispatches with different strategies based on the
	     * object in list position (last argument). If it is an array, executes [fn].
	     * Otherwise, if it has a function with [methodname], it will execute that
	     * function (functor case). Otherwise, if it is a transformer, uses transducer
	     * [xf] to return a new transformer (transducer case). Otherwise, it will
	     * default to executing [fn].
	     *
	     * @private
	     * @param {String} methodname property to check for a custom implementation
	     * @param {Function} xf transducer to initialize if object is transformer
	     * @param {Function} fn default ramda implementation
	     * @return {Function} A function that dispatches on object in list position
	     */
	    var _dispatchable = function _dispatchable(methodname, xf, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            if (!_isArray(obj)) {
	                var args = _slice(arguments, 0, length - 1);
	                if (typeof obj[methodname] === 'function') {
	                    return obj[methodname].apply(obj, args);
	                }
	                if (_isTransformer(obj)) {
	                    var transducer = xf.apply(null, args);
	                    return transducer(obj);
	                }
	            }
	            return fn.apply(this, arguments);
	        };
	    };

	    var _dropLastWhile = function dropLastWhile(pred, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && pred(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, 0, idx + 1);
	    };

	    var _xall = function () {
	        function XAll(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.all = true;
	        }
	        XAll.prototype['@@transducer/init'] = _xfBase.init;
	        XAll.prototype['@@transducer/result'] = function (result) {
	            if (this.all) {
	                result = this.xf['@@transducer/step'](result, true);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAll.prototype['@@transducer/step'] = function (result, input) {
	            if (!this.f(input)) {
	                this.all = false;
	                result = _reduced(this.xf['@@transducer/step'](result, false));
	            }
	            return result;
	        };
	        return _curry2(function _xall(f, xf) {
	            return new XAll(f, xf);
	        });
	    }();

	    var _xany = function () {
	        function XAny(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.any = false;
	        }
	        XAny.prototype['@@transducer/init'] = _xfBase.init;
	        XAny.prototype['@@transducer/result'] = function (result) {
	            if (!this.any) {
	                result = this.xf['@@transducer/step'](result, false);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAny.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.any = true;
	                result = _reduced(this.xf['@@transducer/step'](result, true));
	            }
	            return result;
	        };
	        return _curry2(function _xany(f, xf) {
	            return new XAny(f, xf);
	        });
	    }();

	    var _xaperture = function () {
	        function XAperture(n, xf) {
	            this.xf = xf;
	            this.pos = 0;
	            this.full = false;
	            this.acc = new Array(n);
	        }
	        XAperture.prototype['@@transducer/init'] = _xfBase.init;
	        XAperture.prototype['@@transducer/result'] = function (result) {
	            this.acc = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XAperture.prototype['@@transducer/step'] = function (result, input) {
	            this.store(input);
	            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
	        };
	        XAperture.prototype.store = function (input) {
	            this.acc[this.pos] = input;
	            this.pos += 1;
	            if (this.pos === this.acc.length) {
	                this.pos = 0;
	                this.full = true;
	            }
	        };
	        XAperture.prototype.getCopy = function () {
	            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
	        };
	        return _curry2(function _xaperture(n, xf) {
	            return new XAperture(n, xf);
	        });
	    }();

	    var _xdrop = function () {
	        function XDrop(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XDrop.prototype['@@transducer/init'] = _xfBase.init;
	        XDrop.prototype['@@transducer/result'] = _xfBase.result;
	        XDrop.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n > 0) {
	                this.n -= 1;
	                return result;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdrop(n, xf) {
	            return new XDrop(n, xf);
	        });
	    }();

	    var _xdropLast = function () {
	        function XDropLast(n, xf) {
	            this.xf = xf;
	            this.pos = 0;
	            this.full = false;
	            this.acc = new Array(n);
	        }
	        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
	        XDropLast.prototype['@@transducer/result'] = function (result) {
	            this.acc = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.full) {
	                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
	            }
	            this.store(input);
	            return result;
	        };
	        XDropLast.prototype.store = function (input) {
	            this.acc[this.pos] = input;
	            this.pos += 1;
	            if (this.pos === this.acc.length) {
	                this.pos = 0;
	                this.full = true;
	            }
	        };
	        return _curry2(function _xdropLast(n, xf) {
	            return new XDropLast(n, xf);
	        });
	    }();

	    var _xdropRepeatsWith = function () {
	        function XDropRepeatsWith(pred, xf) {
	            this.xf = xf;
	            this.pred = pred;
	            this.lastValue = undefined;
	            this.seenFirstValue = false;
	        }
	        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
	            return this.xf['@@transducer/init']();
	        };
	        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
	            var sameAsLast = false;
	            if (!this.seenFirstValue) {
	                this.seenFirstValue = true;
	            } else if (this.pred(this.lastValue, input)) {
	                sameAsLast = true;
	            }
	            this.lastValue = input;
	            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropRepeatsWith(pred, xf) {
	            return new XDropRepeatsWith(pred, xf);
	        });
	    }();

	    var _xdropWhile = function () {
	        function XDropWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f) {
	                if (this.f(input)) {
	                    return result;
	                }
	                this.f = null;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropWhile(f, xf) {
	            return new XDropWhile(f, xf);
	        });
	    }();

	    var _xfilter = function () {
	        function XFilter(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFilter.prototype['@@transducer/init'] = _xfBase.init;
	        XFilter.prototype['@@transducer/result'] = _xfBase.result;
	        XFilter.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	        };
	        return _curry2(function _xfilter(f, xf) {
	            return new XFilter(f, xf);
	        });
	    }();

	    var _xfind = function () {
	        function XFind(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.found = false;
	        }
	        XFind.prototype['@@transducer/init'] = _xfBase.init;
	        XFind.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, void 0);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFind.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, input));
	            }
	            return result;
	        };
	        return _curry2(function _xfind(f, xf) {
	            return new XFind(f, xf);
	        });
	    }();

	    var _xfindIndex = function () {
	        function XFindIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.found = false;
	        }
	        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindIndex.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, -1);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	            }
	            return result;
	        };
	        return _curry2(function _xfindIndex(f, xf) {
	            return new XFindIndex(f, xf);
	        });
	    }();

	    var _xfindLast = function () {
	        function XFindLast(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLast.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
	        };
	        XFindLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.last = input;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLast(f, xf) {
	            return new XFindLast(f, xf);
	        });
	    }();

	    var _xfindLastIndex = function () {
	        function XFindLastIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.lastIdx = -1;
	        }
	        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
	        };
	        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.lastIdx = this.idx;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLastIndex(f, xf) {
	            return new XFindLastIndex(f, xf);
	        });
	    }();

	    var _xmap = function () {
	        function XMap(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XMap.prototype['@@transducer/init'] = _xfBase.init;
	        XMap.prototype['@@transducer/result'] = _xfBase.result;
	        XMap.prototype['@@transducer/step'] = function (result, input) {
	            return this.xf['@@transducer/step'](result, this.f(input));
	        };
	        return _curry2(function _xmap(f, xf) {
	            return new XMap(f, xf);
	        });
	    }();

	    var _xtake = function () {
	        function XTake(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XTake.prototype['@@transducer/init'] = _xfBase.init;
	        XTake.prototype['@@transducer/result'] = _xfBase.result;
	        XTake.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n === 0) {
	                return _reduced(result);
	            } else {
	                this.n -= 1;
	                return this.xf['@@transducer/step'](result, input);
	            }
	        };
	        return _curry2(function _xtake(n, xf) {
	            return new XTake(n, xf);
	        });
	    }();

	    var _xtakeWhile = function () {
	        function XTakeWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
	        };
	        return _curry2(function _xtakeWhile(f, xf) {
	            return new XTakeWhile(f, xf);
	        });
	    }();

	    /**
	     * Adds two numbers. Equivalent to `a + b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Number}
	     * @see R.subtract
	     * @example
	     *
	     *      R.add(2, 3);       //=>  5
	     *      R.add(7)(10);      //=> 17
	     */
	    var add = _curry2(function add(a, b) {
	        return a + b;
	    });

	    /**
	     * Applies a function to the value at the given index of an array, returning a
	     * new copy of the array with the element at the given index replaced with the
	     * result of the function application.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig (a -> a) -> Number -> [a] -> [a]
	     * @param {Function} fn The function to apply.
	     * @param {Number} idx The index.
	     * @param {Array|Arguments} list An array-like object whose value
	     *        at the supplied index will be replaced.
	     * @return {Array} A copy of the supplied array-like object with
	     *         the element at index `idx` replaced with the value
	     *         returned by applying `fn` to the existing element.
	     * @see R.update
	     * @example
	     *
	     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var adjust = _curry3(function adjust(fn, idx, list) {
	        if (idx >= list.length || idx < -list.length) {
	            return list;
	        }
	        var start = idx < 0 ? list.length : 0;
	        var _idx = start + idx;
	        var _list = _concat(list);
	        _list[_idx] = fn(list[_idx]);
	        return _list;
	    });

	    /**
	     * Returns `true` if all elements of the list match the predicate, `false` if
	     * there are any that don't.
	     *
	     * Dispatches to the `all` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	     *         otherwise.
	     * @see R.any, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      var lessThan3 = R.flip(R.lt)(3);
	     *      R.all(lessThan2)([1, 2]); //=> false
	     *      R.all(lessThan3)([1, 2]); //=> true
	     */
	    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (!fn(list[idx])) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    }));

	    /**
	     * Returns a function that always returns the given value. Note that for
	     * non-primitives the value returned is a reference to the original value.
	     *
	     * This function is known as `const`, `constant`, or `K` (for K combinator) in
	     * other languages and libraries.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig a -> (* -> a)
	     * @param {*} val The value to wrap in a function
	     * @return {Function} A Function :: * -> val.
	     * @example
	     *
	     *      var t = R.always('Tee');
	     *      t(); //=> 'Tee'
	     */
	    var always = _curry1(function always(val) {
	        return function () {
	            return val;
	        };
	    });

	    /**
	     * Returns `true` if both arguments are `true`; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {Boolean} a A boolean value
	     * @param {Boolean} b A boolean value
	     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
	     * @see R.both
	     * @example
	     *
	     *      R.and(true, true); //=> true
	     *      R.and(true, false); //=> false
	     *      R.and(false, true); //=> false
	     *      R.and(false, false); //=> false
	     */
	    var and = _curry2(function and(a, b) {
	        return a && b;
	    });

	    /**
	     * Returns `true` if at least one of elements of the list match the predicate,
	     * `false` otherwise.
	     *
	     * Dispatches to the `any` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
	     *         otherwise.
	     * @see R.all, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan0 = R.flip(R.lt)(0);
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      R.any(lessThan0)([1, 2]); //=> false
	     *      R.any(lessThan2)([1, 2]); //=> true
	     */
	    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (fn(list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    }));

	    /**
	     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
	     * greater than the length of the list, an empty list is returned.
	     *
	     * Dispatches to the `aperture` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @param {Number} n The size of the tuples to create
	     * @param {Array} list The list to split into `n`-tuples
	     * @return {Array} The new list.
	     * @see R.transduce
	     * @example
	     *
	     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
	     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
	     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
	     */
	    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

	    /**
	     * Returns a new list containing the contents of the given list, followed by
	     * the given element.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The element to add to the end of the new list.
	     * @param {Array} list The list whose contents will be added to the beginning of the output
	     *        list.
	     * @return {Array} A new list containing the contents of the old list followed by `el`.
	     * @see R.prepend
	     * @example
	     *
	     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
	     *      R.append('tests', []); //=> ['tests']
	     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
	     */
	    var append = _curry2(function append(el, list) {
	        return _concat(list, [el]);
	    });

	    /**
	     * Applies function `fn` to the argument list `args`. This is useful for
	     * creating a fixed-arity function from a variadic function. `fn` should be a
	     * bound function if context is significant.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig (*... -> a) -> [*] -> a
	     * @param {Function} fn
	     * @param {Array} args
	     * @return {*}
	     * @see R.call, R.unapply
	     * @example
	     *
	     *      var nums = [1, 2, 3, -99, 42, 6, 7];
	     *      R.apply(Math.max, nums); //=> 42
	     */
	    var apply = _curry2(function apply(fn, args) {
	        return fn.apply(this, args);
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the specified
	     * property with the given value. Note that this copies and flattens prototype
	     * properties onto the new object as well. All non-primitive properties are
	     * copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig String -> a -> {k: v} -> {k: v}
	     * @param {String} prop the property name to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except for the specified property.
	     * @see R.dissoc
	     * @example
	     *
	     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
	     */
	    var assoc = _curry3(function assoc(prop, val, obj) {
	        var result = {};
	        for (var p in obj) {
	            result[p] = obj[p];
	        }
	        result[prop] = val;
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the nodes required
	     * to create the given path, and placing the specific value at the tail end of
	     * that path. Note that this copies and flattens prototype properties onto the
	     * new object as well. All non-primitive properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig [String] -> a -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except along the specified path.
	     * @see R.dissocPath
	     * @example
	     *
	     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
	     */
	    var assocPath = _curry3(function assocPath(path, val, obj) {
	        switch (path.length) {
	        case 0:
	            return val;
	        case 1:
	            return assoc(path[0], val, obj);
	        default:
	            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
	        }
	    });

	    /**
	     * Creates a function that is bound to a context.
	     * Note: `R.bind` does not provide the additional argument-binding capabilities of
	     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @category Object
	     * @sig (* -> *) -> {*} -> (* -> *)
	     * @param {Function} fn The function to bind to context
	     * @param {Object} thisObj The context to bind `fn` to
	     * @return {Function} A function that will execute in the context of `thisObj`.
	     * @see R.partial
	     */
	    var bind = _curry2(function bind(fn, thisObj) {
	        return _arity(fn.length, function () {
	            return fn.apply(thisObj, arguments);
	        });
	    });

	    /**
	     * A function wrapping calls to the two functions in an `&&` operation,
	     * returning the result of the first function if it is false-y and the result
	     * of the second function otherwise. Note that this is short-circuited,
	     * meaning that the second function will not be invoked if the first returns a
	     * false-y value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
	     * @see R.and
	     * @example
	     *
	     *      var gt10 = x => x > 10;
	     *      var even = x => x % 2 === 0;
	     *      var f = R.both(gt10, even);
	     *      f(100); //=> true
	     *      f(101); //=> false
	     */
	    var both = _curry2(function both(f, g) {
	        return function _both() {
	            return f.apply(this, arguments) && g.apply(this, arguments);
	        };
	    });

	    /**
	     * Makes a comparator function out of a function that reports whether the first
	     * element is less than the second.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a, b -> Boolean) -> (a, b -> Number)
	     * @param {Function} pred A predicate function of arity two.
	     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
	     * @example
	     *
	     *      var cmp = R.comparator((a, b) => a.age < b.age);
	     *      var people = [
	     *        // ...
	     *      ];
	     *      R.sort(cmp, people);
	     */
	    var comparator = _curry1(function comparator(pred) {
	        return function (a, b) {
	            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
	        };
	    });

	    /**
	     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
	     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
	     * to `fn` are applied to each of the predicates in turn until one returns a
	     * "truthy" value, at which point `fn` returns the result of applying its
	     * arguments to the corresponding transformer. If none of the predicates
	     * matches, `fn` returns undefined.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Logic
	     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
	     * @param {Array} pairs
	     * @return {Function}
	     * @example
	     *
	     *      var fn = R.cond([
	     *        [R.equals(0),   R.always('water freezes at 0°C')],
	     *        [R.equals(100), R.always('water boils at 100°C')],
	     *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
	     *      ]);
	     *      fn(0); //=> 'water freezes at 0°C'
	     *      fn(50); //=> 'nothing special happens at 50°C'
	     *      fn(100); //=> 'water boils at 100°C'
	     */
	    var cond = _curry1(function cond(pairs) {
	        return function () {
	            var idx = 0;
	            while (idx < pairs.length) {
	                if (pairs[idx][0].apply(this, arguments)) {
	                    return pairs[idx][1].apply(this, arguments);
	                }
	                idx += 1;
	            }
	        };
	    });

	    /**
	     * Counts the elements of a list according to how many match each value of a
	     * key generated by the supplied function. Returns an object mapping the keys
	     * produced by `fn` to the number of occurrences in the list. Note that all
	     * keys are coerced to strings because of how JavaScript objects work.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> String) -> [a] -> {*}
	     * @param {Function} fn The function used to map values to keys.
	     * @param {Array} list The list to count elements from.
	     * @return {Object} An object mapping keys to number of occurrences in the list.
	     * @example
	     *
	     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
	     *      var letters = R.split('', 'abcABCaaaBBc');
	     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
	     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
	     */
	    var countBy = _curry2(function countBy(fn, list) {
	        var counts = {};
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            var key = fn(list[idx]);
	            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
	            idx += 1;
	        }
	        return counts;
	    });

	    /**
	     * Returns a curried equivalent of the provided function, with the specified
	     * arity. The curried function has two unusual capabilities. First, its
	     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curry
	     * @example
	     *
	     *      var sumArgs = (...args) => R.sum(args);
	     *
	     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curryN = _curry2(function curryN(length, fn) {
	        if (length === 1) {
	            return _curry1(fn);
	        }
	        return _arity(length, _curryN(length, [], fn));
	    });

	    /**
	     * Decrements its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.inc
	     * @example
	     *
	     *      R.dec(42); //=> 41
	     */
	    var dec = add(-1);

	    /**
	     * Returns the second argument if it is not `null`, `undefined` or `NaN`
	     * otherwise the first argument is returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Logic
	     * @sig a -> b -> a | b
	     * @param {a} val The default value.
	     * @param {b} val The value to return if it is not null or undefined
	     * @return {*} The the second value or the default value
	     * @example
	     *
	     *      var defaultTo42 = R.defaultTo(42);
	     *
	     *      defaultTo42(null);  //=> 42
	     *      defaultTo42(undefined);  //=> 42
	     *      defaultTo42('Ramda');  //=> 'Ramda'
	     *      defaultTo42(parseInt('string')); //=> 42
	     */
	    var defaultTo = _curry2(function defaultTo(d, v) {
	        return v == null || v !== v ? d : v;
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not
	     * contained in the second list. Duplication is determined according to the
	     * value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.difference
	     * @example
	     *
	     *      function cmp(x, y) => x.a === y.a;
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
	     *      var l2 = [{a: 3}, {a: 4}];
	     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
	     */
	    var differenceWith = _curry3(function differenceWith(pred, first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
	                out.push(first[idx]);
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object that does not contain a `prop` property.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Object
	     * @sig String -> {k: v} -> {k: v}
	     * @param {String} prop the name of the property to dissociate
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original but without the specified property
	     * @see R.assoc
	     * @example
	     *
	     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
	     */
	    var dissoc = _curry2(function dissoc(prop, obj) {
	        var result = {};
	        for (var p in obj) {
	            if (p !== prop) {
	                result[p] = obj[p];
	            }
	        }
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, omitting the property at the given path.
	     * Note that this copies and flattens prototype properties onto the new object
	     * as well. All non-primitive properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.11.0
	     * @category Object
	     * @sig [String] -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object without the property at path
	     * @see R.assocPath
	     * @example
	     *
	     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
	     */
	    var dissocPath = _curry2(function dissocPath(path, obj) {
	        switch (path.length) {
	        case 0:
	            return obj;
	        case 1:
	            return dissoc(path[0], obj);
	        default:
	            var head = path[0];
	            var tail = _slice(path, 1);
	            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
	        }
	    });

	    /**
	     * Divides two numbers. Equivalent to `a / b`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a / b`.
	     * @see R.multiply
	     * @example
	     *
	     *      R.divide(71, 100); //=> 0.71
	     *
	     *      var half = R.divide(R.__, 2);
	     *      half(42); //=> 21
	     *
	     *      var reciprocal = R.divide(1);
	     *      reciprocal(4);   //=> 0.25
	     */
	    var divide = _curry2(function divide(a, b) {
	        return a / b;
	    });

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing
	     * each value to the supplied predicate function, skipping elements while the
	     * predicate function returns `true`. The predicate function is passed one
	     * argument: *(value)*.
	     *
	     * Dispatches to the `dropWhile` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeWhile, R.transduce, R.addIndex
	     * @example
	     *
	     *      var lteTwo = x => x <= 2;
	     *
	     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
	     */
	    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len && pred(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, idx);
	    }));

	    /**
	     * A function wrapping calls to the two functions in an `||` operation,
	     * returning the result of the first function if it is truth-y and the result
	     * of the second function otherwise. Note that this is short-circuited,
	     * meaning that the second function will not be invoked if the first returns a
	     * truth-y value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
	     * @see R.or
	     * @example
	     *
	     *      var gt10 = x => x > 10;
	     *      var even = x => x % 2 === 0;
	     *      var f = R.either(gt10, even);
	     *      f(101); //=> true
	     *      f(8); //=> true
	     */
	    var either = _curry2(function either(f, g) {
	        return function _either() {
	            return f.apply(this, arguments) || g.apply(this, arguments);
	        };
	    });

	    /**
	     * Returns the empty value of its argument's type. Ramda defines the empty
	     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
	     * types are supported if they define `<Type>.empty` and/or
	     * `<Type>.prototype.empty`.
	     *
	     * Dispatches to the `empty` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig a -> a
	     * @param {*} x
	     * @return {*}
	     * @example
	     *
	     *      R.empty(Just(42));      //=> Nothing()
	     *      R.empty([1, 2, 3]);     //=> []
	     *      R.empty('unicorns');    //=> ''
	     *      R.empty({x: 1, y: 2});  //=> {}
	     */
	    // else
	    var empty = _curry1(function empty(x) {
	        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
	            return arguments;
	        }() : // else
	        void 0;
	    });

	    /**
	     * Creates a new object by recursively evolving a shallow copy of `object`,
	     * according to the `transformation` functions. All non-primitive properties
	     * are copied by reference.
	     *
	     * A `transformation` function will not be invoked if its corresponding key
	     * does not exist in the evolved object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
	     * @param {Object} transformations The object specifying transformation functions to apply
	     *        to the object.
	     * @param {Object} object The object to be transformed.
	     * @return {Object} The transformed object.
	     * @example
	     *
	     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
	     *      var transformations = {
	     *        firstName: R.trim,
	     *        lastName: R.trim, // Will not get invoked.
	     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
	     *      };
	     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
	     */
	    var evolve = _curry2(function evolve(transformations, object) {
	        var result = {};
	        var transformation, key, type;
	        for (key in object) {
	            transformation = transformations[key];
	            type = typeof transformation;
	            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
	        }
	        return result;
	    });

	    /**
	     * Returns the first element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `find` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     *        desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	     *      R.find(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx += 1;
	        }
	    }));

	    /**
	     * Returns the index of the first element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    }));

	    /**
	     * Returns the last element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `findLast` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
	     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx -= 1;
	        }
	    }));

	    /**
	     * Returns the index of the last element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findLastIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
	     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx -= 1;
	        }
	        return -1;
	    }));

	    /**
	     * Iterate over an input `list`, calling a provided function `fn` for each
	     * element in the list.
	     *
	     * `fn` receives one argument: *(value)*.
	     *
	     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.forEach` method. For more
	     * details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	     *
	     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
	     * the original array. In some libraries this function is named `each`.
	     *
	     * Dispatches to the `forEach` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> *) -> [a] -> [a]
	     * @param {Function} fn The function to invoke. Receives one argument, `value`.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} The original list.
	     * @see R.addIndex
	     * @example
	     *
	     *      var printXPlusFive = x => console.log(x + 5);
	     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	     *      //-> 6
	     *      //-> 7
	     *      //-> 8
	     */
	    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            fn(list[idx]);
	            idx += 1;
	        }
	        return list;
	    }));

	    /**
	     * Creates a new object out of a list key-value pairs.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [[k,v]] -> {k: v}
	     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
	     * @return {Object} The object made by pairing up `keys` and `values`.
	     * @see R.toPairs, R.pair
	     * @example
	     *
	     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
	     */
	    var fromPairs = _curry1(function fromPairs(pairs) {
	        var idx = 0;
	        var len = pairs.length;
	        var out = {};
	        while (idx < len) {
	            if (_isArray(pairs[idx]) && pairs[idx].length) {
	                out[pairs[idx][0]] = pairs[idx][1];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns `true` if the first argument is greater than the second; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.lt
	     * @example
	     *
	     *      R.gt(2, 1); //=> true
	     *      R.gt(2, 2); //=> false
	     *      R.gt(2, 3); //=> false
	     *      R.gt('a', 'z'); //=> false
	     *      R.gt('z', 'a'); //=> true
	     */
	    var gt = _curry2(function gt(a, b) {
	        return a > b;
	    });

	    /**
	     * Returns `true` if the first argument is greater than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.lte
	     * @example
	     *
	     *      R.gte(2, 1); //=> true
	     *      R.gte(2, 2); //=> true
	     *      R.gte(2, 3); //=> false
	     *      R.gte('a', 'z'); //=> false
	     *      R.gte('z', 'a'); //=> true
	     */
	    var gte = _curry2(function gte(a, b) {
	        return a >= b;
	    });

	    /**
	     * Returns whether or not an object has an own property with the specified name
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      var hasName = R.has('name');
	     *      hasName({name: 'alice'});   //=> true
	     *      hasName({name: 'bob'});     //=> true
	     *      hasName({});                //=> false
	     *
	     *      var point = {x: 0, y: 0};
	     *      var pointHas = R.has(R.__, point);
	     *      pointHas('x');  //=> true
	     *      pointHas('y');  //=> true
	     *      pointHas('z');  //=> false
	     */
	    var has = _curry2(_has);

	    /**
	     * Returns whether or not an object or its prototype chain has a property with
	     * the specified name
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      function Rectangle(width, height) {
	     *        this.width = width;
	     *        this.height = height;
	     *      }
	     *      Rectangle.prototype.area = function() {
	     *        return this.width * this.height;
	     *      };
	     *
	     *      var square = new Rectangle(2, 2);
	     *      R.hasIn('width', square);  //=> true
	     *      R.hasIn('area', square);  //=> true
	     */
	    var hasIn = _curry2(function hasIn(prop, obj) {
	        return prop in obj;
	    });

	    /**
	     * Returns true if its arguments are identical, false otherwise. Values are
	     * identical if they reference the same memory. `NaN` is identical to `NaN`;
	     * `0` and `-0` are not identical.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      var o = {};
	     *      R.identical(o, o); //=> true
	     *      R.identical(1, 1); //=> true
	     *      R.identical(1, '1'); //=> false
	     *      R.identical([], []); //=> false
	     *      R.identical(0, -0); //=> false
	     *      R.identical(NaN, NaN); //=> true
	     */
	    // SameValue algorithm
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Step 6.a: NaN == NaN
	    var identical = _curry2(function identical(a, b) {
	        // SameValue algorithm
	        if (a === b) {
	            // Steps 1-5, 7-10
	            // Steps 6.b-6.e: +0 != -0
	            return a !== 0 || 1 / a === 1 / b;
	        } else {
	            // Step 6.a: NaN == NaN
	            return a !== a && b !== b;
	        }
	    });

	    /**
	     * A function that does nothing but return the parameter supplied to it. Good
	     * as a default or placeholder function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig a -> a
	     * @param {*} x The value to return.
	     * @return {*} The input value, `x`.
	     * @example
	     *
	     *      R.identity(1); //=> 1
	     *
	     *      var obj = {};
	     *      R.identity(obj) === obj; //=> true
	     */
	    var identity = _curry1(_identity);

	    /**
	     * Creates a function that will process either the `onTrue` or the `onFalse`
	     * function depending upon the result of the `condition` predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
	     * @param {Function} condition A predicate function
	     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
	     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
	     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
	     *                    function depending upon the result of the `condition` predicate.
	     * @see R.unless, R.when
	     * @example
	     *
	     *      var incCount = R.ifElse(
	     *        R.has('count'),
	     *        R.over(R.lensProp('count'), R.inc),
	     *        R.assoc('count', 1)
	     *      );
	     *      incCount({});           //=> { count: 1 }
	     *      incCount({ count: 1 }); //=> { count: 2 }
	     */
	    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
	        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
	            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
	        });
	    });

	    /**
	     * Increments its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.dec
	     * @example
	     *
	     *      R.inc(42); //=> 43
	     */
	    var inc = add(1);

	    /**
	     * Inserts the supplied element into the list, at index `index`. _Note that
	     * this is not destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.2
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} index The position to insert the element
	     * @param {*} elt The element to insert into the Array
	     * @param {Array} list The list to insert into
	     * @return {Array} A new Array with `elt` inserted at `index`.
	     * @example
	     *
	     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
	     */
	    var insert = _curry3(function insert(idx, elt, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        var result = _slice(list);
	        result.splice(idx, 0, elt);
	        return result;
	    });

	    /**
	     * Inserts the sub-list into the list, at index `index`. _Note that this is not
	     * destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig Number -> [a] -> [a] -> [a]
	     * @param {Number} index The position to insert the sub-list
	     * @param {Array} elts The sub-list to insert into the Array
	     * @param {Array} list The list to insert the sub-list into
	     * @return {Array} A new Array with `elts` inserted starting at `index`.
	     * @example
	     *
	     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
	     */
	    var insertAll = _curry3(function insertAll(idx, elts, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
	    });

	    /**
	     * Creates a new list with the separator interposed between elements.
	     *
	     * Dispatches to the `intersperse` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} separator The element to add to the list.
	     * @param {Array} list The list to be interposed.
	     * @return {Array} The new list.
	     * @example
	     *
	     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
	     */
	    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
	        var out = [];
	        var idx = 0;
	        var length = list.length;
	        while (idx < length) {
	            if (idx === length - 1) {
	                out.push(list[idx]);
	            } else {
	                out.push(list[idx], separator);
	            }
	            idx += 1;
	        }
	        return out;
	    }));

	    /**
	     * See if an object (`val`) is an instance of the supplied constructor. This
	     * function will check up the inheritance chain, if any.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Type
	     * @sig (* -> {*}) -> a -> Boolean
	     * @param {Object} ctor A constructor
	     * @param {*} val The value to test
	     * @return {Boolean}
	     * @example
	     *
	     *      R.is(Object, {}); //=> true
	     *      R.is(Number, 1); //=> true
	     *      R.is(Object, 1); //=> false
	     *      R.is(String, 's'); //=> true
	     *      R.is(String, new String('')); //=> true
	     *      R.is(Object, new String('')); //=> true
	     *      R.is(Object, 's'); //=> false
	     *      R.is(Number, {}); //=> false
	     */
	    var is = _curry2(function is(Ctor, val) {
	        return val != null && val.constructor === Ctor || val instanceof Ctor;
	    });

	    /**
	     * Tests whether or not an object is similar to an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Type
	     * @category List
	     * @sig * -> Boolean
	     * @param {*} x The object to test.
	     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	     * @example
	     *
	     *      R.isArrayLike([]); //=> true
	     *      R.isArrayLike(true); //=> false
	     *      R.isArrayLike({}); //=> false
	     *      R.isArrayLike({length: 10}); //=> false
	     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	     */
	    var isArrayLike = _curry1(function isArrayLike(x) {
	        if (_isArray(x)) {
	            return true;
	        }
	        if (!x) {
	            return false;
	        }
	        if (typeof x !== 'object') {
	            return false;
	        }
	        if (x instanceof String) {
	            return false;
	        }
	        if (x.nodeType === 1) {
	            return !!x.length;
	        }
	        if (x.length === 0) {
	            return true;
	        }
	        if (x.length > 0) {
	            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	        }
	        return false;
	    });

	    /**
	     * Checks if the input value is `null` or `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Type
	     * @sig * -> Boolean
	     * @param {*} x The value to test.
	     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
	     * @example
	     *
	     *      R.isNil(null); //=> true
	     *      R.isNil(undefined); //=> true
	     *      R.isNil(0); //=> false
	     *      R.isNil([]); //=> false
	     */
	    var isNil = _curry1(function isNil(x) {
	        return x == null;
	    });

	    /**
	     * Returns a list containing the names of all the enumerable own properties of
	     * the supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own properties.
	     * @example
	     *
	     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	     */
	    // cover IE < 9 keys issues
	    // Safari bug
	    var keys = function () {
	        // cover IE < 9 keys issues
	        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	        var nonEnumerableProps = [
	            'constructor',
	            'valueOf',
	            'isPrototypeOf',
	            'toString',
	            'propertyIsEnumerable',
	            'hasOwnProperty',
	            'toLocaleString'
	        ];
	        // Safari bug
	        var hasArgsEnumBug = function () {
	            'use strict';
	            return arguments.propertyIsEnumerable('length');
	        }();
	        var contains = function contains(list, item) {
	            var idx = 0;
	            while (idx < list.length) {
	                if (list[idx] === item) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        };
	        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
	            return Object(obj) !== obj ? [] : Object.keys(obj);
	        }) : _curry1(function keys(obj) {
	            if (Object(obj) !== obj) {
	                return [];
	            }
	            var prop, nIdx;
	            var ks = [];
	            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
	            for (prop in obj) {
	                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
	                    ks[ks.length] = prop;
	                }
	            }
	            if (hasEnumBug) {
	                nIdx = nonEnumerableProps.length - 1;
	                while (nIdx >= 0) {
	                    prop = nonEnumerableProps[nIdx];
	                    if (_has(prop, obj) && !contains(ks, prop)) {
	                        ks[ks.length] = prop;
	                    }
	                    nIdx -= 1;
	                }
	            }
	            return ks;
	        });
	    }();

	    /**
	     * Returns a list containing the names of all the properties of the supplied
	     * object, including prototype properties.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.keysIn(f); //=> ['x', 'y']
	     */
	    var keysIn = _curry1(function keysIn(obj) {
	        var prop;
	        var ks = [];
	        for (prop in obj) {
	            ks[ks.length] = prop;
	        }
	        return ks;
	    });

	    /**
	     * Returns the number of elements in the array by returning `list.length`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [a] -> Number
	     * @param {Array} list The array to inspect.
	     * @return {Number} The length of the array.
	     * @example
	     *
	     *      R.length([]); //=> 0
	     *      R.length([1, 2, 3]); //=> 3
	     */
	    var length = _curry1(function length(list) {
	        return list != null && is(Number, list.length) ? list.length : NaN;
	    });

	    /**
	     * Returns `true` if the first argument is less than the second; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.gt
	     * @example
	     *
	     *      R.lt(2, 1); //=> false
	     *      R.lt(2, 2); //=> false
	     *      R.lt(2, 3); //=> true
	     *      R.lt('a', 'z'); //=> true
	     *      R.lt('z', 'a'); //=> false
	     */
	    var lt = _curry2(function lt(a, b) {
	        return a < b;
	    });

	    /**
	     * Returns `true` if the first argument is less than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.gte
	     * @example
	     *
	     *      R.lte(2, 1); //=> false
	     *      R.lte(2, 2); //=> true
	     *      R.lte(2, 3); //=> true
	     *      R.lte('a', 'z'); //=> true
	     *      R.lte('z', 'a'); //=> false
	     */
	    var lte = _curry2(function lte(a, b) {
	        return a <= b;
	    });

	    /**
	     * The mapAccum function behaves like a combination of map and reduce; it
	     * applies a function to each element of a list, passing an accumulating
	     * parameter from left to right, and returning a final value of this
	     * accumulator together with the new list.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should
	     * return a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = (a, b) => [a + b, a + b];
	     *
	     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
	     */
	    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        var tuple = [acc];
	        while (idx < len) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx += 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * The mapAccumRight function behaves like a combination of map and reduce; it
	     * applies a function to each element of a list, passing an accumulating
	     * parameter from right to left, and returning a final value of this
	     * accumulator together with the new list.
	     *
	     * Similar to `mapAccum`, except moves through the input list from the right to
	     * the left.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should
	     * return a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = (a, b) => [a + b, a + b];
	     *
	     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
	     */
	    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
	        var idx = list.length - 1;
	        var result = [];
	        var tuple = [acc];
	        while (idx >= 0) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx -= 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * Tests a regular expression against a String. Note that this function will
	     * return an empty array when there are no matches. This differs from
	     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
	     * which returns `null` when there are no matches.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category String
	     * @sig RegExp -> String -> [String | Undefined]
	     * @param {RegExp} rx A regular expression.
	     * @param {String} str The string to match against
	     * @return {Array} The list of matches or empty array.
	     * @see R.test
	     * @example
	     *
	     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
	     *      R.match(/a/, 'b'); //=> []
	     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
	     */
	    var match = _curry2(function match(rx, str) {
	        return str.match(rx) || [];
	    });

	    /**
	     * mathMod behaves like the modulo operator should mathematically, unlike the
	     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
	     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
	     * when the modulus is zero or negative.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} m The dividend.
	     * @param {Number} p the modulus.
	     * @return {Number} The result of `b mod a`.
	     * @example
	     *
	     *      R.mathMod(-17, 5);  //=> 3
	     *      R.mathMod(17, 5);   //=> 2
	     *      R.mathMod(17, -5);  //=> NaN
	     *      R.mathMod(17, 0);   //=> NaN
	     *      R.mathMod(17.2, 5); //=> NaN
	     *      R.mathMod(17, 5.3); //=> NaN
	     *
	     *      var clock = R.mathMod(R.__, 12);
	     *      clock(15); //=> 3
	     *      clock(24); //=> 0
	     *
	     *      var seventeenMod = R.mathMod(17);
	     *      seventeenMod(3);  //=> 2
	     *      seventeenMod(4);  //=> 1
	     *      seventeenMod(10); //=> 7
	     */
	    var mathMod = _curry2(function mathMod(m, p) {
	        if (!_isInteger(m)) {
	            return NaN;
	        }
	        if (!_isInteger(p) || p < 1) {
	            return NaN;
	        }
	        return (m % p + p) % p;
	    });

	    /**
	     * Returns the larger of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.maxBy, R.min
	     * @example
	     *
	     *      R.max(789, 123); //=> 789
	     *      R.max('a', 'b'); //=> 'b'
	     */
	    var max = _curry2(function max(a, b) {
	        return b > a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces the
	     * larger result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.max, R.minBy
	     * @example
	     *
	     *      //  square :: Number -> Number
	     *      var square = n => n * n;
	     *
	     *      R.maxBy(square, -3, 2); //=> -3
	     *
	     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
	     *      R.reduce(R.maxBy(square), 0, []); //=> 0
	     */
	    var maxBy = _curry3(function maxBy(f, a, b) {
	        return f(b) > f(a) ? b : a;
	    });

	    /**
	     * Creates a new object with the own properties of the two provided objects. If
	     * a key exists in both objects, the provided function is applied to the key
	     * and the values associated with the key in each object, with the result being
	     * used as the value associated with the key in the returned object. The key
	     * will be excluded from the returned object if the resulting value is
	     * `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Object
	     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
	     * @param {Function} fn
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.merge, R.mergeWith
	     * @example
	     *
	     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
	     *      R.mergeWithKey(concatValues,
	     *                     { a: true, thing: 'foo', values: [10, 20] },
	     *                     { b: true, thing: 'bar', values: [15, 35] });
	     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
	     */
	    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
	        var result = {};
	        var k;
	        for (k in l) {
	            if (_has(k, l)) {
	                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
	            }
	        }
	        for (k in r) {
	            if (_has(k, r) && !_has(k, result)) {
	                result[k] = r[k];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the smaller of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.minBy, R.max
	     * @example
	     *
	     *      R.min(789, 123); //=> 123
	     *      R.min('a', 'b'); //=> 'a'
	     */
	    var min = _curry2(function min(a, b) {
	        return b < a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces the
	     * smaller result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.min, R.maxBy
	     * @example
	     *
	     *      //  square :: Number -> Number
	     *      var square = n => n * n;
	     *
	     *      R.minBy(square, -3, 2); //=> 2
	     *
	     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
	     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
	     */
	    var minBy = _curry3(function minBy(f, a, b) {
	        return f(b) < f(a) ? b : a;
	    });

	    /**
	     * Divides the second parameter by the first and returns the remainder. Note
	     * that this function preserves the JavaScript-style behavior for modulo. For
	     * mathematical modulo see `mathMod`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The value to the divide.
	     * @param {Number} b The pseudo-modulus
	     * @return {Number} The result of `b % a`.
	     * @see R.mathMod
	     * @example
	     *
	     *      R.modulo(17, 3); //=> 2
	     *      // JS behavior:
	     *      R.modulo(-17, 3); //=> -2
	     *      R.modulo(17, -3); //=> 2
	     *
	     *      var isOdd = R.modulo(R.__, 2);
	     *      isOdd(42); //=> 0
	     *      isOdd(21); //=> 1
	     */
	    var modulo = _curry2(function modulo(a, b) {
	        return a % b;
	    });

	    /**
	     * Multiplies two numbers. Equivalent to `a * b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a * b`.
	     * @see R.divide
	     * @example
	     *
	     *      var double = R.multiply(2);
	     *      var triple = R.multiply(3);
	     *      double(3);       //=>  6
	     *      triple(4);       //=> 12
	     *      R.multiply(2, 5);  //=> 10
	     */
	    var multiply = _curry2(function multiply(a, b) {
	        return a * b;
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly `n` parameters. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} n The desired arity of the new function.
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity `n`.
	     * @example
	     *
	     *      var takesTwoArgs = (a, b) => [a, b];
	     *
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.nAry(1, takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only `n` arguments are passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var nAry = _curry2(function nAry(n, fn) {
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.call(this);
	            };
	        case 1:
	            return function (a0) {
	                return fn.call(this, a0);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.call(this, a0, a1);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.call(this, a0, a1, a2);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.call(this, a0, a1, a2, a3);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.call(this, a0, a1, a2, a3, a4);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	            };
	        default:
	            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
	        }
	    });

	    /**
	     * Negates its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @example
	     *
	     *      R.negate(42); //=> -42
	     */
	    var negate = _curry1(function negate(n) {
	        return -n;
	    });

	    /**
	     * Returns `true` if no elements of the list match the predicate, `false`
	     * otherwise.
	     *
	     * Dispatches to the `any` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
	     * @see R.all, R.any
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
	     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
	     */
	    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

	    /**
	     * A function that returns the `!` of its argument. It will return `true` when
	     * passed false-y value, and `false` when passed a truth-y one.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> Boolean
	     * @param {*} a any value
	     * @return {Boolean} the logical inverse of passed argument.
	     * @see R.complement
	     * @example
	     *
	     *      R.not(true); //=> false
	     *      R.not(false); //=> true
	     *      R.not(0); => true
	     *      R.not(1); => false
	     */
	    var not = _curry1(function not(a) {
	        return !a;
	    });

	    /**
	     * Returns the nth element of the given list or string. If n is negative the
	     * element at index length + n is returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> a | Undefined
	     * @sig Number -> String -> String
	     * @param {Number} offset
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      var list = ['foo', 'bar', 'baz', 'quux'];
	     *      R.nth(1, list); //=> 'bar'
	     *      R.nth(-1, list); //=> 'quux'
	     *      R.nth(-99, list); //=> undefined
	     *
	     *      R.nth('abc', 2); //=> 'c'
	     *      R.nth('abc', 3); //=> ''
	     */
	    var nth = _curry2(function nth(offset, list) {
	        var idx = offset < 0 ? list.length + offset : offset;
	        return _isString(list) ? list.charAt(idx) : list[idx];
	    });

	    /**
	     * Returns a function which returns its nth argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig Number -> *... -> *
	     * @param {Number} n
	     * @return {Function}
	     * @example
	     *
	     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
	     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
	     */
	    var nthArg = _curry1(function nthArg(n) {
	        return function () {
	            return nth(n, arguments);
	        };
	    });

	    /**
	     * Creates an object containing a single key:value pair.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Object
	     * @sig String -> a -> {String:a}
	     * @param {String} key
	     * @param {*} val
	     * @return {Object}
	     * @see R.pair
	     * @example
	     *
	     *      var matchPhrases = R.compose(
	     *        R.objOf('must'),
	     *        R.map(R.objOf('match_phrase'))
	     *      );
	     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
	     */
	    var objOf = _curry2(function objOf(key, val) {
	        var obj = {};
	        obj[key] = val;
	        return obj;
	    });

	    /**
	     * Returns a singleton array containing the value provided.
	     *
	     * Note this `of` is different from the ES6 `of`; See
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig a -> [a]
	     * @param {*} x any value
	     * @return {Array} An array wrapping `x`.
	     * @example
	     *
	     *      R.of(null); //=> [null]
	     *      R.of([42]); //=> [[42]]
	     */
	    var of = _curry1(_of);

	    /**
	     * Accepts a function `fn` and returns a function that guards invocation of
	     * `fn` such that `fn` can only ever be called once, no matter how many times
	     * the returned function is invoked. The first value calculated is returned in
	     * subsequent invocations.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a... -> b) -> (a... -> b)
	     * @param {Function} fn The function to wrap in a call-only-once wrapper.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var addOneOnce = R.once(x => x + 1);
	     *      addOneOnce(10); //=> 11
	     *      addOneOnce(addOneOnce(50)); //=> 11
	     */
	    var once = _curry1(function once(fn) {
	        var called = false;
	        var result;
	        return _arity(fn.length, function () {
	            if (called) {
	                return result;
	            }
	            called = true;
	            result = fn.apply(this, arguments);
	            return result;
	        });
	    });

	    /**
	     * Returns `true` if one or both of its arguments are `true`. Returns `false`
	     * if both arguments are `false`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {Boolean} a A boolean value
	     * @param {Boolean} b A boolean value
	     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
	     * @see R.either
	     * @example
	     *
	     *      R.or(true, true); //=> true
	     *      R.or(true, false); //=> true
	     *      R.or(false, true); //=> true
	     *      R.or(false, false); //=> false
	     */
	    var or = _curry2(function or(a, b) {
	        return a || b;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the result of applying the given function to
	     * the focused value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> (a -> a) -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
	     */
	    var over = function () {
	        var Identity = function (x) {
	            return {
	                value: x,
	                map: function (f) {
	                    return Identity(f(x));
	                }
	            };
	        };
	        return _curry3(function over(lens, f, x) {
	            return lens(function (y) {
	                return Identity(f(y));
	            })(x).value;
	        });
	    }();

	    /**
	     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category List
	     * @sig a -> b -> (a,b)
	     * @param {*} fst
	     * @param {*} snd
	     * @return {Array}
	     * @see R.createMapEntry, R.of
	     * @example
	     *
	     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
	     */
	    var pair = _curry2(function pair(fst, snd) {
	        return [
	            fst,
	            snd
	        ];
	    });

	    /**
	     * Retrieve the value at a given path.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig [String] -> {k: v} -> v | Undefined
	     * @param {Array} path The path to use.
	     * @param {Object} obj The object to retrieve the nested property from.
	     * @return {*} The data at `path`.
	     * @example
	     *
	     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
	     */
	    var path = _curry2(function path(paths, obj) {
	        var val = obj;
	        var idx = 0;
	        while (idx < paths.length) {
	            if (val == null) {
	                return;
	            }
	            val = val[paths[idx]];
	            idx += 1;
	        }
	        return val;
	    });

	    /**
	     * If the given, non-null object has a value at the given path, returns the
	     * value at that path. Otherwise returns the provided default value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Object
	     * @sig a -> [String] -> Object -> a
	     * @param {*} d The default value.
	     * @param {Array} p The path to use.
	     * @param {Object} obj The object to retrieve the nested property from.
	     * @return {*} The data at `path` of the supplied object or the default value.
	     * @example
	     *
	     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
	     */
	    var pathOr = _curry3(function pathOr(d, p, obj) {
	        return defaultTo(d, path(p, obj));
	    });

	    /**
	     * Returns `true` if the specified object property at given path satisfies the
	     * given predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Logic
	     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
	     * @param {Function} pred
	     * @param {Array} propPath
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propSatisfies, R.path
	     * @example
	     *
	     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
	     */
	    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
	        return propPath.length > 0 && pred(path(propPath, obj));
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys specified. If
	     * the key does not exist, the property is ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.omit, R.props
	     * @example
	     *
	     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	     */
	    var pick = _curry2(function pick(names, obj) {
	        var result = {};
	        var idx = 0;
	        while (idx < names.length) {
	            if (names[idx] in obj) {
	                result[names[idx]] = obj[names[idx]];
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Similar to `pick` except that this one includes a `key: undefined` pair for
	     * properties that don't exist.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
	     */
	    var pickAll = _curry2(function pickAll(names, obj) {
	        var result = {};
	        var idx = 0;
	        var len = names.length;
	        while (idx < len) {
	            var name = names[idx];
	            result[name] = obj[name];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys that satisfy
	     * the supplied predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
	     * @param {Function} pred A predicate to determine whether or not a key
	     *        should be included on the output object.
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties that satisfy `pred`
	     *         on it.
	     * @see R.pick, R.filter
	     * @example
	     *
	     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
	     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	     */
	    var pickBy = _curry2(function pickBy(test, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (test(obj[prop], prop, obj)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns a new list with the given element at the front, followed by the
	     * contents of the list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The item to add to the head of the output list.
	     * @param {Array} list The array to add to the tail of the output list.
	     * @return {Array} A new array.
	     * @see R.append
	     * @example
	     *
	     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
	     */
	    var prepend = _curry2(function prepend(el, list) {
	        return _concat([el], list);
	    });

	    /**
	     * Returns a function that when supplied an object returns the indicated
	     * property of that object, if it exists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig s -> {s: a} -> a | Undefined
	     * @param {String} p The property name
	     * @param {Object} obj The object to query
	     * @return {*} The value at `obj.p`.
	     * @example
	     *
	     *      R.prop('x', {x: 100}); //=> 100
	     *      R.prop('x', {}); //=> undefined
	     */
	    var prop = _curry2(function prop(p, obj) {
	        return obj[p];
	    });

	    /**
	     * If the given, non-null object has an own property with the specified name,
	     * returns the value of that property. Otherwise returns the provided default
	     * value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Object
	     * @sig a -> String -> Object -> a
	     * @param {*} val The default value.
	     * @param {String} p The name of the property to return.
	     * @param {Object} obj The object to query.
	     * @return {*} The value of given property of the supplied object or the default value.
	     * @example
	     *
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var favorite = R.prop('favoriteLibrary');
	     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
	     *
	     *      favorite(alice);  //=> undefined
	     *      favoriteWithDefault(alice);  //=> 'Ramda'
	     */
	    var propOr = _curry3(function propOr(val, p, obj) {
	        return obj != null && _has(p, obj) ? obj[p] : val;
	    });

	    /**
	     * Returns `true` if the specified object property satisfies the given
	     * predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Logic
	     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
	     * @param {Function} pred
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propEq, R.propIs
	     * @example
	     *
	     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
	     */
	    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
	        return pred(obj[name]);
	    });

	    /**
	     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> [v]
	     * @param {Array} ps The property names to fetch
	     * @param {Object} obj The object to query
	     * @return {Array} The corresponding values or partially applied function.
	     * @example
	     *
	     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	     *
	     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	     */
	    var props = _curry2(function props(ps, obj) {
	        var len = ps.length;
	        var out = [];
	        var idx = 0;
	        while (idx < len) {
	            out[idx] = obj[ps[idx]];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> Number -> [Number]
	     * @param {Number} from The first number in the list.
	     * @param {Number} to One more than the last number in the list.
	     * @return {Array} The list of numbers in tthe set `[a, b)`.
	     * @example
	     *
	     *      R.range(1, 5);    //=> [1, 2, 3, 4]
	     *      R.range(50, 53);  //=> [50, 51, 52]
	     */
	    var range = _curry2(function range(from, to) {
	        if (!(_isNumber(from) && _isNumber(to))) {
	            throw new TypeError('Both arguments to range must be numbers');
	        }
	        var result = [];
	        var n = from;
	        while (n < to) {
	            result.push(n);
	            n += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * Similar to `reduce`, except moves through the input list from the right to
	     * the left.
	     *
	     * The iterator function receives two values: *(acc, value)*
	     *
	     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
	     *      var flattenPairs = (acc, pair) => acc.concat(pair);
	     *
	     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
	     */
	    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            acc = fn(acc, list[idx]);
	            idx -= 1;
	        }
	        return acc;
	    });

	    /**
	     * Returns a value wrapped to indicate that it is the final value of the reduce
	     * and transduce functions. The returned value should be considered a black
	     * box: the internal structure is not guaranteed to be stable.
	     *
	     * Note: this optimization is unavailable to functions not explicitly listed
	     * above. For instance, it is not currently supported by reduceRight.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category List
	     * @sig a -> *
	     * @param {*} x The final value of the reduce.
	     * @return {*} The wrapped value.
	     * @see R.reduce, R.transduce
	     * @example
	     *
	     *      R.reduce(
	     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
	     *        0,
	     *        [1, 2, 3, 4, 5]) // 10
	     */
	    var reduced = _curry1(_reduced);

	    /**
	     * Removes the sub-list of `list` starting at index `start` and containing
	     * `count` elements. _Note that this is not destructive_: it returns a copy of
	     * the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.2
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @param {Number} start The position to start removing elements
	     * @param {Number} count The number of elements to remove
	     * @param {Array} list The list to remove from
	     * @return {Array} A new Array with `count` elements from `start` removed.
	     * @example
	     *
	     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
	     */
	    var remove = _curry3(function remove(start, count, list) {
	        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
	    });

	    /**
	     * Replace a substring or regex match in a string with a replacement.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category String
	     * @sig RegExp|String -> String -> String -> String
	     * @param {RegExp|String} pattern A regular expression or a substring to match.
	     * @param {String} replacement The string to replace the matches with.
	     * @param {String} str The String to do the search and replacement in.
	     * @return {String} The result.
	     * @example
	     *
	     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *
	     *      // Use the "g" (global) flag to replace all occurrences:
	     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
	     */
	    var replace = _curry3(function replace(regex, replacement, str) {
	        return str.replace(regex, replacement);
	    });

	    /**
	     * Returns a new list or string with the elements or characters in reverse
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {Array|String}
	     * @example
	     *
	     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	     *      R.reverse([1, 2]);     //=> [2, 1]
	     *      R.reverse([1]);        //=> [1]
	     *      R.reverse([]);         //=> []
	     *
	     *      R.reverse('abc');      //=> 'cba'
	     *      R.reverse('ab');       //=> 'ba'
	     *      R.reverse('a');        //=> 'a'
	     *      R.reverse('');         //=> ''
	     */
	    var reverse = _curry1(function reverse(list) {
	        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
	    });

	    /**
	     * Scan is similar to reduce, but returns a list of successively reduced values
	     * from the left
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> [a]
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} A list of all intermediately reduced values.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
	     */
	    var scan = _curry3(function scan(fn, acc, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [acc];
	        while (idx < len) {
	            acc = fn(acc, list[idx]);
	            result[idx + 1] = acc;
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the given value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> a -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
	     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
	     */
	    var set = _curry3(function set(lens, v, x) {
	        return over(lens, always(v), x);
	    });

	    /**
	     * Returns the elements of the given list or string (or object with a `slice`
	     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	     *
	     * Dispatches to the `slice` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @sig Number -> Number -> String -> String
	     * @param {Number} fromIndex The start index (inclusive).
	     * @param {Number} toIndex The end index (exclusive).
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	     */
	    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	        return Array.prototype.slice.call(list, fromIndex, toIndex);
	    }));

	    /**
	     * Returns a copy of the list, sorted according to the comparator function,
	     * which should accept two values at a time and return a negative number if the
	     * first value is smaller, a positive number if it's larger, and zero if they
	     * are equal. Please note that this is a **copy** of the list. It does not
	     * modify the original.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,a -> Number) -> [a] -> [a]
	     * @param {Function} comparator A sorting function :: a -> b -> Int
	     * @param {Array} list The list to sort
	     * @return {Array} a new array with its elements sorted by the comparator function.
	     * @example
	     *
	     *      var diff = function(a, b) { return a - b; };
	     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
	     */
	    var sort = _curry2(function sort(comparator, list) {
	        return _slice(list).sort(comparator);
	    });

	    /**
	     * Sorts the list according to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> [a] -> [a]
	     * @param {Function} fn
	     * @param {Array} list The list to sort.
	     * @return {Array} A new list sorted by the keys generated by `fn`.
	     * @example
	     *
	     *      var sortByFirstItem = R.sortBy(R.prop(0));
	     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
	     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
	     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var bob = {
	     *        name: 'Bob',
	     *        age: -10
	     *      };
	     *      var clara = {
	     *        name: 'clara',
	     *        age: 314.159
	     *      };
	     *      var people = [clara, bob, alice];
	     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
	     */
	    var sortBy = _curry2(function sortBy(fn, list) {
	        return _slice(list).sort(function (a, b) {
	            var aa = fn(a);
	            var bb = fn(b);
	            return aa < bb ? -1 : aa > bb ? 1 : 0;
	        });
	    });

	    /**
	     * Splits a given list or string at a given index.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig Number -> [a] -> [[a], [a]]
	     * @sig Number -> String -> [String, String]
	     * @param {Number} index The index where the array/string is split.
	     * @param {Array|String} array The array/string to be split.
	     * @return {Array}
	     * @example
	     *
	     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
	     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
	     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
	     */
	    var splitAt = _curry2(function splitAt(index, array) {
	        return [
	            slice(0, index, array),
	            slice(index, length(array), array)
	        ];
	    });

	    /**
	     * Splits a collection into slices of the specified length.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @sig Number -> String -> [String]
	     * @param {Number} n
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
	     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
	     */
	    var splitEvery = _curry2(function splitEvery(n, list) {
	        if (n <= 0) {
	            throw new Error('First argument to splitEvery must be a positive integer');
	        }
	        var result = [];
	        var idx = 0;
	        while (idx < list.length) {
	            result.push(slice(idx, idx += n, list));
	        }
	        return result;
	    });

	    /**
	     * Takes a list and a predicate and returns a pair of lists with the following properties:
	     *
	     *  - the result of concatenating the two output lists is equivalent to the input list;
	     *  - none of the elements of the first output list satisfies the predicate; and
	     *  - if the second output list is non-empty, its first element satisfies the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
	     * @param {Function} pred The predicate that determines where the array is split.
	     * @param {Array} list The array to be split.
	     * @return {Array}
	     * @example
	     *
	     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
	     */
	    var splitWhen = _curry2(function splitWhen(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        var prefix = [];
	        while (idx < len && !pred(list[idx])) {
	            prefix.push(list[idx]);
	            idx += 1;
	        }
	        return [
	            prefix,
	            _slice(list, idx)
	        ];
	    });

	    /**
	     * Subtracts two numbers. Equivalent to `a - b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a - b`.
	     * @see R.add
	     * @example
	     *
	     *      R.subtract(10, 8); //=> 2
	     *
	     *      var minus5 = R.subtract(R.__, 5);
	     *      minus5(17); //=> 12
	     *
	     *      var complementaryAngle = R.subtract(90);
	     *      complementaryAngle(30); //=> 60
	     *      complementaryAngle(72); //=> 18
	     */
	    var subtract = _curry2(function subtract(a, b) {
	        return a - b;
	    });

	    /**
	     * Returns all but the first element of the given list or string (or object
	     * with a `tail` method).
	     *
	     * Dispatches to the `slice` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.head, R.init, R.last
	     * @example
	     *
	     *      R.tail([1, 2, 3]);  //=> [2, 3]
	     *      R.tail([1, 2]);     //=> [2]
	     *      R.tail([1]);        //=> []
	     *      R.tail([]);         //=> []
	     *
	     *      R.tail('abc');  //=> 'bc'
	     *      R.tail('ab');   //=> 'b'
	     *      R.tail('a');    //=> ''
	     *      R.tail('');     //=> ''
	     */
	    var tail = _checkForMethod('tail', slice(1, Infinity));

	    /**
	     * Returns the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `take` method).
	     *
	     * Dispatches to the `take` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.drop
	     * @example
	     *
	     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(3, 'ramda');               //=> 'ram'
	     *
	     *      var personnel = [
	     *        'Dave Brubeck',
	     *        'Paul Desmond',
	     *        'Eugene Wright',
	     *        'Joe Morello',
	     *        'Gerry Mulligan',
	     *        'Bob Bates',
	     *        'Joe Dodge',
	     *        'Ron Crotty'
	     *      ];
	     *
	     *      var takeFive = R.take(5);
	     *      takeFive(personnel);
	     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
	     */
	    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
	        return slice(0, n < 0 ? Infinity : n, xs);
	    }));

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing
	     * each value to the supplied predicate function, and terminating when the
	     * predicate function returns `false`. Excludes the element that caused the
	     * predicate function to fail. The predicate function is passed one argument:
	     * *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropLastWhile, R.addIndex
	     * @example
	     *
	     *      var isNotOne = x => x !== 1;
	     *
	     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
	     */
	    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && fn(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, idx + 1, Infinity);
	    });

	    /**
	     * Returns a new list containing the first `n` elements of a given list,
	     * passing each value to the supplied predicate function, and terminating when
	     * the predicate function returns `false`. Excludes the element that caused the
	     * predicate function to fail. The predicate function is passed one argument:
	     * *(value)*.
	     *
	     * Dispatches to the `takeWhile` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropWhile, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isNotFour = x => x !== 4;
	     *
	     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
	     */
	    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len && fn(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, 0, idx);
	    }));

	    /**
	     * Runs the given function with the supplied object, then returns the object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a -> *) -> a -> a
	     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
	     * @param {*} x
	     * @return {*} `x`.
	     * @example
	     *
	     *      var sayX = x => console.log('x is ' + x);
	     *      R.tap(sayX, 100); //=> 100
	     *      //-> 'x is 100'
	     */
	    var tap = _curry2(function tap(fn, x) {
	        fn(x);
	        return x;
	    });

	    /**
	     * Calls an input function `n` times, returning an array containing the results
	     * of those function calls.
	     *
	     * `fn` is passed one argument: The current value of `n`, which begins at `0`
	     * and is gradually incremented to `n - 1`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.3
	     * @category List
	     * @sig (Number -> a) -> Number -> [a]
	     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
	     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
	     * @return {Array} An array containing the return values of all calls to `fn`.
	     * @example
	     *
	     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
	     */
	    var times = _curry2(function times(fn, n) {
	        var len = Number(n);
	        var idx = 0;
	        var list;
	        if (len < 0 || isNaN(len)) {
	            throw new RangeError('n must be a non-negative number');
	        }
	        list = new Array(len);
	        while (idx < len) {
	            list[idx] = fn(idx);
	            idx += 1;
	        }
	        return list;
	    });

	    /**
	     * Converts an object into an array of key, value arrays. Only the object's
	     * own properties are used.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own properties.
	     * @see R.fromPairs
	     * @example
	     *
	     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
	     */
	    var toPairs = _curry1(function toPairs(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            if (_has(prop, obj)) {
	                pairs[pairs.length] = [
	                    prop,
	                    obj[prop]
	                ];
	            }
	        }
	        return pairs;
	    });

	    /**
	     * Converts an object into an array of key, value arrays. The object's own
	     * properties and prototype properties are used. Note that the order of the
	     * output array is not guaranteed to be consistent across different JS
	     * platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own
	     *         and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
	     */
	    var toPairsIn = _curry1(function toPairsIn(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            pairs[pairs.length] = [
	                prop,
	                obj[prop]
	            ];
	        }
	        return pairs;
	    });

	    /**
	     * Transposes the rows and columns of a 2D list.
	     * When passed a list of `n` lists of length `x`,
	     * returns a list of `x` lists of length `n`.
	     *
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig [[a]] -> [[a]]
	     * @param {Array} list A 2D list
	     * @return {Array} A 2D list
	     * @example
	     *
	     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
	     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     *
	     * If some of the rows are shorter than the following rows, their elements are skipped:
	     *
	     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
	     */
	    var transpose = _curry1(function transpose(outerlist) {
	        var i = 0;
	        var result = [];
	        while (i < outerlist.length) {
	            var innerlist = outerlist[i];
	            var j = 0;
	            while (j < innerlist.length) {
	                if (typeof result[j] === 'undefined') {
	                    result[j] = [];
	                }
	                result[j].push(innerlist[j]);
	                j += 1;
	            }
	            i += 1;
	        }
	        return result;
	    });

	    /**
	     * Removes (strips) whitespace from both ends of the string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to trim.
	     * @return {String} Trimmed version of `str`.
	     * @example
	     *
	     *      R.trim('   xyz  '); //=> 'xyz'
	     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
	     */
	    var trim = function () {
	        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
	        var zeroWidth = '\u200B';
	        var hasProtoTrim = typeof String.prototype.trim === 'function';
	        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
	            return _curry1(function trim(str) {
	                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
	                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
	                return str.replace(beginRx, '').replace(endRx, '');
	            });
	        } else {
	            return _curry1(function trim(str) {
	                return str.trim();
	            });
	        }
	    }();

	    /**
	     * Gives a single-word string description of the (native) type of a value,
	     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
	     * attempt to distinguish user Object types any further, reporting them all as
	     * 'Object'.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Type
	     * @sig (* -> {*}) -> String
	     * @param {*} val The value to test
	     * @return {String}
	     * @example
	     *
	     *      R.type({}); //=> "Object"
	     *      R.type(1); //=> "Number"
	     *      R.type(false); //=> "Boolean"
	     *      R.type('s'); //=> "String"
	     *      R.type(null); //=> "Null"
	     *      R.type([]); //=> "Array"
	     *      R.type(/[A-z]/); //=> "RegExp"
	     */
	    var type = _curry1(function type(val) {
	        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	    });

	    /**
	     * Takes a function `fn`, which takes a single array argument, and returns a
	     * function which:
	     *
	     *   - takes any number of positional arguments;
	     *   - passes these arguments to `fn` as an array; and
	     *   - returns the result.
	     *
	     * In other words, R.unapply derives a variadic function from a function which
	     * takes an array. R.unapply is the inverse of R.apply.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Function
	     * @sig ([*...] -> a) -> (*... -> a)
	     * @param {Function} fn
	     * @return {Function}
	     * @see R.apply
	     * @example
	     *
	     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
	     */
	    var unapply = _curry1(function unapply(fn) {
	        return function () {
	            return fn(_slice(arguments));
	        };
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly 1 parameter. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Function
	     * @sig (* -> b) -> (a -> b)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 1.
	     * @example
	     *
	     *      var takesTwoArgs = function(a, b) {
	     *        return [a, b];
	     *      };
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.unary(takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only 1 argument is passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var unary = _curry1(function unary(fn) {
	        return nAry(1, fn);
	    });

	    /**
	     * Returns a function of arity `n` from a (manually) curried function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Function
	     * @sig Number -> (a -> b) -> (a -> c)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to uncurry.
	     * @return {Function} A new function.
	     * @see R.curry
	     * @example
	     *
	     *      var addFour = a => b => c => d => a + b + c + d;
	     *
	     *      var uncurriedAddFour = R.uncurryN(4, addFour);
	     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
	     */
	    var uncurryN = _curry2(function uncurryN(depth, fn) {
	        return curryN(depth, function () {
	            var currentDepth = 1;
	            var value = fn;
	            var idx = 0;
	            var endIdx;
	            while (currentDepth <= depth && typeof value === 'function') {
	                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
	                value = value.apply(this, _slice(arguments, idx, endIdx));
	                currentDepth += 1;
	                idx = endIdx;
	            }
	            return value;
	        });
	    });

	    /**
	     * Builds a list from a seed value. Accepts an iterator function, which returns
	     * either false to stop iteration or an array of length 2 containing the value
	     * to add to the resulting list and the seed to be used in the next call to the
	     * iterator function.
	     *
	     * The iterator function receives one argument: *(seed)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (a -> [b]) -> * -> [b]
	     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
	     *        either false to quit iteration or an array of length two to proceed. The element
	     *        at index 0 of this array will be added to the resulting array, and the element
	     *        at index 1 will be passed to the next call to `fn`.
	     * @param {*} seed The seed value.
	     * @return {Array} The final list.
	     * @example
	     *
	     *      var f = n => n > 50 ? false : [-n, n + 10];
	     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
	     */
	    var unfold = _curry2(function unfold(fn, seed) {
	        var pair = fn(seed);
	        var result = [];
	        while (pair && pair.length) {
	            result[result.length] = pair[0];
	            pair = fn(pair[1]);
	        }
	        return result;
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list, based upon the value returned by applying the supplied predicate to
	     * two list elements. Prefers the first item if two items compare equal based
	     * on the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      var strEq = R.eqBy(String);
	     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
	     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
	     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
	     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
	     */
	    var uniqWith = _curry2(function uniqWith(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        var item;
	        while (idx < len) {
	            item = list[idx];
	            if (!_containsWith(pred, item, result)) {
	                result[result.length] = item;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Tests the final argument by passing it to the given predicate function. If
	     * the predicate is not satisfied, the function will return the result of
	     * calling the `whenFalseFn` function with the same argument. If the predicate
	     * is satisfied, the argument is returned as is.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Logic
	     * @sig (a -> Boolean) -> (a -> a) -> a -> a
	     * @param {Function} pred        A predicate function
	     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
	     *                               to a falsy value.
	     * @param {*}        x           An object to test with the `pred` function and
	     *                               pass to `whenFalseFn` if necessary.
	     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
	     * @see R.ifElse, R.when
	     * @example
	     *
	     *      // coerceArray :: (a|[a]) -> [a]
	     *      var coerceArray = R.unless(R.isArrayLike, R.of);
	     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
	     *      coerceArray(1);         //=> [1]
	     */
	    var unless = _curry3(function unless(pred, whenFalseFn, x) {
	        return pred(x) ? x : whenFalseFn(x);
	    });

	    /**
	     * Returns a new copy of the array with the element at the provided index
	     * replaced with the given value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} idx The index to update.
	     * @param {*} x The value to exist at the given index of the returned array.
	     * @param {Array|Arguments} list The source array-like object to be updated.
	     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
	     * @see R.adjust
	     * @example
	     *
	     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var update = _curry3(function update(idx, x, list) {
	        return adjust(always(x), idx, list);
	    });

	    /**
	     * Accepts a function `fn` and a list of transformer functions and returns a
	     * new curried function. When the new function is invoked, it calls the
	     * function `fn` with parameters consisting of the result of calling each
	     * supplied handler on successive arguments to the new function.
	     *
	     * If more arguments are passed to the returned function than transformer
	     * functions, those arguments are passed directly to `fn` as additional
	     * parameters. If you expect additional arguments that don't need to be
	     * transformed, although you can ignore them, it's best to pass an identity
	     * function so that the new function reports the correct arity.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
	     * @param {Function} fn The function to wrap.
	     * @param {Array} transformers A list of transformer functions
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
	     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
	     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
	     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
	     */
	    var useWith = _curry2(function useWith(fn, transformers) {
	        return curryN(transformers.length, function () {
	            var args = [];
	            var idx = 0;
	            while (idx < transformers.length) {
	                args.push(transformers[idx].call(this, arguments[idx]));
	                idx += 1;
	            }
	            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
	        });
	    });

	    /**
	     * Returns a list of all the enumerable own properties of the supplied object.
	     * Note that the order of the output array is not guaranteed across different
	     * JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own properties.
	     * @example
	     *
	     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	     */
	    var values = _curry1(function values(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var vals = [];
	        var idx = 0;
	        while (idx < len) {
	            vals[idx] = obj[props[idx]];
	            idx += 1;
	        }
	        return vals;
	    });

	    /**
	     * Returns a list of all the properties, including prototype properties, of the
	     * supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.valuesIn(f); //=> ['X', 'Y']
	     */
	    var valuesIn = _curry1(function valuesIn(obj) {
	        var prop;
	        var vs = [];
	        for (prop in obj) {
	            vs[vs.length] = obj[prop];
	        }
	        return vs;
	    });

	    /**
	     * Returns a "view" of the given data structure, determined by the given lens.
	     * The lens's focus determines which portion of the data structure is visible.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> s -> a
	     * @param {Lens} lens
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});  //=> 1
	     *      R.view(xLens, {x: 4, y: 2});  //=> 4
	     */
	    var view = function () {
	        var Const = function (x) {
	            return {
	                value: x,
	                map: function () {
	                    return this;
	                }
	            };
	        };
	        return _curry2(function view(lens, x) {
	            return lens(Const)(x).value;
	        });
	    }();

	    /**
	     * Tests the final argument by passing it to the given predicate function. If
	     * the predicate is satisfied, the function will return the result of calling
	     * the `whenTrueFn` function with the same argument. If the predicate is not
	     * satisfied, the argument is returned as is.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Logic
	     * @sig (a -> Boolean) -> (a -> a) -> a -> a
	     * @param {Function} pred       A predicate function
	     * @param {Function} whenTrueFn A function to invoke when the `condition`
	     *                              evaluates to a truthy value.
	     * @param {*}        x          An object to test with the `pred` function and
	     *                              pass to `whenTrueFn` if necessary.
	     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
	     * @see R.ifElse, R.unless
	     * @example
	     *
	     *      // truncate :: String -> String
	     *      var truncate = R.when(
	     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
	     *        R.pipe(R.take(10), R.append('…'), R.join(''))
	     *      );
	     *      truncate('12345');         //=> '12345'
	     *      truncate('0123456789ABC'); //=> '0123456789…'
	     */
	    var when = _curry3(function when(pred, whenTrueFn, x) {
	        return pred(x) ? whenTrueFn(x) : x;
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec. Each of the spec's own properties must be a predicate function.
	     * Each predicate is applied to the value of the corresponding property of the
	     * test object. `where` returns true if all the predicates return true, false
	     * otherwise.
	     *
	     * `where` is well suited to declaratively expressing constraints for other
	     * functions such as `filter` and `find`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category Object
	     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.where({
	     *        a: R.equals('foo'),
	     *        b: R.complement(R.equals('bar')),
	     *        x: R.gt(_, 10),
	     *        y: R.lt(_, 20)
	     *      });
	     *
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
	     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
	     */
	    var where = _curry2(function where(spec, testObj) {
	        for (var prop in spec) {
	            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
	                return false;
	            }
	        }
	        return true;
	    });

	    /**
	     * Wrap a function inside another to allow you to make adjustments to the
	     * parameters, or do other processing either before the internal function is
	     * called or with its results.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
	     * @param {Function} fn The function to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var greet = name => 'Hello ' + name;
	     *
	     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
	     *
	     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
	     *
	     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
	     *        return gr(name.substring(0, 3));
	     *      });
	     *      shortenedGreet("Robert"); //=> "Hello Rob"
	     */
	    var wrap = _curry2(function wrap(fn, wrapper) {
	        return curryN(fn.length, function () {
	            return wrapper.apply(this, _concat([fn], arguments));
	        });
	    });

	    /**
	     * Creates a new list out of the two supplied by creating each possible pair
	     * from the lists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The list made by combining each possible pair from
	     *         `as` and `bs` into pairs (`[a, b]`).
	     * @example
	     *
	     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
	     */
	    // = xprodWith(prepend); (takes about 3 times as long...)
	    var xprod = _curry2(function xprod(a, b) {
	        // = xprodWith(prepend); (takes about 3 times as long...)
	        var idx = 0;
	        var ilen = a.length;
	        var j;
	        var jlen = b.length;
	        var result = [];
	        while (idx < ilen) {
	            j = 0;
	            while (j < jlen) {
	                result[result.length] = [
	                    a[idx],
	                    b[j]
	                ];
	                j += 1;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Creates a new list out of the two supplied by pairing up equally-positioned
	     * items from both lists. The returned list is truncated to the length of the
	     * shorter of the two input lists.
	     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
	     * @example
	     *
	     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     */
	    var zip = _curry2(function zip(a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = [
	                a[idx],
	                b[idx]
	            ];
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * Creates a new object out of a list of keys and a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [String] -> [*] -> {String: *}
	     * @param {Array} keys The array that will be properties on the output object.
	     * @param {Array} values The list of values on the output object.
	     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
	     * @example
	     *
	     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
	     */
	    var zipObj = _curry2(function zipObj(keys, values) {
	        var idx = 0;
	        var len = keys.length;
	        var out = {};
	        while (idx < len) {
	            out[keys[idx]] = values[idx];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Creates a new list out of the two supplied by applying the function to each
	     * equally-positioned pair in the lists. The returned list is truncated to the
	     * length of the shorter of the two input lists.
	     *
	     * @function
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,b -> c) -> [a] -> [b] -> [c]
	     * @param {Function} fn The function used to combine the two elements into one value.
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
	     *         using `fn`.
	     * @example
	     *
	     *      var f = (x, y) => {
	     *        // ...
	     *      };
	     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
	     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
	     */
	    var zipWith = _curry3(function zipWith(fn, a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = fn(a[idx], b[idx]);
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * A function that always returns `false`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig * -> Boolean
	     * @param {*}
	     * @return {Boolean}
	     * @see R.always, R.T
	     * @example
	     *
	     *      R.F(); //=> false
	     */
	    var F = always(false);

	    /**
	     * A function that always returns `true`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig * -> Boolean
	     * @param {*}
	     * @return {Boolean}
	     * @see R.always, R.F
	     * @example
	     *
	     *      R.T(); //=> true
	     */
	    var T = always(true);

	    /**
	     * Copies an object.
	     *
	     * @private
	     * @param {*} value The value to be copied
	     * @param {Array} refFrom Array containing the source references
	     * @param {Array} refTo Array containing the copied source references
	     * @return {*} The copied value.
	     */
	    var _clone = function _clone(value, refFrom, refTo) {
	        var copy = function copy(copiedValue) {
	            var len = refFrom.length;
	            var idx = 0;
	            while (idx < len) {
	                if (value === refFrom[idx]) {
	                    return refTo[idx];
	                }
	                idx += 1;
	            }
	            refFrom[idx + 1] = value;
	            refTo[idx + 1] = copiedValue;
	            for (var key in value) {
	                copiedValue[key] = _clone(value[key], refFrom, refTo);
	            }
	            return copiedValue;
	        };
	        switch (type(value)) {
	        case 'Object':
	            return copy({});
	        case 'Array':
	            return copy([]);
	        case 'Date':
	            return new Date(value.valueOf());
	        case 'RegExp':
	            return _cloneRegExp(value);
	        default:
	            return value;
	        }
	    };

	    var _createPartialApplicator = function _createPartialApplicator(concat) {
	        return _curry2(function (fn, args) {
	            return _arity(Math.max(0, fn.length - args.length), function () {
	                return fn.apply(this, concat(args, arguments));
	            });
	        });
	    };

	    var _dropLast = function dropLast(n, xs) {
	        return take(n < xs.length ? xs.length - n : 0, xs);
	    };

	    // Values of other types are only equal if identical.
	    var _equals = function _equals(a, b, stackA, stackB) {
	        if (identical(a, b)) {
	            return true;
	        }
	        if (type(a) !== type(b)) {
	            return false;
	        }
	        if (a == null || b == null) {
	            return false;
	        }
	        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
	            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
	        }
	        switch (type(a)) {
	        case 'Arguments':
	        case 'Array':
	        case 'Object':
	            break;
	        case 'Boolean':
	        case 'Number':
	        case 'String':
	            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
	                return false;
	            }
	            break;
	        case 'Date':
	            if (!identical(a.valueOf(), b.valueOf())) {
	                return false;
	            }
	            break;
	        case 'Error':
	            return a.name === b.name && a.message === b.message;
	        case 'RegExp':
	            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
	                return false;
	            }
	            break;
	        case 'Map':
	        case 'Set':
	            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
	                return false;
	            }
	            break;
	        case 'Int8Array':
	        case 'Uint8Array':
	        case 'Uint8ClampedArray':
	        case 'Int16Array':
	        case 'Uint16Array':
	        case 'Int32Array':
	        case 'Uint32Array':
	        case 'Float32Array':
	        case 'Float64Array':
	            break;
	        case 'ArrayBuffer':
	            break;
	        default:
	            // Values of other types are only equal if identical.
	            return false;
	        }
	        var keysA = keys(a);
	        if (keysA.length !== keys(b).length) {
	            return false;
	        }
	        var idx = stackA.length - 1;
	        while (idx >= 0) {
	            if (stackA[idx] === a) {
	                return stackB[idx] === b;
	            }
	            idx -= 1;
	        }
	        stackA.push(a);
	        stackB.push(b);
	        idx = keysA.length - 1;
	        while (idx >= 0) {
	            var key = keysA[idx];
	            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
	                return false;
	            }
	            idx -= 1;
	        }
	        stackA.pop();
	        stackB.pop();
	        return true;
	    };

	    /**
	     * `_makeFlat` is a helper function that returns a one-level or fully recursive
	     * function based on the flag passed in.
	     *
	     * @private
	     */
	    var _makeFlat = function _makeFlat(recursive) {
	        return function flatt(list) {
	            var value, jlen, j;
	            var result = [];
	            var idx = 0;
	            var ilen = list.length;
	            while (idx < ilen) {
	                if (isArrayLike(list[idx])) {
	                    value = recursive ? flatt(list[idx]) : list[idx];
	                    j = 0;
	                    jlen = value.length;
	                    while (j < jlen) {
	                        result[result.length] = value[j];
	                        j += 1;
	                    }
	                } else {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	            return result;
	        };
	    };

	    var _reduce = function () {
	        function _arrayReduce(xf, acc, list) {
	            var idx = 0;
	            var len = list.length;
	            while (idx < len) {
	                acc = xf['@@transducer/step'](acc, list[idx]);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                idx += 1;
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _iterableReduce(xf, acc, iter) {
	            var step = iter.next();
	            while (!step.done) {
	                acc = xf['@@transducer/step'](acc, step.value);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                step = iter.next();
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _methodReduce(xf, acc, obj) {
	            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
	        }
	        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	        return function _reduce(fn, acc, list) {
	            if (typeof fn === 'function') {
	                fn = _xwrap(fn);
	            }
	            if (isArrayLike(list)) {
	                return _arrayReduce(fn, acc, list);
	            }
	            if (typeof list.reduce === 'function') {
	                return _methodReduce(fn, acc, list);
	            }
	            if (list[symIterator] != null) {
	                return _iterableReduce(fn, acc, list[symIterator]());
	            }
	            if (typeof list.next === 'function') {
	                return _iterableReduce(fn, acc, list);
	            }
	            throw new TypeError('reduce: list must be array or iterable');
	        };
	    }();

	    var _xdropLastWhile = function () {
	        function XDropLastWhile(fn, xf) {
	            this.f = fn;
	            this.retained = [];
	            this.xf = xf;
	        }
	        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
	            this.retained = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
	        };
	        XDropLastWhile.prototype.flush = function (result, input) {
	            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
	            this.retained = [];
	            return this.xf['@@transducer/step'](result, input);
	        };
	        XDropLastWhile.prototype.retain = function (result, input) {
	            this.retained.push(input);
	            return result;
	        };
	        return _curry2(function _xdropLastWhile(fn, xf) {
	            return new XDropLastWhile(fn, xf);
	        });
	    }();

	    var _xgroupBy = function () {
	        function XGroupBy(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.inputs = {};
	        }
	        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
	        XGroupBy.prototype['@@transducer/result'] = function (result) {
	            var key;
	            for (key in this.inputs) {
	                if (_has(key, this.inputs)) {
	                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
	                    if (result['@@transducer/reduced']) {
	                        result = result['@@transducer/value'];
	                        break;
	                    }
	                }
	            }
	            this.inputs = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
	            var key = this.f(input);
	            this.inputs[key] = this.inputs[key] || [
	                key,
	                []
	            ];
	            this.inputs[key][1] = append(input, this.inputs[key][1]);
	            return result;
	        };
	        return _curry2(function _xgroupBy(f, xf) {
	            return new XGroupBy(f, xf);
	        });
	    }();

	    /**
	     * Creates a new list iteration function from an existing one by adding two new
	     * parameters to its callback function: the current index, and the entire list.
	     *
	     * This would turn, for instance, Ramda's simple `map` function into one that
	     * more closely resembles `Array.prototype.map`. Note that this will only work
	     * for functions in which the iteration callback function is the first
	     * parameter, and where the list is the last parameter. (This latter might be
	     * unimportant if the list parameter is not used.)
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Function
	     * @category List
	     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	     * @param {Function} fn A list iteration function that does not pass index or list to its callback
	     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	     * @example
	     *
	     *      var mapIndexed = R.addIndex(R.map);
	     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
	     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	     */
	    var addIndex = _curry1(function addIndex(fn) {
	        return curryN(fn.length, function () {
	            var idx = 0;
	            var origFn = arguments[0];
	            var list = arguments[arguments.length - 1];
	            var args = _slice(arguments);
	            args[0] = function () {
	                var result = origFn.apply(this, _concat(arguments, [
	                    idx,
	                    list
	                ]));
	                idx += 1;
	                return result;
	            };
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly 2 parameters. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Function
	     * @sig (* -> c) -> (a, b -> c)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 2.
	     * @example
	     *
	     *      var takesThreeArgs = function(a, b, c) {
	     *        return [a, b, c];
	     *      };
	     *      takesThreeArgs.length; //=> 3
	     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      var takesTwoArgs = R.binary(takesThreeArgs);
	     *      takesTwoArgs.length; //=> 2
	     *      // Only 2 arguments are passed to the wrapped function
	     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
	     */
	    var binary = _curry1(function binary(fn) {
	        return nAry(2, fn);
	    });

	    /**
	     * Creates a deep copy of the value which may contain (nested) `Array`s and
	     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
	     * copied, but assigned by their reference.
	     *
	     * Dispatches to a `clone` method if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {*} -> {*}
	     * @param {*} value The object or array to clone
	     * @return {*} A new object or array.
	     * @example
	     *
	     *      var objects = [{}, {}, {}];
	     *      var objectsClone = R.clone(objects);
	     *      objects[0] === objectsClone[0]; //=> false
	     */
	    var clone = _curry1(function clone(value) {
	        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], []);
	    });

	    /**
	     * Returns a curried equivalent of the provided function. The curried function
	     * has two unusual capabilities. First, its arguments needn't be provided one
	     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> a) -> (* -> a)
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curryN
	     * @example
	     *
	     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
	     *
	     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curry = _curry1(function curry(fn) {
	        return curryN(fn.length, fn);
	    });

	    /**
	     * Returns all but the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `drop` method).
	     *
	     * Dispatches to the `drop` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.take, R.transduce
	     * @example
	     *
	     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(3, 'ramda');               //=> 'da'
	     */
	    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
	        return slice(Math.max(0, n), Infinity, xs);
	    }));

	    /**
	     * Returns a list containing all but the last `n` elements of the given `list`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements of `xs` to skip.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.takeLast
	     * @example
	     *
	     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(3, 'ramda');               //=> 'ra'
	     */
	    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

	    /**
	     * Returns a new list containing all but last the`n` elements of a given list,
	     * passing each value from the right to the supplied predicate function,
	     * skipping elements while the predicate function returns `true`. The predicate
	     * function is passed one argument: (value)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeLastWhile, R.addIndex
	     * @example
	     *
	     *      var lteThree = x => x <= 3;
	     *
	     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
	     */
	    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

	    /**
	     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
	     * cyclical data structures.
	     *
	     * Dispatches symmetrically to the `equals` methods of both arguments, if
	     * present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> b -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      R.equals(1, 1); //=> true
	     *      R.equals(1, '1'); //=> false
	     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	     *
	     *      var a = {}; a.v = a;
	     *      var b = {}; b.v = b;
	     *      R.equals(a, b); //=> true
	     */
	    var equals = _curry2(function equals(a, b) {
	        return _equals(a, b, [], []);
	    });

	    /**
	     * Takes a predicate and a "filterable", and returns a new filterable of the
	     * same type containing the members of the given filterable which satisfy the
	     * given predicate.
	     *
	     * Dispatches to the `filter` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Filterable f => (a -> Boolean) -> f a -> f a
	     * @param {Function} pred
	     * @param {Array} filterable
	     * @return {Array}
	     * @see R.reject, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	     *
	     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	     */
	    // else
	    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
	        return _isObject(filterable) ? _reduce(function (acc, key) {
	            if (pred(filterable[key])) {
	                acc[key] = filterable[key];
	            }
	            return acc;
	        }, {}, keys(filterable)) : // else
	        _filter(pred, filterable);
	    }));

	    /**
	     * Returns a new list by pulling every item out of it (and all its sub-arrays)
	     * and putting them in a new array, depth-first.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.unnest
	     * @example
	     *
	     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	     */
	    var flatten = _curry1(_makeFlat(true));

	    /**
	     * Returns a new function much like the supplied one, except that the first two
	     * arguments' order is reversed.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
	     * @param {Function} fn The function to invoke with its first two parameters reversed.
	     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
	     * @example
	     *
	     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
	     *
	     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
	     */
	    var flip = _curry1(function flip(fn) {
	        return curry(function (a, b) {
	            var args = _slice(arguments);
	            args[0] = b;
	            args[1] = a;
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Splits a list into sub-lists stored in an object, based on the result of
	     * calling a String-returning function on each element, and grouping the
	     * results according to values returned.
	     *
	     * Dispatches to the `groupBy` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> String) -> [a] -> {String: [a]}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} list The array to group
	     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
	     *         that produced that key when passed to `fn`.
	     * @see R.transduce
	     * @example
	     *
	     *      var byGrade = R.groupBy(function(student) {
	     *        var score = student.score;
	     *        return score < 65 ? 'F' :
	     *               score < 70 ? 'D' :
	     *               score < 80 ? 'C' :
	     *               score < 90 ? 'B' : 'A';
	     *      });
	     *      var students = [{name: 'Abby', score: 84},
	     *                      {name: 'Eddy', score: 58},
	     *                      // ...
	     *                      {name: 'Jack', score: 69}];
	     *      byGrade(students);
	     *      // {
	     *      //   'A': [{name: 'Dianne', score: 99}],
	     *      //   'B': [{name: 'Abby', score: 84}]
	     *      //   // ...,
	     *      //   'F': [{name: 'Eddy', score: 58}]
	     *      // }
	     */
	    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
	        return _reduce(function (acc, elt) {
	            var key = fn(elt);
	            acc[key] = append(elt, acc[key] || (acc[key] = []));
	            return acc;
	        }, {}, list);
	    }));

	    /**
	     * Returns the first element of the given list or string. In some libraries
	     * this function is named `first`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {*}
	     * @see R.tail, R.init, R.last
	     * @example
	     *
	     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
	     *      R.head([]); //=> undefined
	     *
	     *      R.head('abc'); //=> 'a'
	     *      R.head(''); //=> ''
	     */
	    var head = nth(0);

	    /**
	     * Given a function that generates a key, turns a list of objects into an
	     * object indexing the objects by the given key. Note that if multiple
	     * objects generate the same value for the indexing key only the last value
	     * will be included in the generated object.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} array The array of objects to index
	     * @return {Object} An object indexing each array element by the given property.
	     * @example
	     *
	     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
	     *      R.indexBy(R.prop('id'), list);
	     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
	     */
	    var indexBy = _curry2(function indexBy(fn, list) {
	        return _reduce(function (acc, elem) {
	            var key = fn(elem);
	            acc[key] = elem;
	            return acc;
	        }, {}, list);
	    });

	    /**
	     * Returns all but the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.last, R.head, R.tail
	     * @example
	     *
	     *      R.init([1, 2, 3]);  //=> [1, 2]
	     *      R.init([1, 2]);     //=> [1]
	     *      R.init([1]);        //=> []
	     *      R.init([]);         //=> []
	     *
	     *      R.init('abc');  //=> 'ab'
	     *      R.init('ab');   //=> 'a'
	     *      R.init('a');    //=> ''
	     *      R.init('');     //=> ''
	     */
	    var init = slice(0, -1);

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists. Duplication is determined according to the
	     * value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate function that determines whether
	     *        the two supplied elements are equal.
	     * @param {Array} list1 One list of items to compare
	     * @param {Array} list2 A second list of items to compare
	     * @return {Array} A new list containing those elements common to both lists.
	     * @see R.intersection
	     * @example
	     *
	     *      var buffaloSpringfield = [
	     *        {id: 824, name: 'Richie Furay'},
	     *        {id: 956, name: 'Dewey Martin'},
	     *        {id: 313, name: 'Bruce Palmer'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *      var csny = [
	     *        {id: 204, name: 'David Crosby'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 539, name: 'Graham Nash'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *
	     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
	     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
	     */
	    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
	        var results = [];
	        var idx = 0;
	        while (idx < list1.length) {
	            if (_containsWith(pred, list1[idx], list2)) {
	                results[results.length] = list1[idx];
	            }
	            idx += 1;
	        }
	        return uniqWith(pred, results);
	    });

	    /**
	     * Same as R.invertObj, however this accounts for objects with duplicate values
	     * by putting the values into an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {s: x} -> {x: [ s, ... ]}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object with keys
	     * in an array.
	     * @example
	     *
	     *      var raceResultsByFirstName = {
	     *        first: 'alice',
	     *        second: 'jake',
	     *        third: 'alice',
	     *      };
	     *      R.invert(raceResultsByFirstName);
	     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
	     */
	    var invert = _curry1(function invert(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            var val = obj[key];
	            var list = _has(val, out) ? out[val] : out[val] = [];
	            list[list.length] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object with the keys of the given object as values, and the
	     * values of the given object, which are coerced to strings, as keys. Note
	     * that the last key found is preferred when handling the same value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {s: x} -> {x: s}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object
	     * @example
	     *
	     *      var raceResults = {
	     *        first: 'alice',
	     *        second: 'jake'
	     *      };
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': 'first', 'jake':'second' }
	     *
	     *      // Alternatively:
	     *      var raceResults = ['alice', 'jake'];
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': '0', 'jake':'1' }
	     */
	    var invertObj = _curry1(function invertObj(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            out[obj[key]] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns `true` if the given value is its type's empty value; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig a -> Boolean
	     * @param {*} x
	     * @return {Boolean}
	     * @see R.empty
	     * @example
	     *
	     *      R.isEmpty([1, 2, 3]);   //=> false
	     *      R.isEmpty([]);          //=> true
	     *      R.isEmpty('');          //=> true
	     *      R.isEmpty(null);        //=> false
	     *      R.isEmpty({});          //=> true
	     *      R.isEmpty({length: 0}); //=> false
	     */
	    var isEmpty = _curry1(function isEmpty(x) {
	        return x != null && equals(x, empty(x));
	    });

	    /**
	     * Returns the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.init, R.head, R.tail
	     * @example
	     *
	     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
	     *      R.last([]); //=> undefined
	     *
	     *      R.last('abc'); //=> 'c'
	     *      R.last(''); //=> ''
	     */
	    var last = nth(-1);

	    /**
	     * Returns the position of the last occurrence of an item in an array, or -1 if
	     * the item is not included in the array. `R.equals` is used to determine
	     * equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.indexOf
	     * @example
	     *
	     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
	     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
	     */
	    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
	        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
	            return xs.lastIndexOf(target);
	        } else {
	            var idx = xs.length - 1;
	            while (idx >= 0) {
	                if (equals(xs[idx], target)) {
	                    return idx;
	                }
	                idx -= 1;
	            }
	            return -1;
	        }
	    });

	    /**
	     * Takes a function and
	     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
	     * applies the function to each of the functor's values, and returns
	     * a functor of the same shape.
	     *
	     * Ramda provides suitable `map` implementations for `Array` and `Object`,
	     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
	     *
	     * Dispatches to the `map` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * Also treats functions as functors and will compose them together.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Functor f => (a -> b) -> f a -> f b
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {Array} list The list to be iterated over.
	     * @return {Array} The new list.
	     * @see R.transduce, R.addIndex
	     * @example
	     *
	     *      var double = x => x * 2;
	     *
	     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	     *
	     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
	     */
	    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
	        switch (Object.prototype.toString.call(functor)) {
	        case '[object Function]':
	            return curryN(functor.length, function () {
	                return fn.call(this, functor.apply(this, arguments));
	            });
	        case '[object Object]':
	            return _reduce(function (acc, key) {
	                acc[key] = fn(functor[key]);
	                return acc;
	            }, {}, keys(functor));
	        default:
	            return _map(fn, functor);
	        }
	    }));

	    /**
	     * An Object-specific version of `map`. The function is applied to three
	     * arguments: *(value, key, obj)*. If only the value is significant, use
	     * `map` instead.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig ((*, String, Object) -> *) -> Object -> Object
	     * @param {Function} fn
	     * @param {Object} obj
	     * @return {Object}
	     * @see R.map
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
	     *
	     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	     */
	    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key], key, obj);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Creates a new object with the own properties of the two provided objects. If
	     * a key exists in both objects, the provided function is applied to the values
	     * associated with the key in each object, with the result being used as the
	     * value associated with the key in the returned object. The key will be
	     * excluded from the returned object if the resulting value is `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Object
	     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
	     * @param {Function} fn
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.merge, R.mergeWithKey
	     * @example
	     *
	     *      R.mergeWith(R.concat,
	     *                  { a: true, values: [10, 20] },
	     *                  { b: true, values: [15, 35] });
	     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
	     */
	    var mergeWith = _curry3(function mergeWith(fn, l, r) {
	        return mergeWithKey(function (_, _l, _r) {
	            return fn(_l, _r);
	        }, l, r);
	    });

	    /**
	     * Takes a function `f` and a list of arguments, and returns a function `g`.
	     * When applied, `g` returns the result of applying `f` to the arguments
	     * provided initially followed by the arguments provided to `g`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
	     * @param {Function} f
	     * @param {Array} args
	     * @return {Function}
	     * @see R.partialRight
	     * @example
	     *
	     *      var multiply = (a, b) => a * b;
	     *      var double = R.partial(multiply, [2]);
	     *      double(2); //=> 4
	     *
	     *      var greet = (salutation, title, firstName, lastName) =>
	     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *
	     *      var sayHello = R.partial(greet, ['Hello']);
	     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
	     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partial = _createPartialApplicator(_concat);

	    /**
	     * Takes a function `f` and a list of arguments, and returns a function `g`.
	     * When applied, `g` returns the result of applying `f` to the arguments
	     * provided to `g` followed by the arguments provided initially.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
	     * @param {Function} f
	     * @param {Array} args
	     * @return {Function}
	     * @see R.partial
	     * @example
	     *
	     *      var greet = (salutation, title, firstName, lastName) =>
	     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *
	     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
	     *
	     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partialRight = _createPartialApplicator(flip(_concat));

	    /**
	     * Takes a predicate and a list and returns the pair of lists of elements which
	     * do and do not satisfy the predicate, respectively.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
	     * @param {Function} pred A predicate to determine which array the element belongs to.
	     * @param {Array} list The array to partition.
	     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
	     *         and second an array of elements that did not satisfy.
	     * @see R.filter, R.reject
	     * @example
	     *
	     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
	     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
	     */
	    var partition = _curry2(function partition(pred, list) {
	        return _reduce(function (acc, elt) {
	            var xs = acc[pred(elt) ? 0 : 1];
	            xs[xs.length] = elt;
	            return acc;
	        }, [
	            [],
	            []
	        ], list);
	    });

	    /**
	     * Determines whether a nested path on an object has a specific value, in
	     * `R.equals` terms. Most likely used to filter a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Relation
	     * @sig [String] -> * -> {String: *} -> Boolean
	     * @param {Array} path The path of the nested property to use
	     * @param {*} val The value to compare the nested property with
	     * @param {Object} obj The object to check the nested property in
	     * @return {Boolean} `true` if the value equals the nested object property,
	     *         `false` otherwise.
	     * @example
	     *
	     *      var user1 = { address: { zipCode: 90210 } };
	     *      var user2 = { address: { zipCode: 55555 } };
	     *      var user3 = { name: 'Bob' };
	     *      var users = [ user1, user2, user3 ];
	     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
	     *      R.filter(isFamous, users); //=> [ user1 ]
	     */
	    var pathEq = _curry3(function pathEq(_path, val, obj) {
	        return equals(path(_path, obj), val);
	    });

	    /**
	     * Returns a new list by plucking the same named property off all objects in
	     * the list supplied.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig k -> [{k: v}] -> [v]
	     * @param {Number|String} key The key name to pluck off of each object.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of values for the given key.
	     * @see R.props
	     * @example
	     *
	     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
	     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
	     */
	    var pluck = _curry2(function pluck(p, list) {
	        return map(prop(p), list);
	    });

	    /**
	     * Reasonable analog to SQL `select` statement.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @category Relation
	     * @sig [k] -> [{k: v}] -> [{k: v}]
	     * @param {Array} props The property names to project
	     * @param {Array} objs The objects to query
	     * @return {Array} An array of objects with just the `props` properties.
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
	     *      var kids = [abby, fred];
	     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
	     */
	    // passing `identity` gives correct arity
	    var project = useWith(_map, [
	        pickAll,
	        identity
	    ]);

	    /**
	     * Returns `true` if the specified object property is equal, in `R.equals`
	     * terms, to the given value; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig String -> a -> Object -> Boolean
	     * @param {String} name
	     * @param {*} val
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.equals, R.propSatisfies
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
	     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
	     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
	     *      var kids = [abby, fred, rusty, alois];
	     *      var hasBrownHair = R.propEq('hair', 'brown');
	     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
	     */
	    var propEq = _curry3(function propEq(name, val, obj) {
	        return propSatisfies(equals(val), name, obj);
	    });

	    /**
	     * Returns `true` if the specified object property is of the given type;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Type
	     * @sig Type -> String -> Object -> Boolean
	     * @param {Function} type
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.is, R.propSatisfies
	     * @example
	     *
	     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
	     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
	     *      R.propIs(Number, 'x', {});            //=> false
	     */
	    var propIs = _curry3(function propIs(type, name, obj) {
	        return propSatisfies(is(type), name, obj);
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It may use
	     * `R.reduced` to shortcut the iteration.
	     *
	     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	     *
	     * Dispatches to the `reduce` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig ((a, b) -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduced, R.addIndex
	     * @example
	     *
	     *      var numbers = [1, 2, 3];
	     *      var add = (a, b) => a + b;
	     *
	     *      R.reduce(add, 10, numbers); //=> 16
	     */
	    var reduce = _curry3(_reduce);

	    /**
	     * The complement of `filter`.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Filterable f => (a -> Boolean) -> f a -> f a
	     * @param {Function} pred
	     * @param {Array} filterable
	     * @return {Array}
	     * @see R.filter, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isOdd = (n) => n % 2 === 1;
	     *
	     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
	     *
	     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	     */
	    var reject = _curry2(function reject(pred, filterable) {
	        return filter(_complement(pred), filterable);
	    });

	    /**
	     * Returns a fixed list of size `n` containing a specified identical value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig a -> n -> [a]
	     * @param {*} value The value to repeat.
	     * @param {Number} n The desired size of the output list.
	     * @return {Array} A new array containing `n` `value`s.
	     * @example
	     *
	     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
	     *
	     *      var obj = {};
	     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
	     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
	     */
	    var repeat = _curry2(function repeat(value, n) {
	        return times(always(value), n);
	    });

	    /**
	     * Adds together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The sum of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.sum([2,4,6,8,100,1]); //=> 121
	     */
	    var sum = reduce(add, 0);

	    /**
	     * Returns a new list containing the last `n` elements of the given list.
	     * If `n > list.length`, returns a list of `list.length` elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements to return.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.dropLast
	     * @example
	     *
	     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(3, 'ramda');               //=> 'mda'
	     */
	    var takeLast = _curry2(function takeLast(n, xs) {
	        return drop(n >= 0 ? xs.length - n : 0, xs);
	    });

	    /**
	     * Initializes a transducer using supplied iterator function. Returns a single
	     * item by iterating through the list, successively calling the transformed
	     * iterator function and passing it an accumulator value and the current value
	     * from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It will be
	     * wrapped as a transformer to initialize the transducer. A transformer can be
	     * passed directly in place of an iterator function. In both cases, iteration
	     * may be stopped early with the `R.reduced` function.
	     *
	     * A transducer is a function that accepts a transformer and returns a
	     * transformer and can be composed directly.
	     *
	     * A transformer is an an object that provides a 2-arity reducing iterator
	     * function, step, 0-arity initial value function, init, and 1-arity result
	     * extraction function, result. The step function is used as the iterator
	     * function in reduce. The result function is used to convert the final
	     * accumulator into the return type and in most cases is R.identity. The init
	     * function can be used to provide an initial accumulator, but is ignored by
	     * transduce.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array. Wrapped as transformer, if necessary, and used to
	     *        initialize the transducer
	     * @param {*} acc The initial accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduce, R.reduced, R.into
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
	     */
	    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
	        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements
	     * of each list. Duplication is determined according to the value returned by
	     * applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @see R.union
	     * @example
	     *
	     *      var l1 = [{a: 1}, {a: 2}];
	     *      var l2 = [{a: 1}, {a: 4}];
	     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
	     */
	    var unionWith = _curry3(function unionWith(pred, list1, list2) {
	        return uniqWith(pred, _concat(list1, list2));
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec, false otherwise. An object satisfies the spec if, for each of the
	     * spec's own properties, accessing that property of the object gives the same
	     * value (in `R.equals` terms) as accessing that property of the spec.
	     *
	     * `whereEq` is a specialization of [`where`](#where).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @sig {String: *} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @see R.where
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.whereEq({a: 1, b: 2});
	     *
	     *      pred({a: 1});              //=> false
	     *      pred({a: 1, b: 2});        //=> true
	     *      pred({a: 1, b: 2, c: 3});  //=> true
	     *      pred({a: 1, b: 1});        //=> false
	     */
	    var whereEq = _curry2(function whereEq(spec, testObj) {
	        return where(map(equals, spec), testObj);
	    });

	    var _flatCat = function () {
	        var preservingReduced = function (xf) {
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return xf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    var ret = xf['@@transducer/step'](result, input);
	                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	                }
	            };
	        };
	        return function _xcat(xf) {
	            var rxf = preservingReduced(xf);
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return rxf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	                }
	            };
	        };
	    }();

	    // Array.prototype.indexOf doesn't exist below IE9
	    // manually crawl the list to distinguish between +0 and -0
	    // NaN
	    // non-zero numbers can utilise Set
	    // all these types can utilise Set
	    // null can utilise Set
	    // anything else not covered above, defer to R.equals
	    var _indexOf = function _indexOf(list, a, idx) {
	        var inf, item;
	        // Array.prototype.indexOf doesn't exist below IE9
	        if (typeof list.indexOf === 'function') {
	            switch (typeof a) {
	            case 'number':
	                if (a === 0) {
	                    // manually crawl the list to distinguish between +0 and -0
	                    inf = 1 / a;
	                    while (idx < list.length) {
	                        item = list[idx];
	                        if (item === 0 && 1 / item === inf) {
	                            return idx;
	                        }
	                        idx += 1;
	                    }
	                    return -1;
	                } else if (a !== a) {
	                    // NaN
	                    while (idx < list.length) {
	                        item = list[idx];
	                        if (typeof item === 'number' && item !== item) {
	                            return idx;
	                        }
	                        idx += 1;
	                    }
	                    return -1;
	                }
	                // non-zero numbers can utilise Set
	                return list.indexOf(a, idx);
	            // all these types can utilise Set
	            case 'string':
	            case 'boolean':
	            case 'function':
	            case 'undefined':
	                return list.indexOf(a, idx);
	            case 'object':
	                if (a === null) {
	                    // null can utilise Set
	                    return list.indexOf(a, idx);
	                }
	            }
	        }
	        // anything else not covered above, defer to R.equals
	        while (idx < list.length) {
	            if (equals(list[idx], a)) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    };

	    var _xchain = _curry2(function _xchain(f, xf) {
	        return map(f, _flatCat(xf));
	    });

	    /**
	     * Takes a list of predicates and returns a predicate that returns true for a
	     * given list of arguments if every one of the provided predicates is satisfied
	     * by those arguments.
	     *
	     * The function returned is a curried function whose arity matches that of the
	     * highest-arity predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} preds
	     * @return {Function}
	     * @see R.anyPass
	     * @example
	     *
	     *      var isQueen = R.propEq('rank', 'Q');
	     *      var isSpade = R.propEq('suit', '♠︎');
	     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
	     *
	     *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
	     *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
	     */
	    var allPass = _curry1(function allPass(preds) {
	        return curryN(reduce(max, 0, pluck('length', preds)), function () {
	            var idx = 0;
	            var len = preds.length;
	            while (idx < len) {
	                if (!preds[idx].apply(this, arguments)) {
	                    return false;
	                }
	                idx += 1;
	            }
	            return true;
	        });
	    });

	    /**
	     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
	     * `false`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category List
	     * @sig [a] -> Boolean
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if all elements are unique, else `false`.
	     * @example
	     *
	     *      R.allUniq(['1', 1]); //=> true
	     *      R.allUniq([1, 1]);   //=> false
	     *      R.allUniq([[42], [42]]); //=> false
	     */
	    var allUniq = _curry1(function allUniq(list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            if (_indexOf(list, list[idx], idx + 1) >= 0) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    });

	    /**
	     * Takes a list of predicates and returns a predicate that returns true for a
	     * given list of arguments if at least one of the provided predicates is
	     * satisfied by those arguments.
	     *
	     * The function returned is a curried function whose arity matches that of the
	     * highest-arity predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} preds
	     * @return {Function}
	     * @see R.allPass
	     * @example
	     *
	     *      var gte = R.anyPass([R.gt, R.equals]);
	     *
	     *      gte(3, 2); //=> true
	     *      gte(2, 2); //=> true
	     *      gte(2, 3); //=> false
	     */
	    var anyPass = _curry1(function anyPass(preds) {
	        return curryN(reduce(max, 0, pluck('length', preds)), function () {
	            var idx = 0;
	            var len = preds.length;
	            while (idx < len) {
	                if (preds[idx].apply(this, arguments)) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        });
	    });

	    /**
	     * ap applies a list of functions to a list of values.
	     *
	     * Dispatches to the `ap` method of the second argument, if present. Also
	     * treats functions as applicatives.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig [f] -> [a] -> [f a]
	     * @param {Array} fns An array of functions
	     * @param {Array} vs An array of values
	     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
	     * @example
	     *
	     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
	     */
	    // else
	    var ap = _curry2(function ap(applicative, fn) {
	        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
	            return applicative.apply(this, arguments)(fn.apply(this, arguments));
	        }) : // else
	        _reduce(function (acc, f) {
	            return _concat(acc, map(f, fn));
	        }, [], applicative);
	    });

	    /**
	     * Returns the result of calling its first argument with the remaining
	     * arguments. This is occasionally useful as a converging function for
	     * `R.converge`: the left branch can produce a function while the right branch
	     * produces a value to be passed to that function as an argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig (*... -> a),*... -> a
	     * @param {Function} fn The function to apply to the remaining arguments.
	     * @param {...*} args Any number of positional arguments.
	     * @return {*}
	     * @see R.apply
	     * @example
	     *
	     *      var indentN = R.pipe(R.times(R.always(' ')),
	     *                           R.join(''),
	     *                           R.replace(/^(?!$)/gm));
	     *
	     *      var format = R.converge(R.call, [
	     *                                  R.pipe(R.prop('indent'), indentN),
	     *                                  R.prop('value')
	     *                              ]);
	     *
	     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
	     */
	    var call = curry(function call(fn) {
	        return fn.apply(this, _slice(arguments, 1));
	    });

	    /**
	     * `chain` maps a function over a list and concatenates the results. `chain`
	     * is also known as `flatMap` in some libraries
	     *
	     * Dispatches to the `chain` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig (a -> [b]) -> [a] -> [b]
	     * @param {Function} fn
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      var duplicate = n => [n, n];
	     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	     */
	    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
	        if (typeof monad === 'function') {
	            return function () {
	                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
	            };
	        }
	        return _makeFlat(false)(map(fn, monad));
	    }));

	    /**
	     * Turns a list of Functors into a Functor of a list, applying a mapping
	     * function to the elements of the list along the way.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category List
	     * @sig Functor f => (a -> f b) -> (x -> f x) -> [a] -> f [b]
	     * @param {Function} fn The transformation function
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @see R.traverse
	     * @deprecated since v0.19.0
	     * @example
	     *
	     *      var add10 = R.map(R.add(10));
	     *      R.commuteMap(add10, R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
	     *      R.commuteMap(add10, R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
	     *      R.commuteMap(add10, R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
	     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
	     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     *
	     *      var fetch = url => Future((rej, res) => http.get(url, res).on('error', rej));
	     *      R.commuteMap(fetch, Future.of, [
	     *        'http://ramdajs.com',
	     *        'http://github.com/ramda'
	     *      ]); //=> Future([IncomingMessage, IncomingMessage])
	     */
	    var commuteMap = _curry3(function commuteMap(fn, of, list) {
	        function consF(acc, x) {
	            return ap(map(prepend, fn(x)), acc);
	        }
	        return reduceRight(consF, of([]), list);
	    });

	    /**
	     * Wraps a constructor function inside a curried function that can be called
	     * with the same arguments and returns the same type. The arity of the function
	     * returned is specified to allow using variadic constructor functions.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Function
	     * @sig Number -> (* -> {*}) -> (* -> {*})
	     * @param {Number} n The arity of the constructor function.
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Variadic constructor function
	     *      var Widget = () => {
	     *        this.children = Array.prototype.slice.call(arguments);
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
	     */
	    var constructN = _curry2(function constructN(n, Fn) {
	        if (n > 10) {
	            throw new Error('Constructor with greater than ten arguments');
	        }
	        if (n === 0) {
	            return function () {
	                return new Fn();
	            };
	        }
	        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
	            switch (arguments.length) {
	            case 1:
	                return new Fn($0);
	            case 2:
	                return new Fn($0, $1);
	            case 3:
	                return new Fn($0, $1, $2);
	            case 4:
	                return new Fn($0, $1, $2, $3);
	            case 5:
	                return new Fn($0, $1, $2, $3, $4);
	            case 6:
	                return new Fn($0, $1, $2, $3, $4, $5);
	            case 7:
	                return new Fn($0, $1, $2, $3, $4, $5, $6);
	            case 8:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
	            case 9:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
	            case 10:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
	            }
	        }));
	    });

	    /**
	     * Accepts a converging function and a list of branching functions and returns
	     * a new function. When invoked, this new function is applied to some
	     * arguments, each branching function is applied to those same arguments. The
	     * results of each branching function are passed as arguments to the converging
	     * function to produce the return value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.2
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
	     * @param {Function} after A function. `after` will be invoked with the return values of
	     *        `fn1` and `fn2` as its arguments.
	     * @param {Array} functions A list of functions.
	     * @return {Function} A new function.
	     * @example
	     *
	     *      var add = (a, b) => a + b;
	     *      var multiply = (a, b) => a * b;
	     *      var subtract = (a, b) => a - b;
	     *
	     *      //≅ multiply( add(1, 2), subtract(1, 2) );
	     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
	     *
	     *      var add3 = (a, b, c) => a + b + c;
	     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
	     */
	    var converge = _curry2(function converge(after, fns) {
	        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
	            var args = arguments;
	            var context = this;
	            return after.apply(context, _map(function (fn) {
	                return fn.apply(context, args);
	            }, fns));
	        });
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements. Equality is
	     * determined by applying the supplied predicate two consecutive elements. The
	     * first element in a series of equal element is the one being preserved.
	     *
	     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @see R.transduce
	     * @example
	     *
	     *      var lengthEq = (x, y) => Math.abs(x) === Math.abs(y);
	     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
	     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
	     */
	    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
	        var result = [];
	        var idx = 1;
	        var len = list.length;
	        if (len !== 0) {
	            result[0] = list[0];
	            while (idx < len) {
	                if (!pred(last(result), list[idx])) {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	        }
	        return result;
	    }));

	    /**
	     * Takes a function and two values in its domain and returns `true` if the
	     * values map to the same value in the codomain; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Relation
	     * @sig (a -> b) -> a -> a -> Boolean
	     * @param {Function} f
	     * @param {*} x
	     * @param {*} y
	     * @return {Boolean}
	     * @example
	     *
	     *      R.eqBy(Math.abs, 5, -5); //=> true
	     */
	    var eqBy = _curry3(function eqBy(f, x, y) {
	        return equals(f(x), f(y));
	    });

	    /**
	     * Reports whether two objects have the same value, in `R.equals` terms, for
	     * the specified property. Useful as a curried predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig k -> {k: v} -> {k: v} -> Boolean
	     * @param {String} prop The name of the property to compare
	     * @param {Object} obj1
	     * @param {Object} obj2
	     * @return {Boolean}
	     *
	     * @example
	     *
	     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
	     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
	     *      R.eqProps('a', o1, o2); //=> false
	     *      R.eqProps('c', o1, o2); //=> true
	     */
	    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
	        return equals(obj1[prop], obj2[prop]);
	    });

	    /**
	     * Returns the position of the first occurrence of an item in an array, or -1
	     * if the item is not included in the array. `R.equals` is used to determine
	     * equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.lastIndexOf
	     * @example
	     *
	     *      R.indexOf(3, [1,2,3,4]); //=> 2
	     *      R.indexOf(10, [1,2,3,4]); //=> -1
	     */
	    var indexOf = _curry2(function indexOf(target, xs) {
	        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
	    });

	    /**
	     * juxt applies a list of functions to a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Function
	     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
	     * @param {Array} fns An array of functions
	     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
	     * @example
	     *
	     *      var range = R.juxt([Math.min, Math.max]);
	     *      range(3, 4, 9, -3); //=> [-3, 9]
	     */
	    var juxt = _curry1(function juxt(fns) {
	        return function () {
	            return map(apply(__, arguments), fns);
	        };
	    });

	    /**
	     * Returns a lens for the given getter and setter functions. The getter "gets"
	     * the value of the focus; the setter "sets" the value of the focus. The setter
	     * should not mutate the data structure.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
	     * @param {Function} getter
	     * @param {Function} setter
	     * @return {Lens}
	     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lens = _curry2(function lens(getter, setter) {
	        return function (f) {
	            return function (s) {
	                return map(function (v) {
	                    return setter(v, s);
	                }, f(getter(s)));
	            };
	        };
	    });

	    /**
	     * Returns a lens whose focus is the specified index.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Number -> Lens s a
	     * @param {Number} n
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
	     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
	     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
	     */
	    var lensIndex = _curry1(function lensIndex(n) {
	        return lens(nth(n), update(n));
	    });

	    /**
	     * Returns a lens whose focus is the specified path.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig [String] -> Lens s a
	     * @param {Array} path The path to use.
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xyLens = R.lensPath(['x', 'y']);
	     *
	     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
	     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
	     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
	     */
	    var lensPath = _curry1(function lensPath(p) {
	        return lens(path(p), assocPath(p));
	    });

	    /**
	     * Returns a lens whose focus is the specified property.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig String -> Lens s a
	     * @param {String} k
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lensProp = _curry1(function lensProp(k) {
	        return lens(prop(k), assoc(k));
	    });

	    /**
	     * "lifts" a function to be the specified arity, so that it may "map over" that
	     * many lists (or other objects that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply)).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig Number -> (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The lifted function.
	     * @see R.lift
	     * @example
	     *
	     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     */
	    var liftN = _curry2(function liftN(arity, fn) {
	        var lifted = curryN(arity, fn);
	        return curryN(arity, function () {
	            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
	        });
	    });

	    /**
	     * Returns the mean of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.mean([2, 7, 9]); //=> 6
	     *      R.mean([]); //=> NaN
	     */
	    var mean = _curry1(function mean(list) {
	        return sum(list) / list.length;
	    });

	    /**
	     * Returns the median of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.median([2, 9, 7]); //=> 7
	     *      R.median([7, 2, 10, 9]); //=> 8
	     *      R.median([]); //=> NaN
	     */
	    var median = _curry1(function median(list) {
	        var len = list.length;
	        if (len === 0) {
	            return NaN;
	        }
	        var width = 2 - len % 2;
	        var idx = (len - width) / 2;
	        return mean(_slice(list).sort(function (a, b) {
	            return a < b ? -1 : a > b ? 1 : 0;
	        }).slice(idx, idx + width));
	    });

	    /**
	     * Create a new object with the own properties of the first object merged with
	     * the own properties of the second object. If a key exists in both objects,
	     * the value from the second object will be used.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> {k: v} -> {k: v}
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.mergeWith, R.mergeWithKey
	     * @example
	     *
	     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
	     *      //=> { 'name': 'fred', 'age': 40 }
	     *
	     *      var resetToDefault = R.merge(R.__, {x: 0});
	     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
	     */
	    var merge = mergeWith(function (l, r) {
	        return r;
	    });

	    /**
	     * Merges a list of objects together into one object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig [{k: v}] -> {k: v}
	     * @param {Array} list An array of objects
	     * @return {Object} A merged object.
	     * @see R.reduce
	     * @example
	     *
	     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
	     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
	     */
	    var mergeAll = _curry1(function mergeAll(list) {
	        return reduce(merge, {}, list);
	    });

	    /**
	     * Performs left-to-right function composition. The leftmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * In some libraries this function is named `sequence`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.compose
	     * @example
	     *
	     *      var f = R.pipe(Math.pow, R.negate, R.inc);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var pipe = function pipe() {
	        if (arguments.length === 0) {
	            throw new Error('pipe requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	    };

	    /**
	     * Performs left-to-right composition of one or more Promise-returning
	     * functions. The leftmost function may have any arity; the remaining functions
	     * must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.composeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
	     */
	    var pipeP = function pipeP() {
	        if (arguments.length === 0) {
	            throw new Error('pipeP requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
	    };

	    /**
	     * Multiplies together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The product of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.product([2,4,6,8,100,1]); //=> 38400
	     */
	    var product = reduce(multiply, 1);

	    /**
	     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
	     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
	     * Applicative of Traversable.
	     *
	     * Dispatches to the `sequence` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
	     * @param {Function} of
	     * @param {*} traversable
	     * @return {*}
	     * @see R.traverse
	     * @example
	     *
	     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     *
	     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
	     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
	     */
	    var sequence = _curry2(function sequence(of, traversable) {
	        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
	            return ap(map(prepend, x), acc);
	        }, of([]), traversable);
	    });

	    /**
	     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
	     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
	     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
	     * into an Applicative of Traversable.
	     *
	     * Dispatches to the `sequence` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
	     * @param {Function} of
	     * @param {Function} f
	     * @param {*} traversable
	     * @return {*}
	     * @see R.sequence
	     * @example
	     *
	     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Just(3)]);   //=> Just([-1, -2, -3])
	     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     *
	     *      R.traverse(R.of, R.negate, Just([1, 2, 3])); //=> [Just(-1), Just(-2), Just(-3)]
	     *      R.traverse(R.of, R.negate, Nothing());       //=> [Nothing()]
	     */
	    var traverse = _curry3(function traverse(of, f, traversable) {
	        return sequence(of, map(f, traversable));
	    });

	    /**
	     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
	     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig Chain c => c (c a) -> c a
	     * @param {*} list
	     * @return {*}
	     * @see R.flatten, R.chain
	     * @example
	     *
	     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
	     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
	     */
	    var unnest = chain(_identity);

	    var _contains = function _contains(a, list) {
	        return _indexOf(list, a, 0) >= 0;
	    };

	    var _stepCat = function () {
	        var _stepCatArray = {
	            '@@transducer/init': Array,
	            '@@transducer/step': function (xs, x) {
	                return _concat(xs, [x]);
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatString = {
	            '@@transducer/init': String,
	            '@@transducer/step': function (a, b) {
	                return a + b;
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatObject = {
	            '@@transducer/init': Object,
	            '@@transducer/step': function (result, input) {
	                return merge(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
	            },
	            '@@transducer/result': _identity
	        };
	        return function _stepCat(obj) {
	            if (_isTransformer(obj)) {
	                return obj;
	            }
	            if (isArrayLike(obj)) {
	                return _stepCatArray;
	            }
	            if (typeof obj === 'string') {
	                return _stepCatString;
	            }
	            if (typeof obj === 'object') {
	                return _stepCatObject;
	            }
	            throw new Error('Cannot create transformer for ' + obj);
	        };
	    }();

	    //  mapPairs :: (Object, [String]) -> [String]
	    var _toString = function _toString(x, seen) {
	        var recur = function recur(y) {
	            var xs = seen.concat([x]);
	            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
	        };
	        //  mapPairs :: (Object, [String]) -> [String]
	        var mapPairs = function (obj, keys) {
	            return _map(function (k) {
	                return _quote(k) + ': ' + recur(obj[k]);
	            }, keys.slice().sort());
	        };
	        switch (Object.prototype.toString.call(x)) {
	        case '[object Arguments]':
	            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
	        case '[object Array]':
	            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
	                return /^\d+$/.test(k);
	            }, keys(x)))).join(', ') + ']';
	        case '[object Boolean]':
	            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
	        case '[object Date]':
	            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
	        case '[object Null]':
	            return 'null';
	        case '[object Number]':
	            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
	        case '[object String]':
	            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
	        case '[object Undefined]':
	            return 'undefined';
	        default:
	            if (typeof x.toString === 'function') {
	                var repr = x.toString();
	                if (repr !== '[object Object]') {
	                    return repr;
	                }
	            }
	            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
	        }
	    };

	    /**
	     * Turns a list of Functors into a Functor of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category List
	     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
	     * @param {Function} of A function that returns the data type to return
	     * @param {Array} list An array of functors of the same type
	     * @return {*}
	     * @see R.sequence
	     * @deprecated since v0.19.0
	     * @example
	     *
	     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
	     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
	     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
	     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     */
	    var commute = commuteMap(identity);

	    /**
	     * Performs right-to-left function composition. The rightmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipe
	     * @example
	     *
	     *      var f = R.compose(R.inc, R.negate, Math.pow);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var compose = function compose() {
	        if (arguments.length === 0) {
	            throw new Error('compose requires at least one argument');
	        }
	        return pipe.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the right-to-left Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Function
	     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @see R.pipeK
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.composeK(
	     *        R.compose(Maybe.of, R.toUpper),
	     *        get('state'),
	     *        get('address'),
	     *        get('user'),
	     *        parseJson
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var composeK = function composeK() {
	        return compose.apply(this, prepend(identity, map(chain, arguments)));
	    };

	    /**
	     * Performs right-to-left composition of one or more Promise-returning
	     * functions. The rightmost function may have any arity; the remaining
	     * functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
	     */
	    var composeP = function composeP() {
	        if (arguments.length === 0) {
	            throw new Error('composeP requires at least one argument');
	        }
	        return pipeP.apply(this, reverse(arguments));
	    };

	    /**
	     * Wraps a constructor function inside a curried function that can be called
	     * with the same arguments and returns the same type.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> {*}) -> (* -> {*})
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Constructor function
	     *      var Widget = config => {
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
	     */
	    var construct = _curry1(function construct(Fn) {
	        return constructN(Fn.length, Fn);
	    });

	    /**
	     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
	     * least one element of the given list; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Boolean
	     * @param {Object} a The item to compare against.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
	     * @see R.any
	     * @example
	     *
	     *      R.contains(3, [1, 2, 3]); //=> true
	     *      R.contains(4, [1, 2, 3]); //=> false
	     *      R.contains([42], [[42]]); //=> true
	     */
	    var contains = _curry2(_contains);

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not
	     * contained in the second list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.differenceWith
	     * @example
	     *
	     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
	     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
	     */
	    var difference = _curry2(function difference(first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
	                out[out.length] = first[idx];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements. `R.equals`
	     * is used to determine equality.
	     *
	     * Dispatches to the `dropRepeats` method of the first argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @see R.transduce
	     * @example
	     *
	     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
	     */
	    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

	    /**
	     * Transforms the items of the list with the transducer and appends the
	     * transformed items to the accumulator using an appropriate iterator function
	     * based on the accumulator type.
	     *
	     * The accumulator can be an array, string, object or a transformer. Iterated
	     * items will be appended to arrays and concatenated to strings. Objects will
	     * be merged directly or 2-item arrays will be merged as key, value pairs.
	     *
	     * The accumulator can also be a transformer object that provides a 2-arity
	     * reducing iterator function, step, 0-arity initial value function, init, and
	     * 1-arity result extraction function result. The step function is used as the
	     * iterator function in reduce. The result function is used to convert the
	     * final accumulator into the return type and in most cases is R.identity. The
	     * init function is used to provide the initial accumulator.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig a -> (b -> b) -> [c] -> a
	     * @param {*} acc The initial accumulator value.
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.into([], transducer, numbers); //=> [2, 3]
	     *
	     *      var intoArray = R.into([]);
	     *      intoArray(transducer, numbers); //=> [2, 3]
	     */
	    var into = _curry3(function into(acc, xf, list) {
	        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
	    });

	    /**
	     * "lifts" a function of arity > 1 so that it may "map over" an Array or other
	     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The lifted function.
	     * @see R.liftN
	     * @example
	     *
	     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
	     *
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     *
	     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
	     *
	     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
	     */
	    var lift = _curry1(function lift(fn) {
	        return liftN(fn.length, fn);
	    });

	    /**
	     * Returns a partial copy of an object omitting the keys specified.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [String] -> {String: *} -> {String: *}
	     * @param {Array} names an array of String property names to omit from the new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with properties from `names` not on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	     */
	    var omit = _curry2(function omit(names, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (!_contains(prop, names)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the left-to-right Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Function
	     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @see R.composeK
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.pipeK(
	     *        parseJson,
	     *        get('user'),
	     *        get('address'),
	     *        get('state'),
	     *        R.compose(Maybe.of, R.toUpper)
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var pipeK = function pipeK() {
	        return composeK.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the string representation of the given value. `eval`'ing the output
	     * should result in a value equivalent to the input value. Many of the built-in
	     * `toString` methods do not satisfy this requirement.
	     *
	     * If the given value is an `[object Object]` with a `toString` method other
	     * than `Object.prototype.toString`, this method is invoked with no arguments
	     * to produce the return value. This means user-defined constructor functions
	     * can provide a suitable `toString` method. For example:
	     *
	     *     function Point(x, y) {
	     *       this.x = x;
	     *       this.y = y;
	     *     }
	     *
	     *     Point.prototype.toString = function() {
	     *       return 'new Point(' + this.x + ', ' + this.y + ')';
	     *     };
	     *
	     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category String
	     * @sig * -> String
	     * @param {*} val
	     * @return {String}
	     * @example
	     *
	     *      R.toString(42); //=> '42'
	     *      R.toString('abc'); //=> '"abc"'
	     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
	     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
	     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
	     */
	    var toString = _curry1(function toString(val) {
	        return _toString(val, []);
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list, based upon the value returned by applying the supplied function to
	     * each list element. Prefers the first item if the supplied function produces
	     * the same value on two items. `R.equals` is used for comparison.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> b) -> [a] -> [a]
	     * @param {Function} fn A function used to produce a value to use during comparisons.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
	     */
	    /* globals Set */
	    // distinguishing between +0 and -0 is not supported by Set
	    /* falls through */
	    // these types can all utilise Set
	    // prevent scan for null by tracking as a boolean
	    /* falls through */
	    // scan through all previously applied items
	    var uniqBy = _curry2(/* globals Set */
	    typeof Set === 'undefined' ? function uniqBy(fn, list) {
	        var idx = 0;
	        var applied = [];
	        var result = [];
	        var appliedItem, item;
	        while (idx < list.length) {
	            item = list[idx];
	            appliedItem = fn(item);
	            if (!_contains(appliedItem, applied)) {
	                result.push(item);
	                applied.push(appliedItem);
	            }
	            idx += 1;
	        }
	        return result;
	    } : function uniqBySet(fn, list) {
	        var set = new Set();
	        var applied = [];
	        var prevSetSize = 0;
	        var result = [];
	        var nullExists = false;
	        var negZeroExists = false;
	        var idx = 0;
	        var appliedItem, item, newSetSize;
	        while (idx < list.length) {
	            item = list[idx];
	            appliedItem = fn(item);
	            switch (typeof appliedItem) {
	            case 'number':
	                // distinguishing between +0 and -0 is not supported by Set
	                if (appliedItem === 0 && !negZeroExists && 1 / appliedItem === -Infinity) {
	                    negZeroExists = true;
	                    result.push(item);
	                    break;
	                }
	            /* falls through */
	            case 'string':
	            case 'boolean':
	            case 'function':
	            case 'undefined':
	                // these types can all utilise Set
	                set.add(appliedItem);
	                newSetSize = set.size;
	                if (newSetSize > prevSetSize) {
	                    result.push(item);
	                    prevSetSize = newSetSize;
	                }
	                break;
	            case 'object':
	                if (appliedItem === null) {
	                    if (!nullExists) {
	                        // prevent scan for null by tracking as a boolean
	                        nullExists = true;
	                        result.push(null);
	                    }
	                    break;
	                }
	            /* falls through */
	            default:
	                // scan through all previously applied items
	                if (!_contains(appliedItem, applied)) {
	                    applied.push(appliedItem);
	                    result.push(item);
	                }
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a new list without values in the first argument.
	     * `R.equals` is used to determine equality.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The values to be removed from `list2`.
	     * @param {Array} list2 The array to remove values from.
	     * @return {Array} The new array without values in `list1`.
	     * @see R.transduce
	     * @example
	     *
	     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
	     */
	    var without = _curry2(function (xs, list) {
	        return reject(flip(_contains)(xs), list);
	    });

	    /**
	     * Takes a function `f` and returns a function `g` such that:
	     *
	     *   - applying `g` to zero or more arguments will give __true__ if applying
	     *     the same arguments to `f` gives a logical __false__ value; and
	     *
	     *   - applying `g` to zero or more arguments will give __false__ if applying
	     *     the same arguments to `f` gives a logical __true__ value.
	     *
	     * `R.complement` will work on all other functors as well.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> *) -> (*... -> Boolean)
	     * @param {Function} f
	     * @return {Function}
	     * @see R.not
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *      var isOdd = R.complement(isEven);
	     *      isOdd(21); //=> true
	     *      isOdd(42); //=> false
	     */
	    var complement = lift(not);

	    /**
	     * Turns a named method with a specified arity into a function that can be
	     * called directly supplied with arguments and a target object.
	     *
	     * The returned function is curried and accepts `arity + 1` parameters where
	     * the final parameter is the target object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
	     * @param {Number} arity Number of arguments the returned function should take
	     *        before the target object.
	     * @param {String} method Name of the method to call.
	     * @return {Function} A new curried function.
	     * @example
	     *
	     *      var sliceFrom = R.invoker(1, 'slice');
	     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
	     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
	     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
	     */
	    var invoker = _curry2(function invoker(arity, method) {
	        return curryN(arity + 1, function () {
	            var target = arguments[arity];
	            if (target != null && is(Function, target[method])) {
	                return target[method].apply(target, _slice(arguments, 0, arity));
	            }
	            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
	        });
	    });

	    /**
	     * Returns a string made by inserting the `separator` between each element and
	     * concatenating all the elements into a single string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig String -> [a] -> String
	     * @param {Number|String} separator The string used to separate the elements.
	     * @param {Array} xs The elements to join into a string.
	     * @return {String} str The string made by concatenating `xs` with `separator`.
	     * @see R.split
	     * @example
	     *
	     *      var spacer = R.join(' ');
	     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
	     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
	     */
	    var join = invoker(1, 'join');

	    /**
	     * Creates a new function that, when invoked, caches the result of calling `fn`
	     * for a given argument set and returns the result. Subsequent calls to the
	     * memoized `fn` with the same argument set will not result in an additional
	     * call to `fn`; instead, the cached result for that set of arguments will be
	     * returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (*... -> a) -> (*... -> a)
	     * @param {Function} fn The function to memoize.
	     * @return {Function} Memoized version of `fn`.
	     * @example
	     *
	     *      var count = 0;
	     *      var factorial = R.memoize(n => {
	     *        count += 1;
	     *        return R.product(R.range(1, n + 1));
	     *      });
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      count; //=> 1
	     */
	    var memoize = _curry1(function memoize(fn) {
	        var cache = {};
	        return _arity(fn.length, function () {
	            var key = toString(arguments);
	            if (!_has(key, cache)) {
	                cache[key] = fn.apply(this, arguments);
	            }
	            return cache[key];
	        });
	    });

	    /**
	     * Splits a string into an array of strings based on the given
	     * separator.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category String
	     * @sig (String | RegExp) -> String -> [String]
	     * @param {String|RegExp} sep The pattern.
	     * @param {String} str The string to separate into an array.
	     * @return {Array} The array of strings from `str` separated by `str`.
	     * @see R.join
	     * @example
	     *
	     *      var pathComponents = R.split('/');
	     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
	     *
	     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
	     */
	    var split = invoker(1, 'split');

	    /**
	     * Determines whether a given string matches a given regular expression.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category String
	     * @sig RegExp -> String -> Boolean
	     * @param {RegExp} pattern
	     * @param {String} str
	     * @return {Boolean}
	     * @see R.match
	     * @example
	     *
	     *      R.test(/^x/, 'xyz'); //=> true
	     *      R.test(/^y/, 'xyz'); //=> false
	     */
	    var test = _curry2(function test(pattern, str) {
	        if (!_isRegExp(pattern)) {
	            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
	        }
	        return _cloneRegExp(pattern).test(str);
	    });

	    /**
	     * The lower case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to lower case.
	     * @return {String} The lower case version of `str`.
	     * @see R.toUpper
	     * @example
	     *
	     *      R.toLower('XYZ'); //=> 'xyz'
	     */
	    var toLower = invoker(0, 'toLowerCase');

	    /**
	     * The upper case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to upper case.
	     * @return {String} The upper case version of `str`.
	     * @see R.toLower
	     * @example
	     *
	     *      R.toUpper('abc'); //=> 'ABC'
	     */
	    var toUpper = invoker(0, 'toUpperCase');

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list. `R.equals` is used to determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
	     *      R.uniq([1, '1']);     //=> [1, '1']
	     *      R.uniq([[42], [42]]); //=> [[42]]
	     */
	    var uniq = uniqBy(identity);

	    /**
	     * Returns the result of concatenating the given lists or strings.
	     *
	     * Dispatches to the `concat` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @sig String -> String -> String
	     * @param {Array|String} a
	     * @param {Array|String} b
	     * @return {Array|String}
	     *
	     * @example
	     *
	     *      R.concat([], []); //=> []
	     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
	     */
	    var concat = flip(invoker(1, 'concat'));

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The list of elements found in both `list1` and `list2`.
	     * @see R.intersectionWith
	     * @example
	     *
	     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
	     */
	    var intersection = _curry2(function intersection(list1, list2) {
	        return uniq(_filter(flip(_contains)(list1), list2));
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements contained in the first or
	     * second list, but not both.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` or `list2`, but not both.
	     * @see R.symmetricDifferenceWith
	     * @example
	     *
	     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
	     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
	     */
	    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
	        return concat(difference(list1, list2), difference(list2, list1));
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements contained in the first or
	     * second list, but not both. Duplication is determined according to the value
	     * returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since 0.19.1
	     * @since 0.19.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` or `list2`, but not both.
	     * @see R.symmetricDifference
	     * @example
	     *
	     *      var eqA = R.eqBy(R.prop('a'));
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
	     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
	     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
	     */
	    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
	        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements
	     * of each list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @example
	     *
	     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
	     */
	    var union = _curry2(compose(uniq, _concat));

	    var R = {
	        F: F,
	        T: T,
	        __: __,
	        add: add,
	        addIndex: addIndex,
	        adjust: adjust,
	        all: all,
	        allPass: allPass,
	        allUniq: allUniq,
	        always: always,
	        and: and,
	        any: any,
	        anyPass: anyPass,
	        ap: ap,
	        aperture: aperture,
	        append: append,
	        apply: apply,
	        assoc: assoc,
	        assocPath: assocPath,
	        binary: binary,
	        bind: bind,
	        both: both,
	        call: call,
	        chain: chain,
	        clone: clone,
	        commute: commute,
	        commuteMap: commuteMap,
	        comparator: comparator,
	        complement: complement,
	        compose: compose,
	        composeK: composeK,
	        composeP: composeP,
	        concat: concat,
	        cond: cond,
	        construct: construct,
	        constructN: constructN,
	        contains: contains,
	        converge: converge,
	        countBy: countBy,
	        curry: curry,
	        curryN: curryN,
	        dec: dec,
	        defaultTo: defaultTo,
	        difference: difference,
	        differenceWith: differenceWith,
	        dissoc: dissoc,
	        dissocPath: dissocPath,
	        divide: divide,
	        drop: drop,
	        dropLast: dropLast,
	        dropLastWhile: dropLastWhile,
	        dropRepeats: dropRepeats,
	        dropRepeatsWith: dropRepeatsWith,
	        dropWhile: dropWhile,
	        either: either,
	        empty: empty,
	        eqBy: eqBy,
	        eqProps: eqProps,
	        equals: equals,
	        evolve: evolve,
	        filter: filter,
	        find: find,
	        findIndex: findIndex,
	        findLast: findLast,
	        findLastIndex: findLastIndex,
	        flatten: flatten,
	        flip: flip,
	        forEach: forEach,
	        fromPairs: fromPairs,
	        groupBy: groupBy,
	        gt: gt,
	        gte: gte,
	        has: has,
	        hasIn: hasIn,
	        head: head,
	        identical: identical,
	        identity: identity,
	        ifElse: ifElse,
	        inc: inc,
	        indexBy: indexBy,
	        indexOf: indexOf,
	        init: init,
	        insert: insert,
	        insertAll: insertAll,
	        intersection: intersection,
	        intersectionWith: intersectionWith,
	        intersperse: intersperse,
	        into: into,
	        invert: invert,
	        invertObj: invertObj,
	        invoker: invoker,
	        is: is,
	        isArrayLike: isArrayLike,
	        isEmpty: isEmpty,
	        isNil: isNil,
	        join: join,
	        juxt: juxt,
	        keys: keys,
	        keysIn: keysIn,
	        last: last,
	        lastIndexOf: lastIndexOf,
	        length: length,
	        lens: lens,
	        lensIndex: lensIndex,
	        lensPath: lensPath,
	        lensProp: lensProp,
	        lift: lift,
	        liftN: liftN,
	        lt: lt,
	        lte: lte,
	        map: map,
	        mapAccum: mapAccum,
	        mapAccumRight: mapAccumRight,
	        mapObjIndexed: mapObjIndexed,
	        match: match,
	        mathMod: mathMod,
	        max: max,
	        maxBy: maxBy,
	        mean: mean,
	        median: median,
	        memoize: memoize,
	        merge: merge,
	        mergeAll: mergeAll,
	        mergeWith: mergeWith,
	        mergeWithKey: mergeWithKey,
	        min: min,
	        minBy: minBy,
	        modulo: modulo,
	        multiply: multiply,
	        nAry: nAry,
	        negate: negate,
	        none: none,
	        not: not,
	        nth: nth,
	        nthArg: nthArg,
	        objOf: objOf,
	        of: of,
	        omit: omit,
	        once: once,
	        or: or,
	        over: over,
	        pair: pair,
	        partial: partial,
	        partialRight: partialRight,
	        partition: partition,
	        path: path,
	        pathEq: pathEq,
	        pathOr: pathOr,
	        pathSatisfies: pathSatisfies,
	        pick: pick,
	        pickAll: pickAll,
	        pickBy: pickBy,
	        pipe: pipe,
	        pipeK: pipeK,
	        pipeP: pipeP,
	        pluck: pluck,
	        prepend: prepend,
	        product: product,
	        project: project,
	        prop: prop,
	        propEq: propEq,
	        propIs: propIs,
	        propOr: propOr,
	        propSatisfies: propSatisfies,
	        props: props,
	        range: range,
	        reduce: reduce,
	        reduceRight: reduceRight,
	        reduced: reduced,
	        reject: reject,
	        remove: remove,
	        repeat: repeat,
	        replace: replace,
	        reverse: reverse,
	        scan: scan,
	        sequence: sequence,
	        set: set,
	        slice: slice,
	        sort: sort,
	        sortBy: sortBy,
	        split: split,
	        splitAt: splitAt,
	        splitEvery: splitEvery,
	        splitWhen: splitWhen,
	        subtract: subtract,
	        sum: sum,
	        symmetricDifference: symmetricDifference,
	        symmetricDifferenceWith: symmetricDifferenceWith,
	        tail: tail,
	        take: take,
	        takeLast: takeLast,
	        takeLastWhile: takeLastWhile,
	        takeWhile: takeWhile,
	        tap: tap,
	        test: test,
	        times: times,
	        toLower: toLower,
	        toPairs: toPairs,
	        toPairsIn: toPairsIn,
	        toString: toString,
	        toUpper: toUpper,
	        transduce: transduce,
	        transpose: transpose,
	        traverse: traverse,
	        trim: trim,
	        type: type,
	        unapply: unapply,
	        unary: unary,
	        uncurryN: uncurryN,
	        unfold: unfold,
	        union: union,
	        unionWith: unionWith,
	        uniq: uniq,
	        uniqBy: uniqBy,
	        uniqWith: uniqWith,
	        unless: unless,
	        unnest: unnest,
	        update: update,
	        useWith: useWith,
	        values: values,
	        valuesIn: valuesIn,
	        view: view,
	        when: when,
	        where: where,
	        whereEq: whereEq,
	        without: without,
	        wrap: wrap,
	        xprod: xprod,
	        zip: zip,
	        zipObj: zipObj,
	        zipWith: zipWith
	    };
	  /* eslint-env amd */

	  /* TEST_ENTRY_POINT */

	  if (true) {
	    module.exports = R;
	  } else if (typeof define === 'function' && define.amd) {
	    define(function() { return R; });
	  } else {
	    this.R = R;
	  }

	}.call(this));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isExport = exports.isImport = exports.isBindingPropertyProperty = exports.isBindingPropertyIdentifier = exports.isObjectBinding = exports.isArrayBinding = exports.isBindingIdentifier = exports.isFunctionWithName = exports.isFunctionTerm = exports.isFunctionExpression = exports.isFunctionDeclaration = exports.isSyntaxrecDeclaration = exports.isSyntaxDeclaration = exports.isVariableDeclarationStatement = exports.isVariableDeclaration = exports.isEOF = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(9);

	var _errors = __webpack_require__(12);

	var _utils = __webpack_require__(28);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _ramda = __webpack_require__(26);

	var R = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _class = function () {
	  function _class(type, props) {
	    _classCallCheck(this, _class);

	    this.type = type;
	    this.loc = null;
	    // this._fields = Object.keys(props);
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = Object.keys(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var prop = _step.value;

	        this[prop] = props[prop];
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }

	  _createClass(_class, [{
	    key: "addScope",
	    value: function addScope(scope, bindings, options) {
	      // todo: deal with hygiene here
	      return this;
	    }
	  }]);

	  return _class;
	}();

	exports.default = _class;
	var isEOF = exports.isEOF = R.whereEq({ type: 'EOF' });
	var isVariableDeclaration = exports.isVariableDeclaration = R.whereEq({ type: 'VariableDeclaration' });
	var isVariableDeclarationStatement = exports.isVariableDeclarationStatement = R.whereEq({ type: 'VariableDeclarationStatement' });
	var isSyntaxDeclaration = exports.isSyntaxDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: 'syntax' }));
	var isSyntaxrecDeclaration = exports.isSyntaxrecDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: 'syntaxrec' }));
	var isFunctionDeclaration = exports.isFunctionDeclaration = R.whereEq({ type: 'FunctionDeclaration' });
	var isFunctionExpression = exports.isFunctionExpression = R.whereEq({ type: 'FunctionExpression' });
	var isFunctionTerm = exports.isFunctionTerm = R.either(isFunctionDeclaration, isFunctionExpression);
	var isFunctionWithName = exports.isFunctionWithName = R.and(isFunctionTerm, R.complement(R.where({ name: R.isNil })));
	var isBindingIdentifier = exports.isBindingIdentifier = R.where({ name: R.is(_syntax2.default) });
	var isArrayBinding = exports.isArrayBinding = R.whereEq({ type: 'ArrayBinding' });
	var isObjectBinding = exports.isObjectBinding = R.whereEq({ type: 'ObjectBinding' });
	var isBindingPropertyIdentifier = exports.isBindingPropertyIdentifier = R.whereEq({ type: 'BindingPropertyIdentifier' });
	var isBindingPropertyProperty = exports.isBindingPropertyProperty = R.whereEq({ type: 'BindingPropertyProperty' });
	var isImport = exports.isImport = R.whereEq({ type: 'Import' });
	var isExport = exports.isExport = R.whereEq({ type: 'Export' });
	//# sourceMappingURL=terms.js.map


/***/ },
/* 28 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.mixin = mixin;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function mixin(target, source) {
	  var F = function (_target) {
	    _inherits(F, _target);

	    function F() {
	      _classCallCheck(this, F);

	      return _possibleConstructorReturn(this, Object.getPrototypeOf(F).apply(this, arguments));
	    }

	    return F;
	  }(target);

	  Object.getOwnPropertyNames(source.prototype).forEach(function (name) {
	    if (name !== "constructor") {
	      var newProp = Object.getOwnPropertyDescriptor(source.prototype, name);
	      Object.defineProperty(F.prototype, name, newProp);
	    }
	  });
	  return F;
	}
	//# sourceMappingURL=utils.js.map


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(9);

	var _termExpander = __webpack_require__(30);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _tokenExpander = __webpack_require__(49);

	var _tokenExpander2 = _interopRequireDefault(_tokenExpander);

	var _scope = __webpack_require__(31);

	var _ramda = __webpack_require__(26);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Expander = function () {
	  function Expander(context) {
	    _classCallCheck(this, Expander);

	    this.context = context;
	  }

	  _createClass(Expander, [{
	    key: "expand",
	    value: function expand(stxl) {
	      var tokenExpander = new _tokenExpander2.default(this.context);
	      var termExpander = new _termExpander2.default(this.context);

	      return _.pipe(_.bind(tokenExpander.expand, tokenExpander), _.map(function (t) {
	        return termExpander.expand(t);
	      }))(stxl);
	    }
	  }]);

	  return Expander;
	}();

	exports.default = Expander;
	//# sourceMappingURL=expander.js.map


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(9);

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _scope = __webpack_require__(31);

	var _applyScopeInParamsReducer = __webpack_require__(32);

	var _applyScopeInParamsReducer2 = _interopRequireDefault(_applyScopeInParamsReducer);

	var _shiftReducer = __webpack_require__(34);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _expander = __webpack_require__(29);

	var _expander2 = _interopRequireDefault(_expander);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _serializer = __webpack_require__(38);

	var _enforester = __webpack_require__(44);

	var _errors = __webpack_require__(12);

	var _templateProcessor = __webpack_require__(48);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TermExpander = function () {
	  function TermExpander(context) {
	    _classCallCheck(this, TermExpander);

	    this.context = context;
	  }

	  _createClass(TermExpander, [{
	    key: "expand",
	    value: function expand(term) {
	      var field = "expand" + term.type;
	      if (typeof this[field] === 'function') {
	        return this[field](term);
	      }
	      (0, _errors.assert)(false, "expand not implemented yet for: " + term.type);
	    }
	  }, {
	    key: "expandTemplateExpression",
	    value: function expandTemplateExpression(term) {
	      return new _terms2.default('TemplateExpression', {
	        tag: term.tag,
	        elements: term.elements.toArray()
	      });
	    }
	  }, {
	    key: "expandBreakStatement",
	    value: function expandBreakStatement(term) {
	      return new _terms2.default('BreakStatement', {
	        label: term.label ? term.label.val() : null
	      });
	    }
	  }, {
	    key: "expandDoWhileStatement",
	    value: function expandDoWhileStatement(term) {
	      return new _terms2.default('DoWhileStatement', {
	        body: this.expand(term.body),
	        test: this.expand(term.test)
	      });
	    }
	  }, {
	    key: "expandWithStatement",
	    value: function expandWithStatement(term) {
	      return new _terms2.default('WithStatement', {
	        body: this.expand(term.body),
	        object: this.expand(term.object)
	      });
	    }
	  }, {
	    key: "expandDebuggerStatement",
	    value: function expandDebuggerStatement(term) {
	      return term;
	    }
	  }, {
	    key: "expandContinueStatement",
	    value: function expandContinueStatement(term) {
	      return new _terms2.default('ContinueStatement', {
	        label: term.label ? term.label.val() : null
	      });
	    }
	  }, {
	    key: "expandSwitchStatementWithDefault",
	    value: function expandSwitchStatementWithDefault(term) {
	      var _this = this;

	      return new _terms2.default('SwitchStatementWithDefault', {
	        discriminant: this.expand(term.discriminant),
	        preDefaultCases: term.preDefaultCases.map(function (c) {
	          return _this.expand(c);
	        }).toArray(),
	        defaultCase: this.expand(term.defaultCase),
	        postDefaultCases: term.postDefaultCases.map(function (c) {
	          return _this.expand(c);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandComputedMemberExpression",
	    value: function expandComputedMemberExpression(term) {
	      return new _terms2.default('ComputedMemberExpression', {
	        object: this.expand(term.object),
	        expression: this.expand(term.expression)
	      });
	    }
	  }, {
	    key: "expandSwitchStatement",
	    value: function expandSwitchStatement(term) {
	      var _this2 = this;

	      return new _terms2.default('SwitchStatement', {
	        discriminant: this.expand(term.discriminant),
	        cases: term.cases.map(function (c) {
	          return _this2.expand(c);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandFormalParameters",
	    value: function expandFormalParameters(term) {
	      var _this3 = this;

	      var rest = term.rest == null ? null : this.expand(term.rest);
	      return new _terms2.default('FormalParameters', {
	        items: term.items.map(function (i) {
	          return _this3.expand(i);
	        }),
	        rest: rest
	      });
	    }
	  }, {
	    key: "expandArrowExpression",
	    value: function expandArrowExpression(term) {
	      var _this4 = this;

	      var body = undefined;
	      if (_immutable.List.isList(term.body)) {
	        (function () {
	          var scope = (0, _scope.freshScope)('fun');
	          _this4.context.currentScope.push(scope);
	          var expander = new _expander2.default(_this4.context);

	          body = new _terms2.default("FunctionBody", {
	            directives: (0, _immutable.List)(),
	            statements: expander.expand(term.body.map(function (s) {
	              return s.addScope(scope, _this4.context.bindings);
	            }))
	          });
	          _this4.context.currentScope.pop();
	        })();
	      } else {
	        body = this.expand(term.body);
	      }
	      return new _terms2.default('ArrowExpression', {
	        // TODO: hygiene
	        params: this.expand(term.params),
	        body: body
	      });
	    }
	  }, {
	    key: "expandSwitchDefault",
	    value: function expandSwitchDefault(term) {
	      var _this5 = this;

	      return new _terms2.default('SwitchDefault', {
	        consequent: term.consequent.map(function (c) {
	          return _this5.expand(c);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandSwitchCase",
	    value: function expandSwitchCase(term) {
	      var _this6 = this;

	      return new _terms2.default('SwitchCase', {
	        test: this.expand(term.test),
	        consequent: term.consequent.map(function (c) {
	          return _this6.expand(c);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandForInStatement",
	    value: function expandForInStatement(term) {
	      return new _terms2.default('ForInStatement', {
	        left: this.expand(term.left),
	        right: this.expand(term.right),
	        body: this.expand(term.body)
	      });
	    }
	  }, {
	    key: "expandTryCatchStatement",
	    value: function expandTryCatchStatement(term) {
	      return new _terms2.default('TryCatchStatement', {
	        body: this.expand(term.body),
	        catchClause: this.expand(term.catchClause)
	      });
	    }
	  }, {
	    key: "expandTryFinallyStatement",
	    value: function expandTryFinallyStatement(term) {
	      var catchClause = term.catchClause == null ? null : this.expand(term.catchClause);
	      return new _terms2.default('TryFinallyStatement', {
	        body: this.expand(term.body),
	        catchClause: catchClause,
	        finalizer: this.expand(term.finalizer)
	      });
	    }
	  }, {
	    key: "expandCatchClause",
	    value: function expandCatchClause(term) {
	      return new _terms2.default('CatchClause', {
	        binding: this.expand(term.binding),
	        body: this.expand(term.body)
	      });
	    }
	  }, {
	    key: "expandThrowStatement",
	    value: function expandThrowStatement(term) {
	      return new _terms2.default('ThrowStatement', {
	        expression: this.expand(term.expression)
	      });
	    }
	  }, {
	    key: "expandForOfStatement",
	    value: function expandForOfStatement(term) {
	      return new _terms2.default('ForOfStatement', {
	        left: this.expand(term.left),
	        right: this.expand(term.right),
	        body: this.expand(term.body)
	      });
	    }
	  }, {
	    key: "expandBindingIdentifier",
	    value: function expandBindingIdentifier(term) {
	      return term;
	    }
	  }, {
	    key: "expandBindingPropertyIdentifier",
	    value: function expandBindingPropertyIdentifier(term) {
	      return term;
	    }
	  }, {
	    key: "expandBindingPropertyProperty",
	    value: function expandBindingPropertyProperty(term) {
	      return new _terms2.default('BindingPropertyProperty', {
	        name: this.expand(term.name),
	        binding: this.expand(term.binding)
	      });
	    }
	  }, {
	    key: "expandComputedPropertyName",
	    value: function expandComputedPropertyName(term) {
	      return new _terms2.default('ComputedPropertyName', {
	        expression: this.expand(term.expression)
	      });
	    }
	  }, {
	    key: "expandObjectBinding",
	    value: function expandObjectBinding(term) {
	      var _this7 = this;

	      return new _terms2.default('ObjectBinding', {
	        properties: term.properties.map(function (t) {
	          return _this7.expand(t);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandArrayBinding",
	    value: function expandArrayBinding(term) {
	      var _this8 = this;

	      var restElement = term.restElement == null ? null : this.expand(term.restElement);
	      return new _terms2.default('ArrayBinding', {
	        elements: term.elements.map(function (t) {
	          return t == null ? null : _this8.expand(t);
	        }).toArray(),
	        restElement: restElement
	      });
	    }
	  }, {
	    key: "expandBindingWithDefault",
	    value: function expandBindingWithDefault(term) {
	      return new _terms2.default('BindingWithDefault', {
	        binding: this.expand(term.binding),
	        init: this.expand(term.init)
	      });
	    }
	  }, {
	    key: "expandShorthandProperty",
	    value: function expandShorthandProperty(term) {
	      return new _terms2.default('ShorthandProperty', {
	        name: term.name.val()
	      });
	    }
	  }, {
	    key: "expandForStatement",
	    value: function expandForStatement(term) {
	      var init = term.init == null ? null : this.expand(term.init);
	      var test = term.test == null ? null : this.expand(term.test);
	      var update = term.update == null ? null : this.expand(term.update);
	      var body = this.expand(term.body);
	      return new _terms2.default('ForStatement', { init: init, test: test, update: update, body: body });
	    }
	  }, {
	    key: "expandYieldExpression",
	    value: function expandYieldExpression(term) {
	      var expr = term.expression == null ? null : this.expand(term.expression);
	      return new _terms2.default('YieldExpression', {
	        expression: expr
	      });
	    }
	  }, {
	    key: "expandWhileStatement",
	    value: function expandWhileStatement(term) {
	      return new _terms2.default('WhileStatement', {
	        test: this.expand(term.test),
	        body: this.expand(term.body)
	      });
	    }
	  }, {
	    key: "expandIfStatement",
	    value: function expandIfStatement(term) {
	      var consequent = term.consequent == null ? null : this.expand(term.consequent);
	      var alternate = term.alternate == null ? null : this.expand(term.alternate);
	      return new _terms2.default('IfStatement', {
	        test: this.expand(term.test),
	        consequent: consequent,
	        alternate: alternate
	      });
	    }
	  }, {
	    key: "expandBlockStatement",
	    value: function expandBlockStatement(term) {
	      return new _terms2.default('BlockStatement', {
	        block: this.expand(term.block)
	      });
	    }
	  }, {
	    key: "expandBlock",
	    value: function expandBlock(term) {
	      var _this9 = this;

	      return new _terms2.default('Block', {
	        statements: term.statements.map(function (s) {
	          return _this9.expand(s);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandVariableDeclarationStatement",
	    value: function expandVariableDeclarationStatement(term) {
	      return new _terms2.default('VariableDeclarationStatement', {
	        declaration: this.expand(term.declaration)
	      });
	    }
	  }, {
	    key: "expandReturnStatement",
	    value: function expandReturnStatement(term) {
	      if (term.expression == null) {
	        return term;
	      }
	      return new _terms2.default("ReturnStatement", {
	        expression: this.expand(term.expression)
	      });
	    }
	  }, {
	    key: "expandClassDeclaration",
	    value: function expandClassDeclaration(term) {
	      var _this10 = this;

	      return new _terms2.default('ClassDeclaration', {
	        name: term.name == null ? null : this.expand(term.name),
	        super: term.super == null ? null : this.expand(term.super),
	        elements: term.elements.map(function (el) {
	          return _this10.expand(el);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandClassExpression",
	    value: function expandClassExpression(term) {
	      var _this11 = this;

	      return new _terms2.default('ClassExpression', {
	        name: term.name == null ? null : this.expand(term.name),
	        super: term.super == null ? null : this.expand(term.super),
	        elements: term.elements.map(function (el) {
	          return _this11.expand(el);
	        }).toArray()
	      });
	    }
	  }, {
	    key: "expandClassElement",
	    value: function expandClassElement(term) {
	      return new _terms2.default('ClassElement', {
	        isStatic: term.isStatic,
	        method: this.expand(term.method)
	      });
	    }
	  }, {
	    key: "expandThisExpression",
	    value: function expandThisExpression(term) {
	      return term;
	    }
	  }, {
	    key: "expandSyntaxTemplate",
	    value: function expandSyntaxTemplate(term) {
	      var _this12 = this;

	      var expander = new _expander2.default(this.context);
	      var r = (0, _templateProcessor.processTemplate)(term.template.inner());
	      var str = _syntax2.default.fromString(_serializer.serializer.write(r.template));
	      var callee = new _terms2.default('IdentifierExpression', { name: _syntax2.default.fromIdentifier('syntaxTemplate') });

	      var expandedInterps = r.interp.map(function (i) {
	        var enf = new _enforester.Enforester(i, (0, _immutable.List)(), _this12.context);
	        return _this12.expand(enf.enforest('expression'));
	      });

	      var args = _immutable.List.of(new _terms2.default('LiteralStringExpression', { value: str })).concat(expandedInterps);

	      return new _terms2.default('CallExpression', {
	        callee: callee, arguments: args
	      });
	    }
	  }, {
	    key: "expandSyntaxQuote",
	    value: function expandSyntaxQuote(term) {
	      var str = new _terms2.default("LiteralStringExpression", {
	        value: _syntax2.default.fromString(_serializer.serializer.write(term.name))
	      });

	      return new _terms2.default("TemplateExpression", {
	        tag: term.template.tag,
	        elements: term.template.elements.push(str).push(new _terms2.default('TemplateElement', {
	          rawValue: ''
	        })).toArray()
	      });
	    }
	  }, {
	    key: "expandStaticMemberExpression",
	    value: function expandStaticMemberExpression(term) {
	      return new _terms2.default("StaticMemberExpression", {
	        object: this.expand(term.object),
	        property: term.property
	      });
	    }
	  }, {
	    key: "expandArrayExpression",
	    value: function expandArrayExpression(term) {
	      var _this13 = this;

	      return new _terms2.default("ArrayExpression", {
	        elements: term.elements.map(function (t) {
	          return t == null ? t : _this13.expand(t);
	        })
	      });
	    }
	  }, {
	    key: "expandImport",
	    value: function expandImport(term) {
	      return term;
	    }
	  }, {
	    key: "expandImportNamespace",
	    value: function expandImportNamespace(term) {
	      return term;
	    }
	  }, {
	    key: "expandExport",
	    value: function expandExport(term) {
	      return new _terms2.default('Export', {
	        declaration: this.expand(term.declaration)
	      });
	    }
	  }, {
	    key: "expandExportDefault",
	    value: function expandExportDefault(term) {
	      return new _terms2.default('ExportDefault', {
	        body: this.expand(term.body)
	      });
	    }
	  }, {
	    key: "expandExportFrom",
	    value: function expandExportFrom(term) {
	      return term;
	    }
	  }, {
	    key: "expandExportAllFrom",
	    value: function expandExportAllFrom(term) {
	      return term;
	    }
	  }, {
	    key: "expandExportSpecifier",
	    value: function expandExportSpecifier(term) {
	      return term;
	    }
	  }, {
	    key: "expandStaticPropertyName",
	    value: function expandStaticPropertyName(term) {
	      return term;
	    }
	  }, {
	    key: "expandDataProperty",
	    value: function expandDataProperty(term) {
	      return new _terms2.default("DataProperty", {
	        name: this.expand(term.name),
	        expression: this.expand(term.expression)
	      });
	    }
	  }, {
	    key: "expandObjectExpression",
	    value: function expandObjectExpression(term) {
	      var _this14 = this;

	      return new _terms2.default("ObjectExpression", {
	        properties: term.properties.map(function (t) {
	          return _this14.expand(t);
	        })
	      });
	    }
	  }, {
	    key: "expandVariableDeclarator",
	    value: function expandVariableDeclarator(term) {
	      var init = term.init == null ? null : this.expand(term.init);
	      return new _terms2.default("VariableDeclarator", {
	        binding: this.expand(term.binding),
	        init: init
	      });
	    }
	  }, {
	    key: "expandVariableDeclaration",
	    value: function expandVariableDeclaration(term) {
	      var _this15 = this;

	      return new _terms2.default("VariableDeclaration", {
	        kind: term.kind,
	        declarators: term.declarators.map(function (d) {
	          return _this15.expand(d);
	        })
	      });
	    }
	  }, {
	    key: "expandParenthesizedExpression",
	    value: function expandParenthesizedExpression(term) {
	      if (term.inner.size === 0) {
	        throw new Error("unexpected end of input");
	      }
	      var enf = new _enforester.Enforester(term.inner, (0, _immutable.List)(), this.context);
	      var lookahead = enf.peek();
	      var t = enf.enforestExpression();
	      if (t == null || enf.rest.size > 0) {
	        throw enf.createError(lookahead, "unexpected syntax");
	      }
	      return this.expand(t);
	    }
	  }, {
	    key: "expandUnaryExpression",
	    value: function expandUnaryExpression(term) {
	      return new _terms2.default('UnaryExpression', {
	        operator: term.operator,
	        operand: this.expand(term.operand)
	      });
	    }
	  }, {
	    key: "expandUpdateExpression",
	    value: function expandUpdateExpression(term) {
	      return new _terms2.default('UpdateExpression', {
	        isPrefix: term.isPrefix,
	        operator: term.operator,
	        operand: this.expand(term.operand)
	      });
	    }
	  }, {
	    key: "expandBinaryExpression",
	    value: function expandBinaryExpression(term) {
	      var left = this.expand(term.left);
	      var right = this.expand(term.right);
	      return new _terms2.default("BinaryExpression", {
	        left: left,
	        operator: term.operator,
	        right: right
	      });
	    }
	  }, {
	    key: "expandConditionalExpression",
	    value: function expandConditionalExpression(term) {
	      return new _terms2.default('ConditionalExpression', {
	        test: this.expand(term.test),
	        consequent: this.expand(term.consequent),
	        alternate: this.expand(term.alternate)
	      });
	    }
	  }, {
	    key: "expandNewExpression",
	    value: function expandNewExpression(term) {
	      var _this16 = this;

	      var callee = this.expand(term.callee);
	      var enf = new _enforester.Enforester(term.arguments, (0, _immutable.List)(), this.context);
	      var args = enf.enforestArgumentList().map(function (arg) {
	        return _this16.expand(arg);
	      });
	      return new _terms2.default('NewExpression', {
	        callee: callee,
	        arguments: args.toArray()
	      });
	    }
	  }, {
	    key: "expandCallExpression",
	    value: function expandCallExpression(term) {
	      var _this17 = this;

	      var callee = this.expand(term.callee);
	      var enf = new _enforester.Enforester(term.arguments, (0, _immutable.List)(), this.context);
	      var args = enf.enforestArgumentList().map(function (arg) {
	        return _this17.expand(arg);
	      });
	      return new _terms2.default("CallExpression", {
	        callee: callee,
	        arguments: args
	      });
	    }
	  }, {
	    key: "expandSpreadElement",
	    value: function expandSpreadElement(term) {
	      return new _terms2.default('SpreadElement', {
	        expression: this.expand(term.expression)
	      });
	    }
	  }, {
	    key: "expandExpressionStatement",
	    value: function expandExpressionStatement(term) {
	      var child = this.expand(term.expression);
	      return new _terms2.default("ExpressionStatement", {
	        expression: child
	      });
	    }
	  }, {
	    key: "expandLabeledStatement",
	    value: function expandLabeledStatement(term) {
	      return new _terms2.default('LabeledStatement', {
	        label: term.label.val(),
	        body: this.expand(term.body)
	      });
	    }
	  }, {
	    key: "doFunctionExpansion",
	    value: function doFunctionExpansion(term, type) {
	      var _this18 = this;

	      var scope = (0, _scope.freshScope)("fun");
	      var markedBody = term.body.map(function (b) {
	        return b.addScope(scope, _this18.context.bindings);
	      });
	      var red = new _applyScopeInParamsReducer2.default(scope, this.context);
	      var params = undefined;
	      if (type !== 'Getter' && type !== 'Setter') {
	        params = red.transform(term.params);
	        params = this.expand(params);
	      }
	      this.context.currentScope.push(scope);
	      var expander = new _expander2.default(this.context);

	      var bodyTerm = new _terms2.default("FunctionBody", {
	        directives: (0, _immutable.List)(),
	        statements: expander.expand(markedBody)
	      });
	      this.context.currentScope.pop();

	      if (type === 'Getter') {
	        return new _terms2.default(type, {
	          name: this.expand(term.name),
	          body: bodyTerm
	        });
	      } else if (type === 'Setter') {
	        return new _terms2.default(type, {
	          name: this.expand(term.name),
	          param: term.param,
	          body: bodyTerm
	        });
	      }
	      return new _terms2.default(type, {
	        name: term.name,
	        isGenerator: term.isGenerator,
	        params: params,
	        body: bodyTerm
	      });
	    }
	  }, {
	    key: "expandMethod",
	    value: function expandMethod(term) {
	      return this.doFunctionExpansion(term, 'Method');
	    }
	  }, {
	    key: "expandSetter",
	    value: function expandSetter(term) {
	      return this.doFunctionExpansion(term, 'Setter');
	    }
	  }, {
	    key: "expandGetter",
	    value: function expandGetter(term) {
	      return this.doFunctionExpansion(term, 'Getter');
	    }
	  }, {
	    key: "expandFunctionDeclaration",
	    value: function expandFunctionDeclaration(term) {
	      return this.doFunctionExpansion(term, "FunctionDeclaration");
	    }
	  }, {
	    key: "expandFunctionExpression",
	    value: function expandFunctionExpression(term) {
	      return this.doFunctionExpansion(term, "FunctionExpression");
	    }
	  }, {
	    key: "expandAssignmentExpression",
	    value: function expandAssignmentExpression(term) {
	      return new _terms2.default("AssignmentExpression", {
	        binding: this.expand(term.binding),
	        expression: this.expand(term.expression)
	      });
	    }
	  }, {
	    key: "expandEmptyStatement",
	    value: function expandEmptyStatement(term) {
	      return term;
	    }
	  }, {
	    key: "expandLiteralBooleanExpression",
	    value: function expandLiteralBooleanExpression(term) {
	      return term;
	    }
	  }, {
	    key: "expandLiteralNumericExpression",
	    value: function expandLiteralNumericExpression(term) {
	      return term;
	    }
	  }, {
	    key: "expandLiteralInfinityExpression",
	    value: function expandLiteralInfinityExpression(term) {
	      return term;
	    }
	  }, {
	    key: "expandIdentifierExpression",
	    value: function expandIdentifierExpression(term) {
	      var trans = this.context.env.get(term.name.resolve());
	      if (trans) {
	        return new _terms2.default("IdentifierExpression", {
	          name: trans.id
	        });
	      }
	      return term;
	    }
	  }, {
	    key: "expandLiteralNullExpression",
	    value: function expandLiteralNullExpression(term) {
	      return term;
	    }
	  }, {
	    key: "expandLiteralStringExpression",
	    value: function expandLiteralStringExpression(term) {
	      return term;
	    }
	  }, {
	    key: "expandLiteralRegExpExpression",
	    value: function expandLiteralRegExpExpression(term) {
	      return term;
	    }
	  }]);

	  return TermExpander;
	}();

	exports.default = TermExpander;
	//# sourceMappingURL=term-expander.js.map


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.freshScope = freshScope;
	exports.Scope = Scope;

	var _errors = __webpack_require__(12);

	var _symbol = __webpack_require__(11);

	var scopeIndex = 0;

	function freshScope() {
	  var name = arguments.length <= 0 || arguments[0] === undefined ? "scope" : arguments[0];

	  scopeIndex++;
	  return (0, _symbol.Symbol)(name + "_" + scopeIndex);
	};

	function Scope(name) {
	  return (0, _symbol.Symbol)(name);
	}
	//# sourceMappingURL=scope.js.map


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _symbol = __webpack_require__(11);

	var _transforms = __webpack_require__(33);

	var _errors = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ScopeApplyingReducer = function () {
	  function ScopeApplyingReducer(scope, context) {
	    var phase = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	    _classCallCheck(this, ScopeApplyingReducer);

	    this.context = context;
	    this.scope = scope;
	    this.phase = phase;
	  }

	  _createClass(ScopeApplyingReducer, [{
	    key: "transform",
	    value: function transform(term) {
	      var field = "transform" + term.type;
	      if (typeof this[field] === 'function') {
	        return this[field](term);
	      }
	      (0, _errors.assert)(false, "transform not implemented yet for: " + term.type);
	    }
	  }, {
	    key: "transformFormalParameters",
	    value: function transformFormalParameters(term) {
	      var _this = this;

	      var rest = term.rest == null ? null : this.transform(term.rest);
	      return new _terms2.default('FormalParameters', {
	        items: term.items.map(function (it) {
	          return _this.transform(it);
	        }),
	        rest: rest
	      });
	    }
	  }, {
	    key: "transformBindingWithDefault",
	    value: function transformBindingWithDefault(term) {
	      return new _terms2.default('BindingWithDefault', {
	        binding: this.transform(term.binding),
	        init: term.init
	      });
	    }
	  }, {
	    key: "transformObjectBinding",
	    value: function transformObjectBinding(term) {
	      var _this2 = this;

	      return new _terms2.default('ObjectBinding', {
	        properties: term.properties.map(function (prop) {
	          return _this2.transform(prop);
	        })
	      });
	    }
	  }, {
	    key: "transformBindingPropertyIdentifier",
	    value: function transformBindingPropertyIdentifier(term) {
	      return new _terms2.default('BindingPropertyIdentifier', {
	        binding: this.transform(term.binding),
	        init: term.init
	      });
	    }
	  }, {
	    key: "transformBindingPropertyProperty",
	    value: function transformBindingPropertyProperty(term) {
	      return new _terms2.default('BindingPropertyProperty', {
	        name: term.name,
	        binding: this.transform(term.binding)
	      });
	    }
	  }, {
	    key: "transformArrayBinding",
	    value: function transformArrayBinding(term) {
	      var _this3 = this;

	      return new _terms2.default('ArrayBinding', {
	        elements: term.elements.map(function (el) {
	          return _this3.transform(el);
	        }),
	        restElement: term.restElement == null ? null : this.transform(term.restElement)
	      });
	    }
	  }, {
	    key: "transformBindingIdentifier",
	    value: function transformBindingIdentifier(term) {
	      var name = term.name.addScope(this.scope, this.context.bindings);
	      var newBinding = (0, _symbol.gensym)(name.val());

	      this.context.env.set(newBinding.toString(), new _transforms.VarBindingTransform(name));
	      this.context.bindings.add(name, {
	        binding: newBinding,
	        phase: this.phase,
	        skipDup: true
	      });

	      return new _terms2.default("BindingIdentifier", { name: name });
	    }
	  }]);

	  return ScopeApplyingReducer;
	}();

	exports.default = ScopeApplyingReducer;
	//# sourceMappingURL=apply-scope-in-params-reducer.js.map


/***/ },
/* 33 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FunctionDeclTransform = exports.FunctionDeclTransform = function FunctionDeclTransform() {
	  _classCallCheck(this, FunctionDeclTransform);
	};

	var VariableDeclTransform = exports.VariableDeclTransform = function VariableDeclTransform() {
	  _classCallCheck(this, VariableDeclTransform);
	};

	var NewTransform = exports.NewTransform = function NewTransform() {
	  _classCallCheck(this, NewTransform);
	};

	var ThrowTransform = exports.ThrowTransform = function ThrowTransform() {
	  _classCallCheck(this, ThrowTransform);
	};

	var LetDeclTransform = exports.LetDeclTransform = function LetDeclTransform() {
	  _classCallCheck(this, LetDeclTransform);
	};

	var ConstDeclTransform = exports.ConstDeclTransform = function ConstDeclTransform() {
	  _classCallCheck(this, ConstDeclTransform);
	};

	var TryTransform = exports.TryTransform = function TryTransform() {
	  _classCallCheck(this, TryTransform);
	};

	var WhileTransform = exports.WhileTransform = function WhileTransform() {
	  _classCallCheck(this, WhileTransform);
	};

	var IfTransform = exports.IfTransform = function IfTransform() {
	  _classCallCheck(this, IfTransform);
	};

	var ForTransform = exports.ForTransform = function ForTransform() {
	  _classCallCheck(this, ForTransform);
	};

	var SwitchTransform = exports.SwitchTransform = function SwitchTransform() {
	  _classCallCheck(this, SwitchTransform);
	};

	var BreakTransform = exports.BreakTransform = function BreakTransform() {
	  _classCallCheck(this, BreakTransform);
	};

	var ContinueTransform = exports.ContinueTransform = function ContinueTransform() {
	  _classCallCheck(this, ContinueTransform);
	};

	var DoTransform = exports.DoTransform = function DoTransform() {
	  _classCallCheck(this, DoTransform);
	};

	var WithTransform = exports.WithTransform = function WithTransform() {
	  _classCallCheck(this, WithTransform);
	};

	var DebuggerTransform = exports.DebuggerTransform = function DebuggerTransform() {
	  _classCallCheck(this, DebuggerTransform);
	};

	var SyntaxrecDeclTransform = exports.SyntaxrecDeclTransform = function SyntaxrecDeclTransform() {
	  _classCallCheck(this, SyntaxrecDeclTransform);
	};

	var SyntaxDeclTransform = exports.SyntaxDeclTransform = function SyntaxDeclTransform() {
	  _classCallCheck(this, SyntaxDeclTransform);
	};

	var SyntaxQuoteTransform = exports.SyntaxQuoteTransform = function SyntaxQuoteTransform() {
	  _classCallCheck(this, SyntaxQuoteTransform);
	};

	var ReturnStatementTransform = exports.ReturnStatementTransform = function ReturnStatementTransform() {
	  _classCallCheck(this, ReturnStatementTransform);
	};

	var VarBindingTransform = exports.VarBindingTransform = function VarBindingTransform(id) {
	  _classCallCheck(this, VarBindingTransform);

	  this.id = id;
	};

	var CompiletimeTransform = exports.CompiletimeTransform = function CompiletimeTransform(value) {
	  _classCallCheck(this, CompiletimeTransform);

	  this.value = value;
	};
	//# sourceMappingURL=transforms.js.map


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MonoidalReducer = exports.CloneReducer = undefined;
	exports.default = reduce;

	var _cloneReducer = __webpack_require__(35);

	Object.defineProperty(exports, "CloneReducer", {
	  enumerable: true,
	  get: function get() {
	    return _cloneReducer.default;
	  }
	});

	var _monoidalReducer = __webpack_require__(37);

	Object.defineProperty(exports, "MonoidalReducer", {
	  enumerable: true,
	  get: function get() {
	    return _monoidalReducer.default;
	  }
	});

	var _shiftSpec = __webpack_require__(36);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function transformWithSpec(transformer, node, spec) {
	  switch (spec.typeName) {
	    case "Enum":
	    case "String":
	    case "Number":
	    case "Boolean":
	    case "SourceSpan":
	      return node;
	    case "Const":
	      // TODO: checked version
	      return transformWithSpec(transformer, node, spec.argument);
	    case "Maybe":
	      return node && transformWithSpec(transformer, node, spec.argument);
	    case "List":
	      return node.map(function (e) {
	        return transformWithSpec(transformer, e, spec.argument);
	      });
	    case "Union":
	      // TODO: checked version
	      return transformWithSpec(transformer, node, _shiftSpec2.default[node.type]);
	    default:
	      var state = {};
	      spec.fields.forEach(function (field) {
	        var v = transformWithSpec(transformer, node[field.name], field.type);
	        state[field.name] = v == null ? null : v;
	      });
	      if (typeof transformer["reduce" + node.type] !== "function") {
	        throw new Error("Encountered " + node.type + ", which the provided reducer does not handle.");
	      }
	      return transformer["reduce" + node.type](node, state);
	  }
	} /**
	   * Copyright 2014 Shape Security, Inc.
	   *
	   * Licensed under the Apache License, Version 2.0 (the "License")
	   * you may not use this file except in compliance with the License.
	   * You may obtain a copy of the License at
	   *
	   *     http://www.apache.org/licenses/LICENSE-2.0
	   *
	   * Unless required by applicable law or agreed to in writing, software
	   * distributed under the License is distributed on an "AS IS" BASIS,
	   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   * See the License for the specific language governing permissions and
	   * limitations under the License.
	   */

	function reduce(reducer, reducible) {
	  return transformWithSpec(reducer, reducible, _shiftSpec2.default[reducible.type]);
	}

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shiftSpec = __webpack_require__(36);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                           * you may not use this file except in compliance with the License.
	                                                                                                                                                           * You may obtain a copy of the License at
	                                                                                                                                                           *
	                                                                                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                           *
	                                                                                                                                                           * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                           * See the License for the specific language governing permissions and
	                                                                                                                                                           * limitations under the License.
	                                                                                                                                                           */

	var CloneReducer = function CloneReducer() {
	  _classCallCheck(this, CloneReducer);
	};

	exports.default = CloneReducer;

	for (var typeName in _shiftSpec2.default) {
	  var type = _shiftSpec2.default[typeName];
	  Object.defineProperty(CloneReducer.prototype, "reduce" + typeName, {
	    value: function value(node, state) {
	      return state;
	    }
	  });
	}

/***/ },
/* 36 */
/***/ function(module, exports) {

	// Generated by src/generate-spec.js. 

	/**
	 * Copyright 2015 Shape Security, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	// Hack to make Babel6 import this as a module.
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// Meta data generated from spec.idl.
	exports.default = (function() {
	  var SPEC = {};

	  var BOOLEAN = { typeName: "Boolean" };
	  var DOUBLE = { typeName: "Number" };
	  var STRING = { typeName: "String" };
	  function Maybe(arg) { return { typeName: "Maybe", argument: arg }; }
	  function List(arg) { return { typeName: "List", argument: arg }; }
	  function Const(arg) { return { typeName: "Const", argument: arg }; }
	  function Union() { return { typeName: "Union", arguments: [].slice.call(arguments, 0) }; }

	  var TYPE_INDICATOR = {
	    typeName: "Enum",
	    values: ["ArrayBinding", "ArrayExpression", "ArrowExpression", "AssignmentExpression", "BinaryExpression", "BindingIdentifier", "BindingProperty", "BindingPropertyIdentifier", "BindingPropertyProperty", "BindingWithDefault", "Block", "BlockStatement", "BreakStatement", "CallExpression", "CatchClause", "Class", "ClassDeclaration", "ClassElement", "ClassExpression", "CompoundAssignmentExpression", "ComputedMemberExpression", "ComputedPropertyName", "ConditionalExpression", "ContinueStatement", "DataProperty", "DebuggerStatement", "Directive", "DoWhileStatement", "EmptyStatement", "Export", "ExportAllFrom", "ExportDeclaration", "ExportDefault", "ExportFrom", "ExportSpecifier", "Expression", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FormalParameters", "Function", "FunctionBody", "FunctionDeclaration", "FunctionExpression", "Getter", "IdentifierExpression", "IfStatement", "Import", "ImportDeclaration", "ImportNamespace", "ImportSpecifier", "IterationStatement", "LabeledStatement", "LiteralBooleanExpression", "LiteralInfinityExpression", "LiteralNullExpression", "LiteralNumericExpression", "LiteralRegExpExpression", "LiteralStringExpression", "MemberExpression", "Method", "MethodDefinition", "Module", "NamedObjectProperty", "NewExpression", "NewTargetExpression", "Node", "ObjectBinding", "ObjectExpression", "ObjectProperty", "PropertyName", "ReturnStatement", "Script", "Setter", "ShorthandProperty", "SourceLocation", "SourceSpan", "SpreadElement", "Statement", "StaticMemberExpression", "StaticPropertyName", "Super", "SwitchCase", "SwitchDefault", "SwitchStatement", "SwitchStatementWithDefault", "TemplateElement", "TemplateExpression", "ThisExpression", "ThrowStatement", "TryCatchStatement", "TryFinallyStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarationStatement", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "YieldGeneratorExpression"]
	  };

	  var VariableDeclarationKind = {
	    typeName: "Enum",
	    values: ["var", "let", "const"]
	  };

	  var CompoundAssignmentOperator = {
	    typeName: "Enum",
	    values: ["+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="]
	  };

	  var BinaryOperator = {
	    typeName: "Enum",
	    values: ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", ",", "||", "&&", "|", "^", "&"]
	  };

	  var UnaryOperator = {
	    typeName: "Enum",
	    values: ["+", "-", "!", "~", "typeof", "void", "delete"]
	  };

	  var UpdateOperator = {
	    typeName: "Enum",
	    values: ["++", "--"]
	  };

	  var SourceLocation = SPEC.SourceLocation = {};
	  var SourceSpan = SPEC.SourceSpan = {};
	  var BindingWithDefault = SPEC.BindingWithDefault = {};
	  var BindingIdentifier = SPEC.BindingIdentifier = {};
	  var ArrayBinding = SPEC.ArrayBinding = {};
	  var ObjectBinding = SPEC.ObjectBinding = {};
	  var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
	  var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
	  var ClassExpression = SPEC.ClassExpression = {};
	  var ClassDeclaration = SPEC.ClassDeclaration = {};
	  var ClassElement = SPEC.ClassElement = {};
	  var Module = SPEC.Module = {};
	  var Import = SPEC.Import = {};
	  var ImportNamespace = SPEC.ImportNamespace = {};
	  var ImportSpecifier = SPEC.ImportSpecifier = {};
	  var ExportAllFrom = SPEC.ExportAllFrom = {};
	  var ExportFrom = SPEC.ExportFrom = {};
	  var Export = SPEC.Export = {};
	  var ExportDefault = SPEC.ExportDefault = {};
	  var ExportSpecifier = SPEC.ExportSpecifier = {};
	  var Method = SPEC.Method = {};
	  var Getter = SPEC.Getter = {};
	  var Setter = SPEC.Setter = {};
	  var DataProperty = SPEC.DataProperty = {};
	  var ShorthandProperty = SPEC.ShorthandProperty = {};
	  var ComputedPropertyName = SPEC.ComputedPropertyName = {};
	  var StaticPropertyName = SPEC.StaticPropertyName = {};
	  var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
	  var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
	  var LiteralNullExpression = SPEC.LiteralNullExpression = {};
	  var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
	  var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
	  var LiteralStringExpression = SPEC.LiteralStringExpression = {};
	  var ArrayExpression = SPEC.ArrayExpression = {};
	  var ArrowExpression = SPEC.ArrowExpression = {};
	  var AssignmentExpression = SPEC.AssignmentExpression = {};
	  var BinaryExpression = SPEC.BinaryExpression = {};
	  var CallExpression = SPEC.CallExpression = {};
	  var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
	  var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
	  var ConditionalExpression = SPEC.ConditionalExpression = {};
	  var FunctionExpression = SPEC.FunctionExpression = {};
	  var IdentifierExpression = SPEC.IdentifierExpression = {};
	  var NewExpression = SPEC.NewExpression = {};
	  var NewTargetExpression = SPEC.NewTargetExpression = {};
	  var ObjectExpression = SPEC.ObjectExpression = {};
	  var UnaryExpression = SPEC.UnaryExpression = {};
	  var StaticMemberExpression = SPEC.StaticMemberExpression = {};
	  var TemplateExpression = SPEC.TemplateExpression = {};
	  var ThisExpression = SPEC.ThisExpression = {};
	  var UpdateExpression = SPEC.UpdateExpression = {};
	  var YieldExpression = SPEC.YieldExpression = {};
	  var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};
	  var BlockStatement = SPEC.BlockStatement = {};
	  var BreakStatement = SPEC.BreakStatement = {};
	  var ContinueStatement = SPEC.ContinueStatement = {};
	  var DebuggerStatement = SPEC.DebuggerStatement = {};
	  var DoWhileStatement = SPEC.DoWhileStatement = {};
	  var EmptyStatement = SPEC.EmptyStatement = {};
	  var ExpressionStatement = SPEC.ExpressionStatement = {};
	  var ForInStatement = SPEC.ForInStatement = {};
	  var ForOfStatement = SPEC.ForOfStatement = {};
	  var ForStatement = SPEC.ForStatement = {};
	  var IfStatement = SPEC.IfStatement = {};
	  var LabeledStatement = SPEC.LabeledStatement = {};
	  var ReturnStatement = SPEC.ReturnStatement = {};
	  var SwitchStatement = SPEC.SwitchStatement = {};
	  var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
	  var ThrowStatement = SPEC.ThrowStatement = {};
	  var TryCatchStatement = SPEC.TryCatchStatement = {};
	  var TryFinallyStatement = SPEC.TryFinallyStatement = {};
	  var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
	  var WhileStatement = SPEC.WhileStatement = {};
	  var WithStatement = SPEC.WithStatement = {};
	  var Block = SPEC.Block = {};
	  var CatchClause = SPEC.CatchClause = {};
	  var Directive = SPEC.Directive = {};
	  var FormalParameters = SPEC.FormalParameters = {};
	  var FunctionBody = SPEC.FunctionBody = {};
	  var FunctionDeclaration = SPEC.FunctionDeclaration = {};
	  var Script = SPEC.Script = {};
	  var SpreadElement = SPEC.SpreadElement = {};
	  var Super = SPEC.Super = {};
	  var SwitchCase = SPEC.SwitchCase = {};
	  var SwitchDefault = SPEC.SwitchDefault = {};
	  var TemplateElement = SPEC.TemplateElement = {};
	  var VariableDeclaration = SPEC.VariableDeclaration = {};
	  var VariableDeclarator = SPEC.VariableDeclarator = {};

	  var Class = Union(ClassExpression, ClassDeclaration);
	  var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
	  var ExportDeclaration = Union(ExportAllFrom, ExportFrom, Export, ExportDefault);
	  var ImportDeclaration = Union(Import, ImportNamespace);
	  var MethodDefinition = Union(Method, Getter, Setter);
	  var NamedObjectProperty = Union(MethodDefinition, DataProperty);
	  var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
	  var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
	  var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
	  var Expression = Union(MemberExpression, ClassExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, NewExpression, NewTargetExpression, ObjectExpression, UnaryExpression, TemplateExpression, ThisExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
	  var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
	  var Statement = Union(IterationStatement, ClassDeclaration, BlockStatement, BreakStatement, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, IfStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement, FunctionDeclaration);
	  var Node = Union(Statement, Expression, PropertyName, ObjectProperty, ImportDeclaration, ExportDeclaration, BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding, BindingProperty, ClassElement, Module, ImportSpecifier, ExportSpecifier, Block, CatchClause, Directive, FormalParameters, FunctionBody, Script, SpreadElement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator);
	  var Function = Union(FunctionExpression, FunctionDeclaration);

	  SourceLocation.typeName = "SourceLocation";
	  SourceLocation.fields = [
	    { name: "line", type: DOUBLE },
	    { name: "column", type: DOUBLE },
	    { name: "offset", type: DOUBLE },
	  ];

	  SourceSpan.typeName = "SourceSpan";
	  SourceSpan.fields = [
	    { name: "source", type: Maybe(STRING) },
	    { name: "start", type: SourceLocation },
	    { name: "end", type: SourceLocation },
	  ];

	  BindingWithDefault.typeName = "BindingWithDefault";
	  BindingWithDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingWithDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "init", type: Expression },
	  ];

	  BindingIdentifier.typeName = "BindingIdentifier";
	  BindingIdentifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingIdentifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  ArrayBinding.typeName = "ArrayBinding";
	  ArrayBinding.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayBinding" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "elements", type: List(Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault))) },
	    { name: "restElement", type: Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)) },
	  ];

	  ObjectBinding.typeName = "ObjectBinding";
	  ObjectBinding.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectBinding" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "properties", type: List(BindingProperty) },
	  ];

	  BindingPropertyIdentifier.typeName = "BindingPropertyIdentifier";
	  BindingPropertyIdentifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyIdentifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: BindingIdentifier },
	    { name: "init", type: Maybe(Expression) },
	  ];

	  BindingPropertyProperty.typeName = "BindingPropertyProperty";
	  BindingPropertyProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
	  ];

	  ClassExpression.typeName = "ClassExpression";
	  ClassExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(BindingIdentifier) },
	    { name: "super", type: Maybe(Expression) },
	    { name: "elements", type: List(ClassElement) },
	  ];

	  ClassDeclaration.typeName = "ClassDeclaration";
	  ClassDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: BindingIdentifier },
	    { name: "super", type: Maybe(Expression) },
	    { name: "elements", type: List(ClassElement) },
	  ];

	  ClassElement.typeName = "ClassElement";
	  ClassElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isStatic", type: BOOLEAN },
	    { name: "method", type: MethodDefinition },
	  ];

	  Module.typeName = "Module";
	  Module.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Module" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "items", type: List(Union(ImportDeclaration, ExportDeclaration, Statement)) },
	  ];

	  Import.typeName = "Import";
	  Import.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Import" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
	    { name: "namedImports", type: List(ImportSpecifier) },
	  ];

	  ImportNamespace.typeName = "ImportNamespace";
	  ImportNamespace.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportNamespace" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
	    { name: "namespaceBinding", type: BindingIdentifier },
	  ];

	  ImportSpecifier.typeName = "ImportSpecifier";
	  ImportSpecifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportSpecifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(STRING) },
	    { name: "binding", type: BindingIdentifier },
	  ];

	  ExportAllFrom.typeName = "ExportAllFrom";
	  ExportAllFrom.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportAllFrom" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	  ];

	  ExportFrom.typeName = "ExportFrom";
	  ExportFrom.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportFrom" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "namedExports", type: List(ExportSpecifier) },
	    { name: "moduleSpecifier", type: Maybe(STRING) },
	  ];

	  Export.typeName = "Export";
	  Export.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Export" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "declaration", type: Union(FunctionDeclaration, ClassDeclaration, VariableDeclaration) },
	  ];

	  ExportDefault.typeName = "ExportDefault";
	  ExportDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Union(FunctionDeclaration, ClassDeclaration, Expression) },
	  ];

	  ExportSpecifier.typeName = "ExportSpecifier";
	  ExportSpecifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportSpecifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(STRING) },
	    { name: "exportedName", type: STRING },
	  ];

	  Method.typeName = "Method";
	  Method.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Method" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  Getter.typeName = "Getter";
	  Getter.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Getter" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "body", type: FunctionBody },
	  ];

	  Setter.typeName = "Setter";
	  Setter.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Setter" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "param", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
	    { name: "body", type: FunctionBody },
	  ];

	  DataProperty.typeName = "DataProperty";
	  DataProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DataProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "expression", type: Expression },
	  ];

	  ShorthandProperty.typeName = "ShorthandProperty";
	  ShorthandProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ShorthandProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  ComputedPropertyName.typeName = "ComputedPropertyName";
	  ComputedPropertyName.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedPropertyName" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  StaticPropertyName.typeName = "StaticPropertyName";
	  StaticPropertyName.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticPropertyName" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: STRING },
	  ];

	  LiteralBooleanExpression.typeName = "LiteralBooleanExpression";
	  LiteralBooleanExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralBooleanExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: BOOLEAN },
	  ];

	  LiteralInfinityExpression.typeName = "LiteralInfinityExpression";
	  LiteralInfinityExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralInfinityExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  LiteralNullExpression.typeName = "LiteralNullExpression";
	  LiteralNullExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNullExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  LiteralNumericExpression.typeName = "LiteralNumericExpression";
	  LiteralNumericExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNumericExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: DOUBLE },
	  ];

	  LiteralRegExpExpression.typeName = "LiteralRegExpExpression";
	  LiteralRegExpExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralRegExpExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "pattern", type: STRING },
	    { name: "flags", type: STRING },
	  ];

	  LiteralStringExpression.typeName = "LiteralStringExpression";
	  LiteralStringExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralStringExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: STRING },
	  ];

	  ArrayExpression.typeName = "ArrayExpression";
	  ArrayExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "elements", type: List(Maybe(Union(SpreadElement, Expression))) },
	  ];

	  ArrowExpression.typeName = "ArrowExpression";
	  ArrowExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrowExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: Union(FunctionBody, Expression) },
	  ];

	  AssignmentExpression.typeName = "AssignmentExpression";
	  AssignmentExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "expression", type: Expression },
	  ];

	  BinaryExpression.typeName = "BinaryExpression";
	  BinaryExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BinaryExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: BinaryOperator },
	    { name: "left", type: Expression },
	    { name: "right", type: Expression },
	  ];

	  CallExpression.typeName = "CallExpression";
	  CallExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CallExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "callee", type: Union(Expression, Super) },
	    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
	  ];

	  CompoundAssignmentExpression.typeName = "CompoundAssignmentExpression";
	  CompoundAssignmentExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CompoundAssignmentExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: CompoundAssignmentOperator },
	    { name: "binding", type: Union(BindingIdentifier, MemberExpression) },
	    { name: "expression", type: Expression },
	  ];

	  ComputedMemberExpression.typeName = "ComputedMemberExpression";
	  ComputedMemberExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Union(Expression, Super) },
	    { name: "expression", type: Expression },
	  ];

	  ConditionalExpression.typeName = "ConditionalExpression";
	  ConditionalExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ConditionalExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: Expression },
	    { name: "alternate", type: Expression },
	  ];

	  FunctionExpression.typeName = "FunctionExpression";
	  FunctionExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "name", type: Maybe(BindingIdentifier) },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  IdentifierExpression.typeName = "IdentifierExpression";
	  IdentifierExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "IdentifierExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  NewExpression.typeName = "NewExpression";
	  NewExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "NewExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "callee", type: Expression },
	    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
	  ];

	  NewTargetExpression.typeName = "NewTargetExpression";
	  NewTargetExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "NewTargetExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  ObjectExpression.typeName = "ObjectExpression";
	  ObjectExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "properties", type: List(ObjectProperty) },
	  ];

	  UnaryExpression.typeName = "UnaryExpression";
	  UnaryExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "UnaryExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: UnaryOperator },
	    { name: "operand", type: Expression },
	  ];

	  StaticMemberExpression.typeName = "StaticMemberExpression";
	  StaticMemberExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Union(Expression, Super) },
	    { name: "property", type: STRING },
	  ];

	  TemplateExpression.typeName = "TemplateExpression";
	  TemplateExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "tag", type: Maybe(Expression) },
	    { name: "elements", type: List(Union(Expression, TemplateElement)) },
	  ];

	  ThisExpression.typeName = "ThisExpression";
	  ThisExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ThisExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  UpdateExpression.typeName = "UpdateExpression";
	  UpdateExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "UpdateExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isPrefix", type: BOOLEAN },
	    { name: "operator", type: UpdateOperator },
	    { name: "operand", type: Union(BindingIdentifier, MemberExpression) },
	  ];

	  YieldExpression.typeName = "YieldExpression";
	  YieldExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Maybe(Expression) },
	  ];

	  YieldGeneratorExpression.typeName = "YieldGeneratorExpression";
	  YieldGeneratorExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldGeneratorExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  BlockStatement.typeName = "BlockStatement";
	  BlockStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BlockStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "block", type: Block },
	  ];

	  BreakStatement.typeName = "BreakStatement";
	  BreakStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BreakStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: Maybe(STRING) },
	  ];

	  ContinueStatement.typeName = "ContinueStatement";
	  ContinueStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ContinueStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: Maybe(STRING) },
	  ];

	  DebuggerStatement.typeName = "DebuggerStatement";
	  DebuggerStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DebuggerStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  DoWhileStatement.typeName = "DoWhileStatement";
	  DoWhileStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DoWhileStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Statement },
	    { name: "test", type: Expression },
	  ];

	  EmptyStatement.typeName = "EmptyStatement";
	  EmptyStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "EmptyStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  ExpressionStatement.typeName = "ExpressionStatement";
	  ExpressionStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExpressionStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  ForInStatement.typeName = "ForInStatement";
	  ForInStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForInStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "right", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  ForOfStatement.typeName = "ForOfStatement";
	  ForOfStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForOfStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "right", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  ForStatement.typeName = "ForStatement";
	  ForStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "init", type: Maybe(Union(VariableDeclaration, Expression)) },
	    { name: "test", type: Maybe(Expression) },
	    { name: "update", type: Maybe(Expression) },
	    { name: "body", type: Statement },
	  ];

	  IfStatement.typeName = "IfStatement";
	  IfStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "IfStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: Statement },
	    { name: "alternate", type: Maybe(Statement) },
	  ];

	  LabeledStatement.typeName = "LabeledStatement";
	  LabeledStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LabeledStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: STRING },
	    { name: "body", type: Statement },
	  ];

	  ReturnStatement.typeName = "ReturnStatement";
	  ReturnStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ReturnStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Maybe(Expression) },
	  ];

	  SwitchStatement.typeName = "SwitchStatement";
	  SwitchStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "discriminant", type: Expression },
	    { name: "cases", type: List(SwitchCase) },
	  ];

	  SwitchStatementWithDefault.typeName = "SwitchStatementWithDefault";
	  SwitchStatementWithDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatementWithDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "discriminant", type: Expression },
	    { name: "preDefaultCases", type: List(SwitchCase) },
	    { name: "defaultCase", type: SwitchDefault },
	    { name: "postDefaultCases", type: List(SwitchCase) },
	  ];

	  ThrowStatement.typeName = "ThrowStatement";
	  ThrowStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ThrowStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  TryCatchStatement.typeName = "TryCatchStatement";
	  TryCatchStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TryCatchStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Block },
	    { name: "catchClause", type: CatchClause },
	  ];

	  TryFinallyStatement.typeName = "TryFinallyStatement";
	  TryFinallyStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TryFinallyStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Block },
	    { name: "catchClause", type: Maybe(CatchClause) },
	    { name: "finalizer", type: Block },
	  ];

	  VariableDeclarationStatement.typeName = "VariableDeclarationStatement";
	  VariableDeclarationStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarationStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "declaration", type: VariableDeclaration },
	  ];

	  WhileStatement.typeName = "WhileStatement";
	  WhileStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "WhileStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  WithStatement.typeName = "WithStatement";
	  WithStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "WithStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  Block.typeName = "Block";
	  Block.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Block" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "statements", type: List(Statement) },
	  ];

	  CatchClause.typeName = "CatchClause";
	  CatchClause.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CatchClause" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "body", type: Block },
	  ];

	  Directive.typeName = "Directive";
	  Directive.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Directive" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "rawValue", type: STRING },
	  ];

	  FormalParameters.typeName = "FormalParameters";
	  FormalParameters.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FormalParameters" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "items", type: List(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)) },
	    { name: "rest", type: Maybe(BindingIdentifier) },
	  ];

	  FunctionBody.typeName = "FunctionBody";
	  FunctionBody.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionBody" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "statements", type: List(Statement) },
	  ];

	  FunctionDeclaration.typeName = "FunctionDeclaration";
	  FunctionDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "name", type: BindingIdentifier },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  Script.typeName = "Script";
	  Script.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Script" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "statements", type: List(Statement) },
	  ];

	  SpreadElement.typeName = "SpreadElement";
	  SpreadElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SpreadElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  Super.typeName = "Super";
	  Super.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Super" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  SwitchCase.typeName = "SwitchCase";
	  SwitchCase.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchCase" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: List(Statement) },
	  ];

	  SwitchDefault.typeName = "SwitchDefault";
	  SwitchDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "consequent", type: List(Statement) },
	  ];

	  TemplateElement.typeName = "TemplateElement";
	  TemplateElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "rawValue", type: STRING },
	  ];

	  VariableDeclaration.typeName = "VariableDeclaration";
	  VariableDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "kind", type: VariableDeclarationKind },
	    { name: "declarators", type: List(VariableDeclarator) },
	  ];

	  VariableDeclarator.typeName = "VariableDeclarator";
	  VariableDeclarator.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarator" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "init", type: Maybe(Expression) },
	  ];

	  return SPEC;
	}());


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                   * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                   * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                   * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                   * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                   * limitations under the License.
	                                                                                                                                                                                                                                                   */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shiftSpec = __webpack_require__(36);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var methods = {};

	function id(x) {
	  return x;
	}

	function handlerForFieldOfType(type) {
	  switch (type.typeName) {
	    case "Enum":
	    case "String":
	    case "Boolean":
	    case "Number":
	    case "SourceSpan":
	      return null;
	    case "Const":
	      return handlerForFieldOfType(type.argument);
	    case "Maybe":
	      {
	        var _ret = function () {
	          var subHandler = handlerForFieldOfType(type.argument);
	          if (subHandler == null) return {
	              v: null
	            };
	          return {
	            v: function v(t) {
	              return t == null ? this.identity : subHandler.call(this, t);
	            }
	          };
	        }();

	        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
	      }
	    case "List":
	      {
	        var _ret2 = function () {
	          var subHandler = handlerForFieldOfType(type.argument);
	          if (subHandler == null) return {
	              v: null
	            };
	          return {
	            v: function v(t) {
	              var _this = this;

	              return this.fold(t.map(function (x) {
	                return subHandler.call(_this, x);
	              }));
	            }
	          };
	        }();

	        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
	      }
	    default:
	      return id;
	  }
	}

	var _loop = function _loop(typeName) {
	  var type = _shiftSpec2.default[typeName];

	  var handlers = {};
	  type.fields.forEach(function (field) {
	    var handler = handlerForFieldOfType(field.type);
	    if (handler != null) handlers[field.name] = handler;
	  });
	  var fieldNames = Object.keys(handlers);

	  methods["reduce" + typeName] = {
	    value: function value(node, state) {
	      var _this3 = this;

	      return this.fold(fieldNames.map(function (fieldName) {
	        return handlers[fieldName].call(_this3, state[fieldName]);
	      }));
	    }
	  };
	};

	for (var typeName in _shiftSpec2.default) {
	  _loop(typeName);
	}

	var MonoidalReducer = function () {
	  function MonoidalReducer(monoid) {
	    _classCallCheck(this, MonoidalReducer);

	    this.identity = monoid.empty();
	    var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
	    this.append = function (a, b) {
	      return concat.call(a, b);
	    };
	  }

	  _createClass(MonoidalReducer, [{
	    key: "fold",
	    value: function fold(list, a) {
	      var _this2 = this;

	      return list.reduce(function (memo, x) {
	        return _this2.append(memo, x);
	      }, a == null ? this.identity : a);
	    }
	  }]);

	  return MonoidalReducer;
	}();

	exports.default = MonoidalReducer;

	Object.defineProperties(MonoidalReducer.prototype, methods);

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.serializer = exports.makeDeserializer = undefined;

	var _transitJs = __webpack_require__(39);

	var _transitJs2 = _interopRequireDefault(_transitJs);

	var _immutable = __webpack_require__(9);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _symbol = __webpack_require__(11);

	var _tokenizer = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var typeMap = [_tokenizer.TokenType.STRING, _tokenizer.TokenType.EOS, _tokenizer.TokenType.LPAREN, _tokenizer.TokenType.RPAREN, _tokenizer.TokenType.LBRACK, _tokenizer.TokenType.RBRACK, _tokenizer.TokenType.LBRACE, _tokenizer.TokenType.RBRACE, _tokenizer.TokenType.COLON, _tokenizer.TokenType.SEMICOLON, _tokenizer.TokenType.PERIOD, _tokenizer.TokenType.ELLIPSIS, _tokenizer.TokenType.ARROW, _tokenizer.TokenType.CONDITIONAL, _tokenizer.TokenType.INC, _tokenizer.TokenType.DEC, _tokenizer.TokenType.ASSIGN, _tokenizer.TokenType.ASSIGN_BIT_OR, _tokenizer.TokenType.ASSIGN_BIT_XOR, _tokenizer.TokenType.ASSIGN_BIT_AND, _tokenizer.TokenType.ASSIGN_SHL, _tokenizer.TokenType.ASSIGN_SHR, _tokenizer.TokenType.ASSIGN_SHR_UNSIGNED, _tokenizer.TokenType.ASSIGN_ADD, _tokenizer.TokenType.ASSIGN_SUB, _tokenizer.TokenType.ASSIGN_MUL, _tokenizer.TokenType.ASSIGN_DIV, _tokenizer.TokenType.ASSIGN_MOD, _tokenizer.TokenType.COMMA, _tokenizer.TokenType.OR, _tokenizer.TokenType.AND, _tokenizer.TokenType.BIT_OR, _tokenizer.TokenType.BIT_XOR, _tokenizer.TokenType.BIT_AND, _tokenizer.TokenType.SHL, _tokenizer.TokenType.SHR, _tokenizer.TokenType.SHR_UNSIGNED, _tokenizer.TokenType.ADD, _tokenizer.TokenType.SUB, _tokenizer.TokenType.MUL, _tokenizer.TokenType.DIV, _tokenizer.TokenType.MOD, _tokenizer.TokenType.EQ, _tokenizer.TokenType.NE, _tokenizer.TokenType.EQ_STRICT, _tokenizer.TokenType.NE_STRICT, _tokenizer.TokenType.LT, _tokenizer.TokenType.GT, _tokenizer.TokenType.LTE, _tokenizer.TokenType.GTE, _tokenizer.TokenType.INSTANCEOF, _tokenizer.TokenType.IN, _tokenizer.TokenType.NOT, _tokenizer.TokenType.BIT_NOT, _tokenizer.TokenType.AWAIT, _tokenizer.TokenType.DELETE, _tokenizer.TokenType.TYPEOF, _tokenizer.TokenType.VOID, _tokenizer.TokenType.BREAK, _tokenizer.TokenType.CASE, _tokenizer.TokenType.CATCH, _tokenizer.TokenType.CLASS, _tokenizer.TokenType.CONTINUE, _tokenizer.TokenType.DEBUGGER, _tokenizer.TokenType.DEFAULT, _tokenizer.TokenType.DO, _tokenizer.TokenType.ELSE, _tokenizer.TokenType.EXPORT, _tokenizer.TokenType.EXTENDS, _tokenizer.TokenType.FINALLY, _tokenizer.TokenType.FOR, _tokenizer.TokenType.FUNCTION, _tokenizer.TokenType.IF, _tokenizer.TokenType.IMPORT, _tokenizer.TokenType.LET, _tokenizer.TokenType.NEW, _tokenizer.TokenType.RETURN, _tokenizer.TokenType.SUPER, _tokenizer.TokenType.SWITCH, _tokenizer.TokenType.THIS, _tokenizer.TokenType.THROW, _tokenizer.TokenType.TRY, _tokenizer.TokenType.VAR, _tokenizer.TokenType.WHILE, _tokenizer.TokenType.WITH, _tokenizer.TokenType.NULL, _tokenizer.TokenType.TRUE, _tokenizer.TokenType.FALSE, _tokenizer.TokenType.YIELD, _tokenizer.TokenType.NUMBER, _tokenizer.TokenType.STRING, _tokenizer.TokenType.REGEXP, _tokenizer.TokenType.IDENTIFIER, _tokenizer.TokenType.CONST, _tokenizer.TokenType.TEMPLATE, _tokenizer.TokenType.ILLEGAL];

	var ListHandler = _transitJs2.default.makeWriteHandler({
	  tag: function tag() {
	    return "array";
	  },
	  rep: function rep(v) {
	    return v;
	  }
	});

	var SyntaxHandler = _transitJs2.default.makeWriteHandler({
	  tag: function tag() {
	    return "stx";
	  },
	  rep: function rep(v) {
	    if (_immutable.List.isList(v.token)) {
	      return [v.token, v.context.scopeset];
	    } else {
	      var t = _transitJs2.default.objectToMap(v.token);
	      t.set("type", typeMap.indexOf(v.token.type));
	      return [t, v.context.scopeset];
	    }
	  }
	});
	var SymbolHandler = _transitJs2.default.makeWriteHandler({
	  tag: function tag() {
	    return "symb";
	  },
	  rep: function rep(v) {
	    return [v.name];
	  }
	});

	var writer = _transitJs2.default.writer("json", {
	  handlers: _transitJs2.default.map([_immutable.List, ListHandler, _syntax2.default, SyntaxHandler, _symbol.SymbolClass, SymbolHandler])
	});

	function makeReader(bindings) {
	  return _transitJs2.default.reader("json", {
	    arrayBuilder: {
	      init: function init(node) {
	        return (0, _immutable.List)().asMutable();
	      },
	      add: function add(ret, val, node) {
	        return ret.push(val);
	      },
	      finalize: function finalize(ret, node) {
	        return ret.asImmutable();
	      },
	      fromArray: function fromArray(arr, node) {
	        return (0, _immutable.List)(arr);
	      }
	    },
	    handlers: {
	      "stx": function stx(rep) {
	        if (_immutable.List.isList(rep[0])) {
	          var token = rep[0];
	          return new _syntax2.default(token, { bindings: bindings, scopeset: rep[1] });
	        } else {
	          var token = _transitJs2.default.mapToObject(rep[0]);
	          token.type = typeMap[rep[0].get("type")];
	          token.slice = rep[0].has("slice") ? _transitJs2.default.mapToObject(rep[0].get("slice")) : undefined;
	          return new _syntax2.default(token, { bindings: bindings, scopeset: rep[1] });
	        }
	      },
	      "symb": function symb(rep) {
	        return (0, _symbol.Symbol)(rep[0]);
	      }
	    }
	  });
	}

	exports.makeDeserializer = makeReader;
	exports.serializer = writer;
	//# sourceMappingURL=serializer.js.map


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// transit-js 0.8.847
	// http://transit-format.org
	// 
	// Copyright 2014 Cognitect. All Rights Reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//      http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS-IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License..
	var COMPILED = !0, goog = goog || {};
	goog.global = this;
	goog.isDef = function(a) {
	  return void 0 !== a;
	};
	goog.exportPath_ = function(a, b, c) {
	  a = a.split(".");
	  c = c || goog.global;
	  a[0] in c || !c.execScript || c.execScript("var " + a[0]);
	  for (var d;a.length && (d = a.shift());) {
	    !a.length && goog.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {};
	  }
	};
	goog.define = function(a, b) {
	  var c = b;
	  COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));
	  goog.exportPath_(a, c);
	};
	goog.DEBUG = !0;
	goog.LOCALE = "en";
	goog.TRUSTED_SITE = !0;
	goog.STRICT_MODE_COMPATIBLE = !1;
	goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
	goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
	goog.provide = function(a) {
	  if (!COMPILED && goog.isProvided_(a)) {
	    throw Error('Namespace "' + a + '" already declared.');
	  }
	  goog.constructNamespace_(a);
	};
	goog.constructNamespace_ = function(a, b) {
	  if (!COMPILED) {
	    delete goog.implicitNamespaces_[a];
	    for (var c = a;(c = c.substring(0, c.lastIndexOf("."))) && !goog.getObjectByName(c);) {
	      goog.implicitNamespaces_[c] = !0;
	    }
	  }
	  goog.exportPath_(a, b);
	};
	goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
	goog.module = function(a) {
	  if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) {
	    throw Error("Invalid module identifier");
	  }
	  if (!goog.isInModuleLoader_()) {
	    throw Error("Module " + a + " has been loaded incorrectly.");
	  }
	  if (goog.moduleLoaderState_.moduleName) {
	    throw Error("goog.module may only be called once per module.");
	  }
	  goog.moduleLoaderState_.moduleName = a;
	  if (!COMPILED) {
	    if (goog.isProvided_(a)) {
	      throw Error('Namespace "' + a + '" already declared.');
	    }
	    delete goog.implicitNamespaces_[a];
	  }
	};
	goog.module.get = function(a) {
	  return goog.module.getInternal_(a);
	};
	goog.module.getInternal_ = function(a) {
	  if (!COMPILED) {
	    return goog.isProvided_(a) ? a in goog.loadedModules_ ? goog.loadedModules_[a] : goog.getObjectByName(a) : null;
	  }
	};
	goog.moduleLoaderState_ = null;
	goog.isInModuleLoader_ = function() {
	  return null != goog.moduleLoaderState_;
	};
	goog.module.declareTestMethods = function() {
	  if (!goog.isInModuleLoader_()) {
	    throw Error("goog.module.declareTestMethods must be called from within a goog.module");
	  }
	  goog.moduleLoaderState_.declareTestMethods = !0;
	};
	goog.module.declareLegacyNamespace = function() {
	  if (!COMPILED && !goog.isInModuleLoader_()) {
	    throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
	  }
	  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
	    throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
	  }
	  goog.moduleLoaderState_.declareLegacyNamespace = !0;
	};
	goog.setTestOnly = function(a) {
	  if (goog.DISALLOW_TEST_ONLY_CODE) {
	    throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
	  }
	};
	goog.forwardDeclare = function(a) {
	};
	COMPILED || (goog.isProvided_ = function(a) {
	  return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));
	}, goog.implicitNamespaces_ = {"goog.module":!0});
	goog.getObjectByName = function(a, b) {
	  for (var c = a.split("."), d = b || goog.global, e;e = c.shift();) {
	    if (goog.isDefAndNotNull(d[e])) {
	      d = d[e];
	    } else {
	      return null;
	    }
	  }
	  return d;
	};
	goog.globalize = function(a, b) {
	  var c = b || goog.global, d;
	  for (d in a) {
	    c[d] = a[d];
	  }
	};
	goog.addDependency = function(a, b, c, d) {
	  if (goog.DEPENDENCIES_ENABLED) {
	    var e;
	    a = a.replace(/\\/g, "/");
	    for (var f = goog.dependencies_, g = 0;e = b[g];g++) {
	      f.nameToPath[e] = a, f.pathIsModule[a] = !!d;
	    }
	    for (d = 0;b = c[d];d++) {
	      a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0;
	    }
	  }
	};
	goog.ENABLE_DEBUG_LOADER = !0;
	goog.logToConsole_ = function(a) {
	  goog.global.console && goog.global.console.error(a);
	};
	goog.require = function(a) {
	  if (!COMPILED) {
	    goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);
	    if (goog.isProvided_(a)) {
	      return goog.isInModuleLoader_() ? goog.module.getInternal_(a) : null;
	    }
	    if (goog.ENABLE_DEBUG_LOADER) {
	      var b = goog.getPathFromDeps_(a);
	      if (b) {
	        return goog.included_[b] = !0, goog.writeScripts_(), null;
	      }
	    }
	    a = "goog.require could not find: " + a;
	    goog.logToConsole_(a);
	    throw Error(a);
	  }
	};
	goog.basePath = "";
	goog.nullFunction = function() {
	};
	goog.abstractMethod = function() {
	  throw Error("unimplemented abstract method");
	};
	goog.addSingletonGetter = function(a) {
	  a.getInstance = function() {
	    if (a.instance_) {
	      return a.instance_;
	    }
	    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
	    return a.instance_ = new a;
	  };
	};
	goog.instantiatedSingletons_ = [];
	goog.LOAD_MODULE_USING_EVAL = !0;
	goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
	goog.loadedModules_ = {};
	goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
	goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {pathIsModule:{}, nameToPath:{}, requires:{}, visited:{}, written:{}, deferred:{}}, goog.inHtmlDocument_ = function() {
	  var a = goog.global.document;
	  return "undefined" != typeof a && "write" in a;
	}, goog.findBasePath_ = function() {
	  if (goog.global.CLOSURE_BASE_PATH) {
	    goog.basePath = goog.global.CLOSURE_BASE_PATH;
	  } else {
	    if (goog.inHtmlDocument_()) {
	      for (var a = goog.global.document.getElementsByTagName("SCRIPT"), b = a.length - 1;0 <= b;--b) {
	        var c = a[b].src, d = c.lastIndexOf("?"), d = -1 == d ? c.length : d;
	        if ("base.js" == c.substr(d - 7, 7)) {
	          goog.basePath = c.substr(0, d - 7);
	          break;
	        }
	      }
	    }
	  }
	}, goog.importScript_ = function(a, b) {
	  (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);
	}, goog.IS_OLD_IE_ = !goog.global.atob && goog.global.document && goog.global.document.all, goog.importModule_ = function(a) {
	  goog.importScript_("", 'goog.retrieveAndExecModule_("' + a + '");') && (goog.dependencies_.written[a] = !0);
	}, goog.queuedModules_ = [], goog.wrapModule_ = function(a, b) {
	  return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? "goog.loadModule(" + goog.global.JSON.stringify(b + "\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n";
	}, goog.loadQueuedModules_ = function() {
	  var a = goog.queuedModules_.length;
	  if (0 < a) {
	    var b = goog.queuedModules_;
	    goog.queuedModules_ = [];
	    for (var c = 0;c < a;c++) {
	      goog.maybeProcessDeferredPath_(b[c]);
	    }
	  }
	}, goog.maybeProcessDeferredDep_ = function(a) {
	  goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));
	}, goog.isDeferredModule_ = function(a) {
	  return (a = goog.getPathFromDeps_(a)) && goog.dependencies_.pathIsModule[a] ? goog.basePath + a in goog.dependencies_.deferred : !1;
	}, goog.allDepsAreAvailable_ = function(a) {
	  if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_.requires) {
	    for (var b in goog.dependencies_.requires[a]) {
	      if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) {
	        return !1;
	      }
	    }
	  }
	  return !0;
	}, goog.maybeProcessDeferredPath_ = function(a) {
	  if (a in goog.dependencies_.deferred) {
	    var b = goog.dependencies_.deferred[a];
	    delete goog.dependencies_.deferred[a];
	    goog.globalEval(b);
	  }
	}, goog.loadModule = function(a) {
	  var b = goog.moduleLoaderState_;
	  try {
	    goog.moduleLoaderState_ = {moduleName:void 0, declareTestMethods:!1};
	    var c;
	    if (goog.isFunction(a)) {
	      c = a.call(goog.global, {});
	    } else {
	      if (goog.isString(a)) {
	        c = goog.loadModuleFromSource_.call(goog.global, a);
	      } else {
	        throw Error("Invalid module definition");
	      }
	    }
	    var d = goog.moduleLoaderState_.moduleName;
	    if (!goog.isString(d) || !d) {
	      throw Error('Invalid module name "' + d + '"');
	    }
	    goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && Object.seal(c);
	    goog.loadedModules_[d] = c;
	    if (goog.moduleLoaderState_.declareTestMethods) {
	      for (var e in c) {
	        if (0 === e.indexOf("test", 0) || "tearDown" == e || "setUp" == e || "setUpPage" == e || "tearDownPage" == e) {
	          goog.global[e] = c[e];
	        }
	      }
	    }
	  } finally {
	    goog.moduleLoaderState_ = b;
	  }
	}, goog.loadModuleFromSource_ = function(a) {
	  eval(a);
	  return {};
	}, goog.writeScriptSrcNode_ = function(a) {
	  goog.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>');
	}, goog.appendScriptSrcNode_ = function(a) {
	  var b = goog.global.document, c = b.createElement("script");
	  c.type = "text/javascript";
	  c.src = a;
	  c.defer = !1;
	  c.async = !1;
	  b.head.appendChild(c);
	}, goog.writeScriptTag_ = function(a, b) {
	  if (goog.inHtmlDocument_()) {
	    var c = goog.global.document;
	    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
	      if (/\bdeps.js$/.test(a)) {
	        return !1;
	      }
	      throw Error('Cannot write "' + a + '" after document load');
	    }
	    var d = goog.IS_OLD_IE_;
	    void 0 === b ? d ? (d = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + d + ">\x3c/script>")) : goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? goog.appendScriptSrcNode_(a) : goog.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + b + "\x3c/script>");
	    return !0;
	  }
	  return !1;
	}, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function(a, b) {
	  "complete" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();
	  return !0;
	}, goog.writeScripts_ = function() {
	  function a(e) {
	    if (!(e in d.written)) {
	      if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires)) {
	        for (var f in d.requires[e]) {
	          if (!goog.isProvided_(f)) {
	            if (f in d.nameToPath) {
	              a(d.nameToPath[f]);
	            } else {
	              throw Error("Undefined nameToPath for " + f);
	            }
	          }
	        }
	      }
	      e in c || (c[e] = !0, b.push(e));
	    }
	  }
	  var b = [], c = {}, d = goog.dependencies_, e;
	  for (e in goog.included_) {
	    d.written[e] || a(e);
	  }
	  for (var f = 0;f < b.length;f++) {
	    e = b[f], goog.dependencies_.written[e] = !0;
	  }
	  var g = goog.moduleLoaderState_;
	  goog.moduleLoaderState_ = null;
	  for (f = 0;f < b.length;f++) {
	    if (e = b[f]) {
	      d.pathIsModule[e] ? goog.importModule_(goog.basePath + e) : goog.importScript_(goog.basePath + e);
	    } else {
	      throw goog.moduleLoaderState_ = g, Error("Undefined script input");
	    }
	  }
	  goog.moduleLoaderState_ = g;
	}, goog.getPathFromDeps_ = function(a) {
	  return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
	}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
	goog.normalizePath_ = function(a) {
	  a = a.split("/");
	  for (var b = 0;b < a.length;) {
	    "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
	  }
	  return a.join("/");
	};
	goog.loadFileSync_ = function(a) {
	  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
	    return goog.global.CLOSURE_LOAD_FILE_SYNC(a);
	  }
	  var b = new goog.global.XMLHttpRequest;
	  b.open("get", a, !1);
	  b.send();
	  return b.responseText;
	};
	goog.retrieveAndExecModule_ = function(a) {
	  if (!COMPILED) {
	    var b = a;
	    a = goog.normalizePath_(a);
	    var c = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_, d = goog.loadFileSync_(a);
	    if (null != d) {
	      d = goog.wrapModule_(a, d), goog.IS_OLD_IE_ ? (goog.dependencies_.deferred[b] = d, goog.queuedModules_.push(b)) : c(a, d);
	    } else {
	      throw Error("load of " + a + "failed");
	    }
	  }
	};
	goog.typeOf = function(a) {
	  var b = typeof a;
	  if ("object" == b) {
	    if (a) {
	      if (a instanceof Array) {
	        return "array";
	      }
	      if (a instanceof Object) {
	        return b;
	      }
	      var c = Object.prototype.toString.call(a);
	      if ("[object Window]" == c) {
	        return "object";
	      }
	      if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
	        return "array";
	      }
	      if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
	        return "function";
	      }
	    } else {
	      return "null";
	    }
	  } else {
	    if ("function" == b && "undefined" == typeof a.call) {
	      return "object";
	    }
	  }
	  return b;
	};
	goog.isNull = function(a) {
	  return null === a;
	};
	goog.isDefAndNotNull = function(a) {
	  return null != a;
	};
	goog.isArray = function(a) {
	  return "array" == goog.typeOf(a);
	};
	goog.isArrayLike = function(a) {
	  var b = goog.typeOf(a);
	  return "array" == b || "object" == b && "number" == typeof a.length;
	};
	goog.isDateLike = function(a) {
	  return goog.isObject(a) && "function" == typeof a.getFullYear;
	};
	goog.isString = function(a) {
	  return "string" == typeof a;
	};
	goog.isBoolean = function(a) {
	  return "boolean" == typeof a;
	};
	goog.isNumber = function(a) {
	  return "number" == typeof a;
	};
	goog.isFunction = function(a) {
	  return "function" == goog.typeOf(a);
	};
	goog.isObject = function(a) {
	  var b = typeof a;
	  return "object" == b && null != a || "function" == b;
	};
	goog.getUid = function(a) {
	  return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
	};
	goog.hasUid = function(a) {
	  return !!a[goog.UID_PROPERTY_];
	};
	goog.removeUid = function(a) {
	  "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
	  try {
	    delete a[goog.UID_PROPERTY_];
	  } catch (b) {
	  }
	};
	goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
	goog.uidCounter_ = 0;
	goog.getHashCode = goog.getUid;
	goog.removeHashCode = goog.removeUid;
	goog.cloneObject = function(a) {
	  var b = goog.typeOf(a);
	  if ("object" == b || "array" == b) {
	    if (a.clone) {
	      return a.clone();
	    }
	    var b = "array" == b ? [] : {}, c;
	    for (c in a) {
	      b[c] = goog.cloneObject(a[c]);
	    }
	    return b;
	  }
	  return a;
	};
	goog.bindNative_ = function(a, b, c) {
	  return a.call.apply(a.bind, arguments);
	};
	goog.bindJs_ = function(a, b, c) {
	  if (!a) {
	    throw Error();
	  }
	  if (2 < arguments.length) {
	    var d = Array.prototype.slice.call(arguments, 2);
	    return function() {
	      var c = Array.prototype.slice.call(arguments);
	      Array.prototype.unshift.apply(c, d);
	      return a.apply(b, c);
	    };
	  }
	  return function() {
	    return a.apply(b, arguments);
	  };
	};
	goog.bind = function(a, b, c) {
	  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
	  return goog.bind.apply(null, arguments);
	};
	goog.partial = function(a, b) {
	  var c = Array.prototype.slice.call(arguments, 1);
	  return function() {
	    var b = c.slice();
	    b.push.apply(b, arguments);
	    return a.apply(this, b);
	  };
	};
	goog.mixin = function(a, b) {
	  for (var c in b) {
	    a[c] = b[c];
	  }
	};
	goog.now = goog.TRUSTED_SITE && Date.now || function() {
	  return +new Date;
	};
	goog.globalEval = function(a) {
	  if (goog.global.execScript) {
	    goog.global.execScript(a, "JavaScript");
	  } else {
	    if (goog.global.eval) {
	      if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) {
	        goog.global.eval(a);
	      } else {
	        var b = goog.global.document, c = b.createElement("SCRIPT");
	        c.type = "text/javascript";
	        c.defer = !1;
	        c.appendChild(b.createTextNode(a));
	        b.body.appendChild(c);
	        b.body.removeChild(c);
	      }
	    } else {
	      throw Error("goog.globalEval not available");
	    }
	  }
	};
	goog.evalWorksForGlobals_ = null;
	goog.getCssName = function(a, b) {
	  var c = function(a) {
	    return goog.cssNameMapping_[a] || a;
	  }, d = function(a) {
	    a = a.split("-");
	    for (var b = [], d = 0;d < a.length;d++) {
	      b.push(c(a[d]));
	    }
	    return b.join("-");
	  }, d = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : d : function(a) {
	    return a;
	  };
	  return b ? a + "-" + d(b) : d(a);
	};
	goog.setCssNameMapping = function(a, b) {
	  goog.cssNameMapping_ = a;
	  goog.cssNameMappingStyle_ = b;
	};
	!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
	goog.getMsg = function(a, b) {
	  b && (a = a.replace(/\{\$([^}]+)}/g, function(a, d) {
	    return d in b ? b[d] : a;
	  }));
	  return a;
	};
	goog.getMsgWithFallback = function(a, b) {
	  return a;
	};
	goog.exportSymbol = function(a, b, c) {
	  goog.exportPath_(a, b, c);
	};
	goog.exportProperty = function(a, b, c) {
	  a[b] = c;
	};
	goog.inherits = function(a, b) {
	  function c() {
	  }
	  c.prototype = b.prototype;
	  a.superClass_ = b.prototype;
	  a.prototype = new c;
	  a.prototype.constructor = a;
	  a.base = function(a, c, f) {
	    for (var g = Array(arguments.length - 2), h = 2;h < arguments.length;h++) {
	      g[h - 2] = arguments[h];
	    }
	    return b.prototype[c].apply(a, g);
	  };
	};
	goog.base = function(a, b, c) {
	  var d = arguments.callee.caller;
	  if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) {
	    throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
	  }
	  if (d.superClass_) {
	    for (var e = Array(arguments.length - 1), f = 1;f < arguments.length;f++) {
	      e[f - 1] = arguments[f];
	    }
	    return d.superClass_.constructor.apply(a, e);
	  }
	  e = Array(arguments.length - 2);
	  for (f = 2;f < arguments.length;f++) {
	    e[f - 2] = arguments[f];
	  }
	  for (var f = !1, g = a.constructor;g;g = g.superClass_ && g.superClass_.constructor) {
	    if (g.prototype[b] === d) {
	      f = !0;
	    } else {
	      if (f) {
	        return g.prototype[b].apply(a, e);
	      }
	    }
	  }
	  if (a[b] === d) {
	    return a.constructor.prototype[b].apply(a, e);
	  }
	  throw Error("goog.base called from a method of one name to a method of a different name");
	};
	goog.scope = function(a) {
	  a.call(goog.global);
	};
	COMPILED || (goog.global.COMPILED = COMPILED);
	goog.defineClass = function(a, b) {
	  var c = b.constructor, d = b.statics;
	  c && c != Object.prototype.constructor || (c = function() {
	    throw Error("cannot instantiate an interface (no constructor defined).");
	  });
	  c = goog.defineClass.createSealingConstructor_(c, a);
	  a && goog.inherits(c, a);
	  delete b.constructor;
	  delete b.statics;
	  goog.defineClass.applyProperties_(c.prototype, b);
	  null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));
	  return c;
	};
	goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
	goog.defineClass.createSealingConstructor_ = function(a, b) {
	  if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
	    if (b && b.prototype && b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
	      return a;
	    }
	    var c = function() {
	      var b = a.apply(this, arguments) || this;
	      b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];
	      this.constructor === c && Object.seal(b);
	      return b;
	    };
	    return c;
	  }
	  return a;
	};
	goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog.defineClass.applyProperties_ = function(a, b) {
	  for (var c in b) {
	    Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
	  }
	  for (var d = 0;d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++) {
	    c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
	  }
	};
	goog.tagUnsealableClass = function(a) {
	  !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);
	};
	goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
	goog.math = {};
	goog.math.Long = function(a, b) {
	  this.low_ = a | 0;
	  this.high_ = b | 0;
	};
	goog.math.Long.IntCache_ = {};
	goog.math.Long.fromInt = function(a) {
	  if (-128 <= a && 128 > a) {
	    var b = goog.math.Long.IntCache_[a];
	    if (b) {
	      return b;
	    }
	  }
	  b = new goog.math.Long(a | 0, 0 > a ? -1 : 0);
	  -128 <= a && 128 > a && (goog.math.Long.IntCache_[a] = b);
	  return b;
	};
	goog.math.Long.fromNumber = function(a) {
	  return isNaN(a) || !isFinite(a) ? goog.math.Long.getZero() : a <= -goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMinValue() : a + 1 >= goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMaxValue() : 0 > a ? goog.math.Long.fromNumber(-a).negate() : new goog.math.Long(a % goog.math.Long.TWO_PWR_32_DBL_ | 0, a / goog.math.Long.TWO_PWR_32_DBL_ | 0);
	};
	goog.math.Long.fromBits = function(a, b) {
	  return new goog.math.Long(a, b);
	};
	goog.math.Long.fromString = function(a, b) {
	  if (0 == a.length) {
	    throw Error("number format error: empty string");
	  }
	  var c = b || 10;
	  if (2 > c || 36 < c) {
	    throw Error("radix out of range: " + c);
	  }
	  if ("-" == a.charAt(0)) {
	    return goog.math.Long.fromString(a.substring(1), c).negate();
	  }
	  if (0 <= a.indexOf("-")) {
	    throw Error('number format error: interior "-" character: ' + a);
	  }
	  for (var d = goog.math.Long.fromNumber(Math.pow(c, 8)), e = goog.math.Long.getZero(), f = 0;f < a.length;f += 8) {
	    var g = Math.min(8, a.length - f), h = parseInt(a.substring(f, f + g), c);
	    8 > g ? (g = goog.math.Long.fromNumber(Math.pow(c, g)), e = e.multiply(g).add(goog.math.Long.fromNumber(h))) : (e = e.multiply(d), e = e.add(goog.math.Long.fromNumber(h)));
	  }
	  return e;
	};
	goog.math.Long.TWO_PWR_16_DBL_ = 65536;
	goog.math.Long.getTwoPwr24DBL_ = 16777216;
	goog.math.Long.TWO_PWR_32_DBL_ = goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
	goog.math.Long.TWO_PWR_31_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ / 2;
	goog.math.Long.TWO_PWR_48_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
	goog.math.Long.TWO_PWR_64_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;
	goog.math.Long.TWO_PWR_63_DBL_ = goog.math.Long.TWO_PWR_64_DBL_ / 2;
	goog.math.Long.getZero = function() {
	  goog.math.Long.ZERO_ || (goog.math.Long.ZERO_ = goog.math.Long.fromInt(0));
	  return goog.math.Long.ZERO_;
	};
	goog.math.Long.getOne = function() {
	  goog.math.Long.ONE_ || (goog.math.Long.ONE_ = goog.math.Long.fromInt(1));
	  return goog.math.Long.ONE_;
	};
	goog.math.Long.getNegOne = function() {
	  goog.math.Long.NEG_ONE_ || (goog.math.Long.NEG_ONE_ = goog.math.Long.fromInt(-1));
	  return goog.math.Long.NEG_ONE_;
	};
	goog.math.Long.getMaxValue = function() {
	  goog.math.Long.MAX_VALUE_ || (goog.math.Long.MAX_VALUE_ = goog.math.Long.fromBits(-1, 2147483647));
	  return goog.math.Long.MAX_VALUE_;
	};
	goog.math.Long.getMinValue = function() {
	  goog.math.Long.MIN_VALUE_ || (goog.math.Long.MIN_VALUE_ = goog.math.Long.fromBits(0, -2147483648));
	  return goog.math.Long.MIN_VALUE_;
	};
	goog.math.Long.getTwoPwr24 = function() {
	  goog.math.Long.TWO_PWR_24_ || (goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(16777216));
	  return goog.math.Long.TWO_PWR_24_;
	};
	goog.math.Long.prototype.toInt = function() {
	  return this.low_;
	};
	goog.math.Long.prototype.toNumber = function() {
	  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
	};
	goog.math.Long.prototype.toString = function(a) {
	  a = a || 10;
	  if (2 > a || 36 < a) {
	    throw Error("radix out of range: " + a);
	  }
	  if (this.isZero()) {
	    return "0";
	  }
	  if (this.isNegative()) {
	    if (this.equals(goog.math.Long.getMinValue())) {
	      var b = goog.math.Long.fromNumber(a), c = this.div(b), b = c.multiply(b).subtract(this);
	      return c.toString(a) + b.toInt().toString(a);
	    }
	    return "-" + this.negate().toString(a);
	  }
	  for (var c = goog.math.Long.fromNumber(Math.pow(a, 6)), b = this, d = "";;) {
	    var e = b.div(c), f = b.subtract(e.multiply(c)).toInt().toString(a), b = e;
	    if (b.isZero()) {
	      return f + d;
	    }
	    for (;6 > f.length;) {
	      f = "0" + f;
	    }
	    d = "" + f + d;
	  }
	};
	goog.math.Long.prototype.getHighBits = function() {
	  return this.high_;
	};
	goog.math.Long.prototype.getLowBits = function() {
	  return this.low_;
	};
	goog.math.Long.prototype.getLowBitsUnsigned = function() {
	  return 0 <= this.low_ ? this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
	};
	goog.math.Long.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    return this.equals(goog.math.Long.getMinValue()) ? 64 : this.negate().getNumBitsAbs();
	  }
	  for (var a = 0 != this.high_ ? this.high_ : this.low_, b = 31;0 < b && 0 == (a & 1 << b);b--) {
	  }
	  return 0 != this.high_ ? b + 33 : b + 1;
	};
	goog.math.Long.prototype.isZero = function() {
	  return 0 == this.high_ && 0 == this.low_;
	};
	goog.math.Long.prototype.isNegative = function() {
	  return 0 > this.high_;
	};
	goog.math.Long.prototype.isOdd = function() {
	  return 1 == (this.low_ & 1);
	};
	goog.math.Long.prototype.equals = function(a) {
	  return this.high_ == a.high_ && this.low_ == a.low_;
	};
	goog.math.Long.prototype.notEquals = function(a) {
	  return this.high_ != a.high_ || this.low_ != a.low_;
	};
	goog.math.Long.prototype.lessThan = function(a) {
	  return 0 > this.compare(a);
	};
	goog.math.Long.prototype.lessThanOrEqual = function(a) {
	  return 0 >= this.compare(a);
	};
	goog.math.Long.prototype.greaterThan = function(a) {
	  return 0 < this.compare(a);
	};
	goog.math.Long.prototype.greaterThanOrEqual = function(a) {
	  return 0 <= this.compare(a);
	};
	goog.math.Long.prototype.compare = function(a) {
	  if (this.equals(a)) {
	    return 0;
	  }
	  var b = this.isNegative(), c = a.isNegative();
	  return b && !c ? -1 : !b && c ? 1 : this.subtract(a).isNegative() ? -1 : 1;
	};
	goog.math.Long.prototype.negate = function() {
	  return this.equals(goog.math.Long.getMinValue()) ? goog.math.Long.getMinValue() : this.not().add(goog.math.Long.getOne());
	};
	goog.math.Long.prototype.add = function(a) {
	  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = a.high_ >>> 16, f = a.high_ & 65535, g = a.low_ >>> 16, h;
	  h = 0 + ((this.low_ & 65535) + (a.low_ & 65535));
	  a = 0 + (h >>> 16);
	  a += d + g;
	  d = 0 + (a >>> 16);
	  d += c + f;
	  c = 0 + (d >>> 16);
	  c = c + (b + e) & 65535;
	  return goog.math.Long.fromBits((a & 65535) << 16 | h & 65535, c << 16 | d & 65535);
	};
	goog.math.Long.prototype.subtract = function(a) {
	  return this.add(a.negate());
	};
	goog.math.Long.prototype.multiply = function(a) {
	  if (this.isZero() || a.isZero()) {
	    return goog.math.Long.getZero();
	  }
	  if (this.equals(goog.math.Long.getMinValue())) {
	    return a.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
	  }
	  if (a.equals(goog.math.Long.getMinValue())) {
	    return this.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
	  }
	  if (this.isNegative()) {
	    return a.isNegative() ? this.negate().multiply(a.negate()) : this.negate().multiply(a).negate();
	  }
	  if (a.isNegative()) {
	    return this.multiply(a.negate()).negate();
	  }
	  if (this.lessThan(goog.math.Long.getTwoPwr24()) && a.lessThan(goog.math.Long.getTwoPwr24())) {
	    return goog.math.Long.fromNumber(this.toNumber() * a.toNumber());
	  }
	  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = this.low_ & 65535, f = a.high_ >>> 16, g = a.high_ & 65535, h = a.low_ >>> 16;
	  a = a.low_ & 65535;
	  var m, k, l, n;
	  n = 0 + e * a;
	  l = 0 + (n >>> 16);
	  l += d * a;
	  k = 0 + (l >>> 16);
	  l = (l & 65535) + e * h;
	  k += l >>> 16;
	  l &= 65535;
	  k += c * a;
	  m = 0 + (k >>> 16);
	  k = (k & 65535) + d * h;
	  m += k >>> 16;
	  k &= 65535;
	  k += e * g;
	  m += k >>> 16;
	  k &= 65535;
	  m = m + (b * a + c * h + d * g + e * f) & 65535;
	  return goog.math.Long.fromBits(l << 16 | n & 65535, m << 16 | k);
	};
	goog.math.Long.prototype.div = function(a) {
	  if (a.isZero()) {
	    throw Error("division by zero");
	  }
	  if (this.isZero()) {
	    return goog.math.Long.getZero();
	  }
	  if (this.equals(goog.math.Long.getMinValue())) {
	    if (a.equals(goog.math.Long.getOne()) || a.equals(goog.math.Long.getNegOne())) {
	      return goog.math.Long.getMinValue();
	    }
	    if (a.equals(goog.math.Long.getMinValue())) {
	      return goog.math.Long.getOne();
	    }
	    var b = this.shiftRight(1).div(a).shiftLeft(1);
	    if (b.equals(goog.math.Long.getZero())) {
	      return a.isNegative() ? goog.math.Long.getOne() : goog.math.Long.getNegOne();
	    }
	    var c = this.subtract(a.multiply(b));
	    return b.add(c.div(a));
	  }
	  if (a.equals(goog.math.Long.getMinValue())) {
	    return goog.math.Long.getZero();
	  }
	  if (this.isNegative()) {
	    return a.isNegative() ? this.negate().div(a.negate()) : this.negate().div(a).negate();
	  }
	  if (a.isNegative()) {
	    return this.div(a.negate()).negate();
	  }
	  for (var d = goog.math.Long.getZero(), c = this;c.greaterThanOrEqual(a);) {
	    for (var b = Math.max(1, Math.floor(c.toNumber() / a.toNumber())), e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : Math.pow(2, e - 48), f = goog.math.Long.fromNumber(b), g = f.multiply(a);g.isNegative() || g.greaterThan(c);) {
	      b -= e, f = goog.math.Long.fromNumber(b), g = f.multiply(a);
	    }
	    f.isZero() && (f = goog.math.Long.getOne());
	    d = d.add(f);
	    c = c.subtract(g);
	  }
	  return d;
	};
	goog.math.Long.prototype.modulo = function(a) {
	  return this.subtract(this.div(a).multiply(a));
	};
	goog.math.Long.prototype.not = function() {
	  return goog.math.Long.fromBits(~this.low_, ~this.high_);
	};
	goog.math.Long.prototype.and = function(a) {
	  return goog.math.Long.fromBits(this.low_ & a.low_, this.high_ & a.high_);
	};
	goog.math.Long.prototype.or = function(a) {
	  return goog.math.Long.fromBits(this.low_ | a.low_, this.high_ | a.high_);
	};
	goog.math.Long.prototype.xor = function(a) {
	  return goog.math.Long.fromBits(this.low_ ^ a.low_, this.high_ ^ a.high_);
	};
	goog.math.Long.prototype.shiftLeft = function(a) {
	  a &= 63;
	  if (0 == a) {
	    return this;
	  }
	  var b = this.low_;
	  return 32 > a ? goog.math.Long.fromBits(b << a, this.high_ << a | b >>> 32 - a) : goog.math.Long.fromBits(0, b << a - 32);
	};
	goog.math.Long.prototype.shiftRight = function(a) {
	  a &= 63;
	  if (0 == a) {
	    return this;
	  }
	  var b = this.high_;
	  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >> a) : goog.math.Long.fromBits(b >> a - 32, 0 <= b ? 0 : -1);
	};
	goog.math.Long.prototype.shiftRightUnsigned = function(a) {
	  a &= 63;
	  if (0 == a) {
	    return this;
	  }
	  var b = this.high_;
	  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >>> a) : 32 == a ? goog.math.Long.fromBits(b, 0) : goog.math.Long.fromBits(b >>> a - 32, 0);
	};
	goog.object = {};
	goog.object.forEach = function(a, b, c) {
	  for (var d in a) {
	    b.call(c, a[d], d, a);
	  }
	};
	goog.object.filter = function(a, b, c) {
	  var d = {}, e;
	  for (e in a) {
	    b.call(c, a[e], e, a) && (d[e] = a[e]);
	  }
	  return d;
	};
	goog.object.map = function(a, b, c) {
	  var d = {}, e;
	  for (e in a) {
	    d[e] = b.call(c, a[e], e, a);
	  }
	  return d;
	};
	goog.object.some = function(a, b, c) {
	  for (var d in a) {
	    if (b.call(c, a[d], d, a)) {
	      return !0;
	    }
	  }
	  return !1;
	};
	goog.object.every = function(a, b, c) {
	  for (var d in a) {
	    if (!b.call(c, a[d], d, a)) {
	      return !1;
	    }
	  }
	  return !0;
	};
	goog.object.getCount = function(a) {
	  var b = 0, c;
	  for (c in a) {
	    b++;
	  }
	  return b;
	};
	goog.object.getAnyKey = function(a) {
	  for (var b in a) {
	    return b;
	  }
	};
	goog.object.getAnyValue = function(a) {
	  for (var b in a) {
	    return a[b];
	  }
	};
	goog.object.contains = function(a, b) {
	  return goog.object.containsValue(a, b);
	};
	goog.object.getValues = function(a) {
	  var b = [], c = 0, d;
	  for (d in a) {
	    b[c++] = a[d];
	  }
	  return b;
	};
	goog.object.getKeys = function(a) {
	  var b = [], c = 0, d;
	  for (d in a) {
	    b[c++] = d;
	  }
	  return b;
	};
	goog.object.getValueByKeys = function(a, b) {
	  for (var c = goog.isArrayLike(b), d = c ? b : arguments, c = c ? 0 : 1;c < d.length && (a = a[d[c]], goog.isDef(a));c++) {
	  }
	  return a;
	};
	goog.object.containsKey = function(a, b) {
	  return b in a;
	};
	goog.object.containsValue = function(a, b) {
	  for (var c in a) {
	    if (a[c] == b) {
	      return !0;
	    }
	  }
	  return !1;
	};
	goog.object.findKey = function(a, b, c) {
	  for (var d in a) {
	    if (b.call(c, a[d], d, a)) {
	      return d;
	    }
	  }
	};
	goog.object.findValue = function(a, b, c) {
	  return (b = goog.object.findKey(a, b, c)) && a[b];
	};
	goog.object.isEmpty = function(a) {
	  for (var b in a) {
	    return !1;
	  }
	  return !0;
	};
	goog.object.clear = function(a) {
	  for (var b in a) {
	    delete a[b];
	  }
	};
	goog.object.remove = function(a, b) {
	  var c;
	  (c = b in a) && delete a[b];
	  return c;
	};
	goog.object.add = function(a, b, c) {
	  if (b in a) {
	    throw Error('The object already contains the key "' + b + '"');
	  }
	  goog.object.set(a, b, c);
	};
	goog.object.get = function(a, b, c) {
	  return b in a ? a[b] : c;
	};
	goog.object.set = function(a, b, c) {
	  a[b] = c;
	};
	goog.object.setIfUndefined = function(a, b, c) {
	  return b in a ? a[b] : a[b] = c;
	};
	goog.object.setWithReturnValueIfNotSet = function(a, b, c) {
	  if (b in a) {
	    return a[b];
	  }
	  c = c();
	  return a[b] = c;
	};
	goog.object.equals = function(a, b) {
	  for (var c in a) {
	    if (!(c in b) || a[c] !== b[c]) {
	      return !1;
	    }
	  }
	  for (c in b) {
	    if (!(c in a)) {
	      return !1;
	    }
	  }
	  return !0;
	};
	goog.object.clone = function(a) {
	  var b = {}, c;
	  for (c in a) {
	    b[c] = a[c];
	  }
	  return b;
	};
	goog.object.unsafeClone = function(a) {
	  var b = goog.typeOf(a);
	  if ("object" == b || "array" == b) {
	    if (a.clone) {
	      return a.clone();
	    }
	    var b = "array" == b ? [] : {}, c;
	    for (c in a) {
	      b[c] = goog.object.unsafeClone(a[c]);
	    }
	    return b;
	  }
	  return a;
	};
	goog.object.transpose = function(a) {
	  var b = {}, c;
	  for (c in a) {
	    b[a[c]] = c;
	  }
	  return b;
	};
	goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog.object.extend = function(a, b) {
	  for (var c, d, e = 1;e < arguments.length;e++) {
	    d = arguments[e];
	    for (c in d) {
	      a[c] = d[c];
	    }
	    for (var f = 0;f < goog.object.PROTOTYPE_FIELDS_.length;f++) {
	      c = goog.object.PROTOTYPE_FIELDS_[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
	    }
	  }
	};
	goog.object.create = function(a) {
	  var b = arguments.length;
	  if (1 == b && goog.isArray(arguments[0])) {
	    return goog.object.create.apply(null, arguments[0]);
	  }
	  if (b % 2) {
	    throw Error("Uneven number of arguments");
	  }
	  for (var c = {}, d = 0;d < b;d += 2) {
	    c[arguments[d]] = arguments[d + 1];
	  }
	  return c;
	};
	goog.object.createSet = function(a) {
	  var b = arguments.length;
	  if (1 == b && goog.isArray(arguments[0])) {
	    return goog.object.createSet.apply(null, arguments[0]);
	  }
	  for (var c = {}, d = 0;d < b;d++) {
	    c[arguments[d]] = !0;
	  }
	  return c;
	};
	goog.object.createImmutableView = function(a) {
	  var b = a;
	  Object.isFrozen && !Object.isFrozen(a) && (b = Object.create(a), Object.freeze(b));
	  return b;
	};
	goog.object.isImmutableView = function(a) {
	  return !!Object.isFrozen && Object.isFrozen(a);
	};
	var com = {cognitect:{}};
	com.cognitect.transit = {};
	com.cognitect.transit.delimiters = {};
	com.cognitect.transit.delimiters.ESC = "~";
	com.cognitect.transit.delimiters.TAG = "#";
	com.cognitect.transit.delimiters.SUB = "^";
	com.cognitect.transit.delimiters.RES = "`";
	com.cognitect.transit.delimiters.ESC_TAG = "~#";
	com.cognitect.transit.caching = {};
	com.cognitect.transit.caching.MIN_SIZE_CACHEABLE = 3;
	com.cognitect.transit.caching.BASE_CHAR_IDX = 48;
	com.cognitect.transit.caching.CACHE_CODE_DIGITS = 44;
	com.cognitect.transit.caching.MAX_CACHE_ENTRIES = com.cognitect.transit.caching.CACHE_CODE_DIGITS * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
	com.cognitect.transit.caching.MAX_CACHE_SIZE = 4096;
	com.cognitect.transit.caching.isCacheable = function(a, b) {
	  if (a.length > com.cognitect.transit.caching.MIN_SIZE_CACHEABLE) {
	    if (b) {
	      return !0;
	    }
	    var c = a.charAt(0), d = a.charAt(1);
	    return c === com.cognitect.transit.delimiters.ESC ? ":" === d || "$" === d || "#" === d : !1;
	  }
	  return !1;
	};
	com.cognitect.transit.caching.idxToCode = function(a) {
	  var b = Math.floor(a / com.cognitect.transit.caching.CACHE_CODE_DIGITS);
	  a = String.fromCharCode(a % com.cognitect.transit.caching.CACHE_CODE_DIGITS + com.cognitect.transit.caching.BASE_CHAR_IDX);
	  return 0 === b ? com.cognitect.transit.delimiters.SUB + a : com.cognitect.transit.delimiters.SUB + String.fromCharCode(b + com.cognitect.transit.caching.BASE_CHAR_IDX) + a;
	};
	com.cognitect.transit.caching.WriteCache = function() {
	  this.cacheSize = this.gen = this.idx = 0;
	  this.cache = {};
	};
	com.cognitect.transit.caching.WriteCache.prototype.write = function(a, b) {
	  if (com.cognitect.transit.caching.isCacheable(a, b)) {
	    this.cacheSize === com.cognitect.transit.caching.MAX_CACHE_SIZE ? (this.clear(), this.gen = 0, this.cache = {}) : this.idx === com.cognitect.transit.caching.MAX_CACHE_ENTRIES && this.clear();
	    var c = this.cache[a];
	    return null == c ? (this.cache[a] = [com.cognitect.transit.caching.idxToCode(this.idx), this.gen], this.idx++, a) : c[1] != this.gen ? (c[1] = this.gen, c[0] = com.cognitect.transit.caching.idxToCode(this.idx), this.idx++, a) : c[0];
	  }
	  return a;
	};
	com.cognitect.transit.caching.WriteCache.prototype.clear = function() {
	  this.idx = 0;
	  this.gen++;
	};
	com.cognitect.transit.caching.writeCache = function() {
	  return new com.cognitect.transit.caching.WriteCache;
	};
	com.cognitect.transit.caching.isCacheCode = function(a) {
	  return a.charAt(0) === com.cognitect.transit.delimiters.SUB && " " !== a.charAt(1);
	};
	com.cognitect.transit.caching.codeToIdx = function(a) {
	  if (2 === a.length) {
	    return a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX;
	  }
	  var b = (a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX) * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
	  a = a.charCodeAt(2) - com.cognitect.transit.caching.BASE_CHAR_IDX;
	  return b + a;
	};
	com.cognitect.transit.caching.ReadCache = function() {
	  this.idx = 0;
	  this.cache = [];
	};
	com.cognitect.transit.caching.ReadCache.prototype.write = function(a, b) {
	  this.idx == com.cognitect.transit.caching.MAX_CACHE_ENTRIES && (this.idx = 0);
	  this.cache[this.idx] = a;
	  this.idx++;
	  return a;
	};
	com.cognitect.transit.caching.ReadCache.prototype.read = function(a, b) {
	  return this.cache[com.cognitect.transit.caching.codeToIdx(a)];
	};
	com.cognitect.transit.caching.ReadCache.prototype.clear = function() {
	  this.idx = 0;
	};
	com.cognitect.transit.caching.readCache = function() {
	  return new com.cognitect.transit.caching.ReadCache;
	};
	com.cognitect.transit.util = {};
	com.cognitect.transit.util.objectKeys = "undefined" != typeof Object.keys ? function(a) {
	  return Object.keys(a);
	} : function(a) {
	  return goog.object.getKeys(a);
	};
	com.cognitect.transit.util.isArray = "undefined" != typeof Array.isArray ? function(a) {
	  return Array.isArray(a);
	} : function(a) {
	  return "array" === goog.typeOf(a);
	};
	com.cognitect.transit.util.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	com.cognitect.transit.util.randInt = function(a) {
	  return Math.round(Math.random() * a);
	};
	com.cognitect.transit.util.randHex = function() {
	  return com.cognitect.transit.util.randInt(15).toString(16);
	};
	com.cognitect.transit.util.randomUUID = function() {
	  var a = (8 | 3 & com.cognitect.transit.util.randInt(14)).toString(16);
	  return com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-4" + com.cognitect.transit.util.randHex() + 
	  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + a + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + 
	  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex();
	};
	com.cognitect.transit.util.btoa = function(a) {
	  if ("undefined" != typeof btoa) {
	    return btoa(a);
	  }
	  a = String(a);
	  for (var b, c, d = 0, e = com.cognitect.transit.util.chars, f = "";a.charAt(d | 0) || (e = "=", d % 1);f += e.charAt(63 & b >> 8 - d % 1 * 8)) {
	    c = a.charCodeAt(d += .75);
	    if (255 < c) {
	      throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	    }
	    b = b << 8 | c;
	  }
	  return f;
	};
	com.cognitect.transit.util.atob = function(a) {
	  if ("undefined" != typeof atob) {
	    return atob(a);
	  }
	  a = String(a).replace(/=+$/, "");
	  if (1 == a.length % 4) {
	    throw Error("'atob' failed: The string to be decoded is not correctly encoded.");
	  }
	  for (var b = 0, c, d, e = 0, f = "";d = a.charAt(e++);~d && (c = b % 4 ? 64 * c + d : d, b++ % 4) ? f += String.fromCharCode(255 & c >> (-2 * b & 6)) : 0) {
	    d = com.cognitect.transit.util.chars.indexOf(d);
	  }
	  return f;
	};
	com.cognitect.transit.util.Uint8ToBase64 = function(a) {
	  for (var b = 0, c = a.length, d = "", e = null;b < c;) {
	    e = a.subarray(b, Math.min(b + 32768, c)), d += String.fromCharCode.apply(null, e), b += 32768;
	  }
	  return com.cognitect.transit.util.btoa(d);
	};
	com.cognitect.transit.util.Base64ToUint8 = function(a) {
	  a = com.cognitect.transit.util.atob(a);
	  for (var b = a.length, c = new Uint8Array(b), d = 0;d < b;d++) {
	    var e = a.charCodeAt(d);
	    c[d] = e;
	  }
	  return c;
	};
	com.cognitect.transit.eq = {};
	com.cognitect.transit.eq.hashCodeProperty = "transit$hashCode$";
	com.cognitect.transit.eq.hashCodeCounter = 1;
	com.cognitect.transit.eq.equals = function(a, b) {
	  if (null == a) {
	    return null == b;
	  }
	  if (a === b) {
	    return !0;
	  }
	  if ("object" === typeof a) {
	    if (com.cognitect.transit.util.isArray(a)) {
	      if (com.cognitect.transit.util.isArray(b) && a.length === b.length) {
	        for (var c = 0;c < a.length;c++) {
	          if (!com.cognitect.transit.eq.equals(a[c], b[c])) {
	            return !1;
	          }
	        }
	        return !0;
	      }
	      return !1;
	    }
	    if (a.com$cognitect$transit$equals) {
	      return a.com$cognitect$transit$equals(b);
	    }
	    if (null != b && "object" === typeof b) {
	      if (b.com$cognitect$transit$equals) {
	        return b.com$cognitect$transit$equals(a);
	      }
	      var c = 0, d = com.cognitect.transit.util.objectKeys(b).length, e;
	      for (e in a) {
	        if (a.hasOwnProperty(e) && (c++, !b.hasOwnProperty(e) || !com.cognitect.transit.eq.equals(a[e], b[e]))) {
	          return !1;
	        }
	      }
	      return c === d;
	    }
	  }
	  return !1;
	};
	com.cognitect.transit.eq.hashCombine = function(a, b) {
	  return a ^ b + 2654435769 + (a << 6) + (a >> 2);
	};
	com.cognitect.transit.eq.stringCodeCache = {};
	com.cognitect.transit.eq.stringCodeCacheSize = 0;
	com.cognitect.transit.eq.STR_CACHE_MAX = 256;
	com.cognitect.transit.eq.hashString = function(a) {
	  var b = com.cognitect.transit.eq.stringCodeCache[a];
	  if (null != b) {
	    return b;
	  }
	  for (var c = b = 0;c < a.length;++c) {
	    b = 31 * b + a.charCodeAt(c), b %= 4294967296;
	  }
	  com.cognitect.transit.eq.stringCodeCacheSize++;
	  com.cognitect.transit.eq.stringCodeCacheSize >= com.cognitect.transit.eq.STR_CACHE_MAX && (com.cognitect.transit.eq.stringCodeCache = {}, com.cognitect.transit.eq.stringCodeCacheSize = 1);
	  return com.cognitect.transit.eq.stringCodeCache[a] = b;
	};
	com.cognitect.transit.eq.hashMapLike = function(a) {
	  var b = 0;
	  if (null != a.forEach) {
	    a.forEach(function(a, c, d) {
	      b = (b + (com.cognitect.transit.eq.hashCode(c) ^ com.cognitect.transit.eq.hashCode(a))) % 4503599627370496;
	    });
	  } else {
	    for (var c = com.cognitect.transit.util.objectKeys(a), d = 0;d < c.length;d++) {
	      var e = c[d], f = a[e], b = (b + (com.cognitect.transit.eq.hashCode(e) ^ com.cognitect.transit.eq.hashCode(f))) % 4503599627370496
	    }
	  }
	  return b;
	};
	com.cognitect.transit.eq.hashArrayLike = function(a) {
	  var b = 0;
	  if (com.cognitect.transit.util.isArray(a)) {
	    for (var c = 0;c < a.length;c++) {
	      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a[c]));
	    }
	  } else {
	    a.forEach && a.forEach(function(a, c) {
	      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a));
	    });
	  }
	  return b;
	};
	com.cognitect.transit.eq.hashCode = function(a) {
	  if (null == a) {
	    return 0;
	  }
	  switch(typeof a) {
	    case "number":
	      return a;
	    case "boolean":
	      return !0 === a ? 1 : 0;
	    case "string":
	      return com.cognitect.transit.eq.hashString(a);
	    case "function":
	      var b = a[com.cognitect.transit.eq.hashCodeProperty];
	      b || (b = com.cognitect.transit.eq.hashCodeCounter, "undefined" != typeof Object.defineProperty ? Object.defineProperty(a, com.cognitect.transit.eq.hashCodeProperty, {value:b, enumerable:!1}) : a[com.cognitect.transit.eq.hashCodeProperty] = b, com.cognitect.transit.eq.hashCodeCounter++);
	      return b;
	    default:
	      return a instanceof Date ? a.valueOf() : com.cognitect.transit.util.isArray(a) ? com.cognitect.transit.eq.hashArrayLike(a) : a.com$cognitect$transit$hashCode ? a.com$cognitect$transit$hashCode() : com.cognitect.transit.eq.hashMapLike(a);
	  }
	};
	com.cognitect.transit.eq.extendToEQ = function(a, b) {
	  a.com$cognitect$transit$hashCode = b.hashCode;
	  a.com$cognitect$transit$equals = b.equals;
	  return a;
	};
	com.cognitect.transit.types = {};
	com.cognitect.transit.types.ITERATOR = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator";
	com.cognitect.transit.types.TaggedValue = function(a, b) {
	  this.tag = a;
	  this.rep = b;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.TaggedValue.prototype.toString = function() {
	  return "[TaggedValue: " + this.tag + ", " + this.rep + "]";
	};
	com.cognitect.transit.types.TaggedValue.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.TaggedValue.prototype.equiv = com.cognitect.transit.types.TaggedValue.prototype.equiv;
	com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue ? this.tag === a.tag && com.cognitect.transit.eq.equals(this.rep, a.rep) : !1;
	};
	com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCombine(com.cognitect.transit.eq.hashCode(this.tag), com.cognitect.transit.eq.hashCode(this.rep)));
	  return this.hashCode;
	};
	com.cognitect.transit.types.taggedValue = function(a, b) {
	  return new com.cognitect.transit.types.TaggedValue(a, b);
	};
	com.cognitect.transit.types.isTaggedValue = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue;
	};
	com.cognitect.transit.types.nullValue = function() {
	  return null;
	};
	com.cognitect.transit.types.boolValue = function(a) {
	  return "t" === a;
	};
	com.cognitect.transit.types.MAX_INT = goog.math.Long.fromString("9007199254740991");
	com.cognitect.transit.types.MIN_INT = goog.math.Long.fromString("-9007199254740991");
	com.cognitect.transit.types.intValue = function(a) {
	  if ("number" === typeof a || a instanceof goog.math.Long) {
	    return a;
	  }
	  a = goog.math.Long.fromString(a, 10);
	  return a.greaterThan(com.cognitect.transit.types.MAX_INT) || a.lessThan(com.cognitect.transit.types.MIN_INT) ? a : a.toNumber();
	};
	goog.math.Long.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	goog.math.Long.prototype.equiv = goog.math.Long.prototype.equiv;
	goog.math.Long.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof goog.math.Long && this.equals(a);
	};
	goog.math.Long.prototype.com$cognitect$transit$hashCode = function() {
	  return this.toInt();
	};
	com.cognitect.transit.types.isInteger = function(a) {
	  return a instanceof goog.math.Long ? !0 : "number" === typeof a && !isNaN(a) && Infinity !== a && parseFloat(a) === parseInt(a, 10);
	};
	com.cognitect.transit.types.floatValue = function(a) {
	  return parseFloat(a);
	};
	com.cognitect.transit.types.bigInteger = function(a) {
	  return com.cognitect.transit.types.taggedValue("n", a);
	};
	com.cognitect.transit.types.isBigInteger = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "n" === a.tag;
	};
	com.cognitect.transit.types.bigDecimalValue = function(a) {
	  return com.cognitect.transit.types.taggedValue("f", a);
	};
	com.cognitect.transit.types.isBigDecimal = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "f" === a.tag;
	};
	com.cognitect.transit.types.charValue = function(a) {
	  return a;
	};
	com.cognitect.transit.types.Keyword = function(a) {
	  this._name = a;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.Keyword.prototype.toString = function() {
	  return ":" + this._name;
	};
	com.cognitect.transit.types.Keyword.prototype.namespace = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(0, a) : null;
	};
	com.cognitect.transit.types.Keyword.prototype.name = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
	};
	com.cognitect.transit.types.Keyword.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.Keyword.prototype.equiv = com.cognitect.transit.types.Keyword.prototype.equiv;
	com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.Keyword && this._name == a._name;
	};
	com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
	  return this.hashCode;
	};
	com.cognitect.transit.types.keyword = function(a) {
	  return new com.cognitect.transit.types.Keyword(a);
	};
	com.cognitect.transit.types.isKeyword = function(a) {
	  return a instanceof com.cognitect.transit.types.Keyword;
	};
	com.cognitect.transit.types.Symbol = function(a) {
	  this._name = a;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.Symbol.prototype.namespace = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(0, a) : null;
	};
	com.cognitect.transit.types.Symbol.prototype.name = function() {
	  var a = this._name.indexOf("/");
	  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
	};
	com.cognitect.transit.types.Symbol.prototype.toString = function() {
	  return this._name;
	};
	com.cognitect.transit.types.Symbol.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.Symbol.prototype.equiv = com.cognitect.transit.types.Symbol.prototype.equiv;
	com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.Symbol && this._name == a._name;
	};
	com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
	  return this.hashCode;
	};
	com.cognitect.transit.types.symbol = function(a) {
	  return new com.cognitect.transit.types.Symbol(a);
	};
	com.cognitect.transit.types.isSymbol = function(a) {
	  return a instanceof com.cognitect.transit.types.Symbol;
	};
	com.cognitect.transit.types.hexFor = function(a, b, c) {
	  var d = "";
	  c = c || b + 1;
	  for (var e = 8 * (7 - b), f = goog.math.Long.fromInt(255).shiftLeft(e);b < c;b++, e -= 8, f = f.shiftRightUnsigned(8)) {
	    var g = a.and(f).shiftRightUnsigned(e).toString(16);
	    1 == g.length && (g = "0" + g);
	    d += g;
	  }
	  return d;
	};
	com.cognitect.transit.types.UUID = function(a, b) {
	  this.high = a;
	  this.low = b;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.UUID.prototype.getLeastSignificantBits = function() {
	  return this.low;
	};
	com.cognitect.transit.types.UUID.prototype.getMostSignificantBits = function() {
	  return this.high;
	};
	com.cognitect.transit.types.UUID.prototype.toString = function() {
	  var a, b = this.high, c = this.low;
	  a = "" + (com.cognitect.transit.types.hexFor(b, 0, 4) + "-");
	  a += com.cognitect.transit.types.hexFor(b, 4, 6) + "-";
	  a += com.cognitect.transit.types.hexFor(b, 6, 8) + "-";
	  a += com.cognitect.transit.types.hexFor(c, 0, 2) + "-";
	  return a += com.cognitect.transit.types.hexFor(c, 2, 8);
	};
	com.cognitect.transit.types.UUID.prototype.equiv = function(a) {
	  return com.cognitect.transit.eq.equals(this, a);
	};
	com.cognitect.transit.types.UUID.prototype.equiv = com.cognitect.transit.types.UUID.prototype.equiv;
	com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof com.cognitect.transit.types.UUID && this.high.equals(a.high) && this.low.equals(a.low);
	};
	com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this.toString()));
	  return this.hashCode;
	};
	com.cognitect.transit.types.UUIDfromString = function(a) {
	  a = a.replace(/-/g, "");
	  for (var b = null, c = null, d = c = 0, e = 24, f = 0, f = c = 0, e = 24;8 > f;f += 2, e -= 8) {
	    c |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  d = 0;
	  f = 8;
	  for (e = 24;16 > f;f += 2, e -= 8) {
	    d |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  b = goog.math.Long.fromBits(d, c);
	  c = 0;
	  f = 16;
	  for (e = 24;24 > f;f += 2, e -= 8) {
	    c |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  d = 0;
	  for (e = f = 24;32 > f;f += 2, e -= 8) {
	    d |= parseInt(a.substring(f, f + 2), 16) << e;
	  }
	  c = goog.math.Long.fromBits(d, c);
	  return new com.cognitect.transit.types.UUID(b, c);
	};
	com.cognitect.transit.types.uuid = function(a) {
	  return com.cognitect.transit.types.UUIDfromString(a);
	};
	com.cognitect.transit.types.isUUID = function(a) {
	  return a instanceof com.cognitect.transit.types.UUID;
	};
	com.cognitect.transit.types.date = function(a) {
	  a = "number" === typeof a ? a : parseInt(a, 10);
	  return new Date(a);
	};
	com.cognitect.transit.types.verboseDate = function(a) {
	  return new Date(a);
	};
	Date.prototype.com$cognitect$transit$equals = function(a) {
	  return a instanceof Date ? this.valueOf() === a.valueOf() : !1;
	};
	Date.prototype.com$cognitect$transit$hashCode = function() {
	  return this.valueOf();
	};
	com.cognitect.transit.types.binary = function(a, b) {
	  return b && !1 === b.preferBuffers || "undefined" == typeof Buffer ? "undefined" != typeof Uint8Array ? com.cognitect.transit.util.Base64ToUint8(a) : com.cognitect.transit.types.taggedValue("b", a) : new Buffer(a, "base64");
	};
	com.cognitect.transit.types.isBinary = function(a) {
	  return "undefined" != typeof Buffer && a instanceof Buffer ? !0 : "undefined" != typeof Uint8Array && a instanceof Uint8Array ? !0 : a instanceof com.cognitect.transit.types.TaggedValue && "b" === a.tag;
	};
	com.cognitect.transit.types.uri = function(a) {
	  return com.cognitect.transit.types.taggedValue("r", a);
	};
	com.cognitect.transit.types.isURI = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "r" === a.tag;
	};
	com.cognitect.transit.types.KEYS = 0;
	com.cognitect.transit.types.VALUES = 1;
	com.cognitect.transit.types.ENTRIES = 2;
	com.cognitect.transit.types.TransitArrayMapIterator = function(a, b) {
	  this.entries = a;
	  this.type = b || com.cognitect.transit.types.KEYS;
	  this.idx = 0;
	};
	com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = function() {
	  if (this.idx < this.entries.length) {
	    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.entries[this.idx] : this.type === com.cognitect.transit.types.VALUES ? this.entries[this.idx + 1] : [this.entries[this.idx], this.entries[this.idx + 1]], a = {value:a, done:!1};
	    this.idx += 2;
	    return a;
	  }
	  return {value:null, done:!0};
	};
	com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = com.cognitect.transit.types.TransitArrayMapIterator.prototype.next;
	com.cognitect.transit.types.TransitArrayMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this;
	};
	com.cognitect.transit.types.TransitMapIterator = function(a, b) {
	  this.map = a;
	  this.type = b || com.cognitect.transit.types.KEYS;
	  this.keys = this.map.getKeys();
	  this.idx = 0;
	  this.bucket = null;
	  this.bucketIdx = 0;
	};
	com.cognitect.transit.types.TransitMapIterator.prototype.next = function() {
	  if (this.idx < this.map.size) {
	    null != this.bucket && this.bucketIdx < this.bucket.length || (this.bucket = this.map.map[this.keys[this.idx]], this.bucketIdx = 0);
	    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.bucket[this.bucketIdx] : this.type === com.cognitect.transit.types.VALUES ? this.bucket[this.bucketIdx + 1] : [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]], a = {value:a, done:!1};
	    this.idx++;
	    this.bucketIdx += 2;
	    return a;
	  }
	  return {value:null, done:!0};
	};
	com.cognitect.transit.types.TransitMapIterator.prototype.next = com.cognitect.transit.types.TransitMapIterator.prototype.next;
	com.cognitect.transit.types.TransitMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this;
	};
	com.cognitect.transit.types.mapEquals = function(a, b) {
	  if (a instanceof com.cognitect.transit.types.TransitMap && com.cognitect.transit.types.isMap(b)) {
	    if (a.size !== b.size) {
	      return !1;
	    }
	    for (var c in a.map) {
	      for (var d = a.map[c], e = 0;e < d.length;e += 2) {
	        if (!com.cognitect.transit.eq.equals(d[e + 1], b.get(d[e]))) {
	          return !1;
	        }
	      }
	    }
	    return !0;
	  }
	  if (a instanceof com.cognitect.transit.types.TransitArrayMap && com.cognitect.transit.types.isMap(b)) {
	    if (a.size !== b.size) {
	      return !1;
	    }
	    c = a._entries;
	    for (e = 0;e < c.length;e += 2) {
	      if (!com.cognitect.transit.eq.equals(c[e + 1], b.get(c[e]))) {
	        return !1;
	      }
	    }
	    return !0;
	  }
	  if (null != b && "object" === typeof b && (e = com.cognitect.transit.util.objectKeys(b), c = e.length, a.size === c)) {
	    for (d = 0;d < c;d++) {
	      var f = e[d];
	      if (!a.has(f) || !com.cognitect.transit.eq.equals(b[f], a.get(f))) {
	        return !1;
	      }
	    }
	    return !0;
	  }
	  return !1;
	};
	com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD = 8;
	com.cognitect.transit.types.ARRAY_MAP_THRESHOLD = 32;
	com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD = 32;
	com.cognitect.transit.types.print = function(a) {
	  return null == a ? "null" : goog.isArray(a) ? "[" + a.toString() + "]" : goog.isString(a) ? '"' + a + '"' : a.toString();
	};
	com.cognitect.transit.types.printMap = function(a) {
	  var b = 0, c = "TransitMap {";
	  a.forEach(function(d, e) {
	    c += com.cognitect.transit.types.print(e) + " => " + com.cognitect.transit.types.print(d);
	    b < a.size - 1 && (c += ", ");
	    b++;
	  });
	  return c + "}";
	};
	com.cognitect.transit.types.printSet = function(a) {
	  var b = 0, c = "TransitSet {";
	  a.forEach(function(d) {
	    c += com.cognitect.transit.types.print(d);
	    b < a.size - 1 && (c += ", ");
	    b++;
	  });
	  return c + "}";
	};
	com.cognitect.transit.types.TransitArrayMap = function(a) {
	  this._entries = a;
	  this.backingMap = null;
	  this.hashCode = -1;
	  this.size = a.length / 2;
	  this.accesses = 0;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.toString = function() {
	  return com.cognitect.transit.types.printMap(this);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.inspect = function() {
	  return this.toString();
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.convert = function() {
	  if (this.backingMap) {
	    throw Error("Invalid operation, already converted");
	  }
	  if (this.size < com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD) {
	    return !1;
	  }
	  this.accesses++;
	  return this.accesses > com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD ? (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = [], !0) : !1;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clear = function() {
	  this.hashCode = -1;
	  this.backingMap ? this.backingMap.clear() : this._entries = [];
	  this.size = 0;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clear = com.cognitect.transit.types.TransitArrayMap.prototype.clear;
	com.cognitect.transit.types.TransitArrayMap.prototype.keys = function() {
	  return this.backingMap ? this.backingMap.keys() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.KEYS);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.keys = com.cognitect.transit.types.TransitArrayMap.prototype.keys;
	com.cognitect.transit.types.TransitArrayMap.prototype.keySet = function() {
	  if (this.backingMap) {
	    return this.backingMap.keySet();
	  }
	  for (var a = [], b = 0, c = 0;c < this._entries.length;b++, c += 2) {
	    a[b] = this._entries[c];
	  }
	  return a;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.keySet = com.cognitect.transit.types.TransitArrayMap.prototype.keySet;
	com.cognitect.transit.types.TransitArrayMap.prototype.entries = function() {
	  return this.backingMap ? this.backingMap.entries() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.ENTRIES);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.entries = com.cognitect.transit.types.TransitArrayMap.prototype.entries;
	com.cognitect.transit.types.TransitArrayMap.prototype.values = function() {
	  return this.backingMap ? this.backingMap.values() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.VALUES);
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.values = com.cognitect.transit.types.TransitArrayMap.prototype.values;
	com.cognitect.transit.types.TransitArrayMap.prototype.forEach = function(a) {
	  if (this.backingMap) {
	    this.backingMap.forEach(a);
	  } else {
	    for (var b = 0;b < this._entries.length;b += 2) {
	      a(this._entries[b + 1], this._entries[b]);
	    }
	  }
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.forEach = com.cognitect.transit.types.TransitArrayMap.prototype.forEach;
	com.cognitect.transit.types.TransitArrayMap.prototype.get = function(a, b) {
	  if (this.backingMap) {
	    return this.backingMap.get(a);
	  }
	  if (this.convert()) {
	    return this.get(a);
	  }
	  for (var c = 0;c < this._entries.length;c += 2) {
	    if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
	      return this._entries[c + 1];
	    }
	  }
	  return b;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.get = com.cognitect.transit.types.TransitArrayMap.prototype.get;
	com.cognitect.transit.types.TransitArrayMap.prototype.has = function(a) {
	  if (this.backingMap) {
	    return this.backingMap.has(a);
	  }
	  if (this.convert()) {
	    return this.has(a);
	  }
	  for (var b = 0;b < this._entries.length;b += 2) {
	    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
	      return !0;
	    }
	  }
	  return !1;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.has = com.cognitect.transit.types.TransitArrayMap.prototype.has;
	com.cognitect.transit.types.TransitArrayMap.prototype.set = function(a, b) {
	  this.hashCode = -1;
	  if (this.backingMap) {
	    this.backingMap.set(a, b), this.size = this.backingMap.size;
	  } else {
	    for (var c = 0;c < this._entries.length;c += 2) {
	      if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
	        this._entries[c + 1] = b;
	        return;
	      }
	    }
	    this._entries.push(a);
	    this._entries.push(b);
	    this.size++;
	    this.size > com.cognitect.transit.types.ARRAY_MAP_THRESHOLD && (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = null);
	  }
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.set = com.cognitect.transit.types.TransitArrayMap.prototype.set;
	com.cognitect.transit.types.TransitArrayMap.prototype["delete"] = function(a) {
	  this.hashCode = -1;
	  if (this.backingMap) {
	    return a = this.backingMap["delete"](a), this.size = this.backingMap.size, a;
	  }
	  for (var b = 0;b < this._entries.length;b += 2) {
	    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
	      return a = this._entries[b + 1], this._entries.splice(b, 2), this.size--, a;
	    }
	  }
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clone = function() {
	  var a = com.cognitect.transit.types.map();
	  this.forEach(function(b, c) {
	    a.set(c, b);
	  });
	  return a;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.clone = com.cognitect.transit.types.TransitArrayMap.prototype.clone;
	com.cognitect.transit.types.TransitArrayMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this.entries();
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {
	  if (this.backingMap) {
	    return this.backingMap.com$cognitect$transit$hashCode();
	  }
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
	  return this.hashCode;
	};
	com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(a) {
	  return this.backingMap ? com.cognitect.transit.types.mapEquals(this.backingMap, a) : com.cognitect.transit.types.mapEquals(this, a);
	};
	com.cognitect.transit.types.TransitMap = function(a, b, c) {
	  this.map = b || {};
	  this._keys = a || [];
	  this.size = c || 0;
	  this.hashCode = -1;
	};
	com.cognitect.transit.types.TransitMap.prototype.toString = function() {
	  return com.cognitect.transit.types.printMap(this);
	};
	com.cognitect.transit.types.TransitMap.prototype.inspect = function() {
	  return this.toString();
	};
	com.cognitect.transit.types.TransitMap.prototype.clear = function() {
	  this.hashCode = -1;
	  this.map = {};
	  this._keys = [];
	  this.size = 0;
	};
	com.cognitect.transit.types.TransitMap.prototype.clear = com.cognitect.transit.types.TransitMap.prototype.clear;
	com.cognitect.transit.types.TransitMap.prototype.getKeys = function() {
	  return null != this._keys ? this._keys : com.cognitect.transit.util.objectKeys(this.map);
	};
	com.cognitect.transit.types.TransitMap.prototype["delete"] = function(a) {
	  this.hashCode = -1;
	  this._keys = null;
	  for (var b = com.cognitect.transit.eq.hashCode(a), c = this.map[b], d = 0;d < c.length;d += 2) {
	    if (com.cognitect.transit.eq.equals(a, c[d])) {
	      return a = c[d + 1], c.splice(d, 2), 0 === c.length && delete this.map[b], this.size--, a;
	    }
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.entries = function() {
	  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.ENTRIES);
	};
	com.cognitect.transit.types.TransitMap.prototype.entries = com.cognitect.transit.types.TransitMap.prototype.entries;
	com.cognitect.transit.types.TransitMap.prototype.forEach = function(a) {
	  for (var b = this.getKeys(), c = 0;c < b.length;c++) {
	    for (var d = this.map[b[c]], e = 0;e < d.length;e += 2) {
	      a(d[e + 1], d[e], this);
	    }
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.forEach = com.cognitect.transit.types.TransitMap.prototype.forEach;
	com.cognitect.transit.types.TransitMap.prototype.get = function(a, b) {
	  var c = com.cognitect.transit.eq.hashCode(a), c = this.map[c];
	  if (null != c) {
	    for (var d = 0;d < c.length;d += 2) {
	      if (com.cognitect.transit.eq.equals(a, c[d])) {
	        return c[d + 1];
	      }
	    }
	  } else {
	    return b;
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.get = com.cognitect.transit.types.TransitMap.prototype.get;
	com.cognitect.transit.types.TransitMap.prototype.has = function(a) {
	  var b = com.cognitect.transit.eq.hashCode(a), b = this.map[b];
	  if (null != b) {
	    for (var c = 0;c < b.length;c += 2) {
	      if (com.cognitect.transit.eq.equals(a, b[c])) {
	        return !0;
	      }
	    }
	  }
	  return !1;
	};
	com.cognitect.transit.types.TransitMap.prototype.has = com.cognitect.transit.types.TransitMap.prototype.has;
	com.cognitect.transit.types.TransitMap.prototype.keys = function() {
	  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.KEYS);
	};
	com.cognitect.transit.types.TransitMap.prototype.keys = com.cognitect.transit.types.TransitMap.prototype.keys;
	com.cognitect.transit.types.TransitMap.prototype.keySet = function() {
	  for (var a = this.getKeys(), b = [], c = 0;c < a.length;c++) {
	    for (var d = this.map[a[c]], e = 0;e < d.length;e += 2) {
	      b.push(d[e]);
	    }
	  }
	  return b;
	};
	com.cognitect.transit.types.TransitMap.prototype.keySet = com.cognitect.transit.types.TransitMap.prototype.keySet;
	com.cognitect.transit.types.TransitMap.prototype.set = function(a, b) {
	  this.hashCode = -1;
	  var c = com.cognitect.transit.eq.hashCode(a), d = this.map[c];
	  if (null == d) {
	    this._keys && this._keys.push(c), this.map[c] = [a, b], this.size++;
	  } else {
	    for (var c = !0, e = 0;e < d.length;e += 2) {
	      if (com.cognitect.transit.eq.equals(b, d[e])) {
	        c = !1;
	        d[e] = b;
	        break;
	      }
	    }
	    c && (d.push(a), d.push(b), this.size++);
	  }
	};
	com.cognitect.transit.types.TransitMap.prototype.set = com.cognitect.transit.types.TransitMap.prototype.set;
	com.cognitect.transit.types.TransitMap.prototype.values = function() {
	  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.VALUES);
	};
	com.cognitect.transit.types.TransitMap.prototype.values = com.cognitect.transit.types.TransitMap.prototype.values;
	com.cognitect.transit.types.TransitMap.prototype.clone = function() {
	  var a = com.cognitect.transit.types.map();
	  this.forEach(function(b, c) {
	    a.set(c, b);
	  });
	  return a;
	};
	com.cognitect.transit.types.TransitMap.prototype.clone = com.cognitect.transit.types.TransitMap.prototype.clone;
	com.cognitect.transit.types.TransitMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this.entries();
	};
	com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {
	  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
	  return this.hashCode;
	};
	com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$equals = function(a) {
	  return com.cognitect.transit.types.mapEquals(this, a);
	};
	com.cognitect.transit.types.map = function(a, b, c) {
	  a = a || [];
	  b = !1 === b ? b : !0;
	  if ((!0 !== c || !c) && a.length <= 2 * com.cognitect.transit.types.ARRAY_MAP_THRESHOLD) {
	    if (b) {
	      var d = a;
	      a = [];
	      for (b = 0;b < d.length;b += 2) {
	        var e = !1;
	        for (c = 0;c < a.length;c += 2) {
	          if (com.cognitect.transit.eq.equals(a[c], d[b])) {
	            a[c + 1] = d[b + 1];
	            e = !0;
	            break;
	          }
	        }
	        e || (a.push(d[b]), a.push(d[b + 1]));
	      }
	    }
	    return new com.cognitect.transit.types.TransitArrayMap(a);
	  }
	  var d = {}, e = [], f = 0;
	  for (b = 0;b < a.length;b += 2) {
	    c = com.cognitect.transit.eq.hashCode(a[b]);
	    var g = d[c];
	    if (null == g) {
	      e.push(c), d[c] = [a[b], a[b + 1]], f++;
	    } else {
	      var h = !0;
	      for (c = 0;c < g.length;c += 2) {
	        if (com.cognitect.transit.eq.equals(g[c], a[b])) {
	          g[c + 1] = a[b + 1];
	          h = !1;
	          break;
	        }
	      }
	      h && (g.push(a[b]), g.push(a[b + 1]), f++);
	    }
	  }
	  return new com.cognitect.transit.types.TransitMap(e, d, f);
	};
	com.cognitect.transit.types.isArrayMap = function(a) {
	  return a instanceof com.cognitect.transit.types.TransitArrayMap;
	};
	com.cognitect.transit.types.isMap = function(a) {
	  return a instanceof com.cognitect.transit.types.TransitArrayMap || a instanceof com.cognitect.transit.types.TransitMap;
	};
	com.cognitect.transit.types.TransitSet = function(a) {
	  this.map = a;
	  this.size = a.size;
	};
	com.cognitect.transit.types.TransitSet.prototype.toString = function() {
	  return com.cognitect.transit.types.printSet(this);
	};
	com.cognitect.transit.types.TransitSet.prototype.inspect = function() {
	  return this.toString();
	};
	com.cognitect.transit.types.TransitSet.prototype.add = function(a) {
	  this.map.set(a, a);
	  this.size = this.map.size;
	};
	com.cognitect.transit.types.TransitSet.prototype.add = com.cognitect.transit.types.TransitSet.prototype.add;
	com.cognitect.transit.types.TransitSet.prototype.clear = function() {
	  this.map = new com.cognitect.transit.types.TransitMap;
	  this.size = 0;
	};
	com.cognitect.transit.types.TransitSet.prototype.clear = com.cognitect.transit.types.TransitSet.prototype.clear;
	com.cognitect.transit.types.TransitSet.prototype["delete"] = function(a) {
	  a = this.map["delete"](a);
	  this.size = this.map.size;
	  return a;
	};
	com.cognitect.transit.types.TransitSet.prototype.entries = function() {
	  return this.map.entries();
	};
	com.cognitect.transit.types.TransitSet.prototype.entries = com.cognitect.transit.types.TransitSet.prototype.entries;
	com.cognitect.transit.types.TransitSet.prototype.forEach = function(a, b) {
	  var c = this;
	  this.map.forEach(function(b, e, f) {
	    a(e, c);
	  });
	};
	com.cognitect.transit.types.TransitSet.prototype.forEach = com.cognitect.transit.types.TransitSet.prototype.forEach;
	com.cognitect.transit.types.TransitSet.prototype.has = function(a) {
	  return this.map.has(a);
	};
	com.cognitect.transit.types.TransitSet.prototype.has = com.cognitect.transit.types.TransitSet.prototype.has;
	com.cognitect.transit.types.TransitSet.prototype.keys = function() {
	  return this.map.keys();
	};
	com.cognitect.transit.types.TransitSet.prototype.keys = com.cognitect.transit.types.TransitSet.prototype.keys;
	com.cognitect.transit.types.TransitSet.prototype.keySet = function() {
	  return this.map.keySet();
	};
	com.cognitect.transit.types.TransitSet.prototype.keySet = com.cognitect.transit.types.TransitSet.prototype.keySet;
	com.cognitect.transit.types.TransitSet.prototype.values = function() {
	  return this.map.values();
	};
	com.cognitect.transit.types.TransitSet.prototype.values = com.cognitect.transit.types.TransitSet.prototype.values;
	com.cognitect.transit.types.TransitSet.prototype.clone = function() {
	  var a = com.cognitect.transit.types.set();
	  this.forEach(function(b) {
	    a.add(b);
	  });
	  return a;
	};
	com.cognitect.transit.types.TransitSet.prototype.clone = com.cognitect.transit.types.TransitSet.prototype.clone;
	com.cognitect.transit.types.TransitSet.prototype[com.cognitect.transit.types.ITERATOR] = function() {
	  return this.values();
	};
	com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$equals = function(a) {
	  if (a instanceof com.cognitect.transit.types.TransitSet) {
	    if (this.size === a.size) {
	      return com.cognitect.transit.eq.equals(this.map, a.map);
	    }
	  } else {
	    return !1;
	  }
	};
	com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$hashCode = function(a) {
	  return com.cognitect.transit.eq.hashCode(this.map);
	};
	com.cognitect.transit.types.set = function(a) {
	  a = a || [];
	  for (var b = {}, c = [], d = 0, e = 0;e < a.length;e++) {
	    var f = com.cognitect.transit.eq.hashCode(a[e]), g = b[f];
	    if (null == g) {
	      c.push(f), b[f] = [a[e], a[e]], d++;
	    } else {
	      for (var f = !0, h = 0;h < g.length;h += 2) {
	        if (com.cognitect.transit.eq.equals(g[h], a[e])) {
	          f = !1;
	          break;
	        }
	      }
	      f && (g.push(a[e]), g.push(a[e]), d++);
	    }
	  }
	  return new com.cognitect.transit.types.TransitSet(new com.cognitect.transit.types.TransitMap(c, b, d));
	};
	com.cognitect.transit.types.isSet = function(a) {
	  return a instanceof com.cognitect.transit.types.TransitSet;
	};
	com.cognitect.transit.types.quoted = function(a) {
	  return com.cognitect.transit.types.taggedValue("'", a);
	};
	com.cognitect.transit.types.isQuoted = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "'" === a.tag;
	};
	com.cognitect.transit.types.list = function(a) {
	  return com.cognitect.transit.types.taggedValue("list", a);
	};
	com.cognitect.transit.types.isList = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "list" === a.tag;
	};
	com.cognitect.transit.types.link = function(a) {
	  return com.cognitect.transit.types.taggedValue("link", a);
	};
	com.cognitect.transit.types.isLink = function(a) {
	  return a instanceof com.cognitect.transit.types.TaggedValue && "link" === a.tag;
	};
	com.cognitect.transit.types.specialDouble = function(a) {
	  switch(a) {
	    case "-INF":
	      return -Infinity;
	    case "INF":
	      return Infinity;
	    case "NaN":
	      return NaN;
	    default:
	      throw Error("Invalid special double value " + a);;
	  }
	};
	com.cognitect.transit.handlers = {};
	com.cognitect.transit.handlers.ctorGuid = 0;
	com.cognitect.transit.handlers.ctorGuidProperty = "transit$guid$" + com.cognitect.transit.util.randomUUID();
	com.cognitect.transit.handlers.typeTag = function(a) {
	  if (null == a) {
	    return "null";
	  }
	  if (a === String) {
	    return "string";
	  }
	  if (a === Boolean) {
	    return "boolean";
	  }
	  if (a === Number) {
	    return "number";
	  }
	  if (a === Array) {
	    return "array";
	  }
	  if (a === Object) {
	    return "map";
	  }
	  var b = a[com.cognitect.transit.handlers.ctorGuidProperty];
	  null == b && ("undefined" != typeof Object.defineProperty ? (b = ++com.cognitect.transit.handlers.ctorGuid, Object.defineProperty(a, com.cognitect.transit.handlers.ctorGuidProperty, {value:b, enumerable:!1})) : a[com.cognitect.transit.handlers.ctorGuidProperty] = b = ++com.cognitect.transit.handlers.ctorGuid);
	  return b;
	};
	com.cognitect.transit.handlers.constructor = function(a) {
	  return null == a ? null : a.constructor;
	};
	com.cognitect.transit.handlers.padZeros = function(a, b) {
	  for (var c = a.toString(), d = c.length;d < b;d++) {
	    c = "0" + c;
	  }
	  return c;
	};
	com.cognitect.transit.handlers.stringableKeys = function(a) {
	  a = com.cognitect.transit.util.objectKeys(a);
	  for (var b = 0;b < a.length;b++) {
	  }
	  return !0;
	};
	com.cognitect.transit.handlers.NilHandler = function() {
	};
	com.cognitect.transit.handlers.NilHandler.prototype.tag = function(a) {
	  return "_";
	};
	com.cognitect.transit.handlers.NilHandler.prototype.rep = function(a) {
	  return null;
	};
	com.cognitect.transit.handlers.NilHandler.prototype.stringRep = function(a) {
	  return "null";
	};
	com.cognitect.transit.handlers.StringHandler = function() {
	};
	com.cognitect.transit.handlers.StringHandler.prototype.tag = function(a) {
	  return "s";
	};
	com.cognitect.transit.handlers.StringHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.StringHandler.prototype.stringRep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.NumberHandler = function() {
	};
	com.cognitect.transit.handlers.NumberHandler.prototype.tag = function(a) {
	  return "i";
	};
	com.cognitect.transit.handlers.NumberHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.NumberHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.IntegerHandler = function() {
	};
	com.cognitect.transit.handlers.IntegerHandler.prototype.tag = function(a) {
	  return "i";
	};
	com.cognitect.transit.handlers.IntegerHandler.prototype.rep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.IntegerHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.BooleanHandler = function() {
	};
	com.cognitect.transit.handlers.BooleanHandler.prototype.tag = function(a) {
	  return "?";
	};
	com.cognitect.transit.handlers.BooleanHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.BooleanHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.ArrayHandler = function() {
	};
	com.cognitect.transit.handlers.ArrayHandler.prototype.tag = function(a) {
	  return "array";
	};
	com.cognitect.transit.handlers.ArrayHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.ArrayHandler.prototype.stringRep = function(a) {
	  return null;
	};
	com.cognitect.transit.handlers.MapHandler = function() {
	};
	com.cognitect.transit.handlers.MapHandler.prototype.tag = function(a) {
	  return "map";
	};
	com.cognitect.transit.handlers.MapHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.MapHandler.prototype.stringRep = function(a) {
	  return null;
	};
	com.cognitect.transit.handlers.VerboseDateHandler = function() {
	};
	com.cognitect.transit.handlers.VerboseDateHandler.prototype.tag = function(a) {
	  return "t";
	};
	com.cognitect.transit.handlers.VerboseDateHandler.prototype.rep = function(a) {
	  return a.getUTCFullYear() + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCMonth() + 1, 2) + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCDate(), 2) + "T" + com.cognitect.transit.handlers.padZeros(a.getUTCHours(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCMinutes(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCSeconds(), 2) + "." + com.cognitect.transit.handlers.padZeros(a.getUTCMilliseconds(), 3) + "Z";
	};
	com.cognitect.transit.handlers.VerboseDateHandler.prototype.stringRep = function(a, b) {
	  return b.rep(a);
	};
	com.cognitect.transit.handlers.DateHandler = function() {
	};
	com.cognitect.transit.handlers.DateHandler.prototype.tag = function(a) {
	  return "m";
	};
	com.cognitect.transit.handlers.DateHandler.prototype.rep = function(a) {
	  return a.valueOf();
	};
	com.cognitect.transit.handlers.DateHandler.prototype.stringRep = function(a) {
	  return a.valueOf().toString();
	};
	com.cognitect.transit.handlers.DateHandler.prototype.getVerboseHandler = function(a) {
	  return new com.cognitect.transit.handlers.VerboseDateHandler;
	};
	com.cognitect.transit.handlers.UUIDHandler = function() {
	};
	com.cognitect.transit.handlers.UUIDHandler.prototype.tag = function(a) {
	  return "u";
	};
	com.cognitect.transit.handlers.UUIDHandler.prototype.rep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.UUIDHandler.prototype.stringRep = function(a) {
	  return a.toString();
	};
	com.cognitect.transit.handlers.KeywordHandler = function() {
	};
	com.cognitect.transit.handlers.KeywordHandler.prototype.tag = function(a) {
	  return ":";
	};
	com.cognitect.transit.handlers.KeywordHandler.prototype.rep = function(a) {
	  return a._name;
	};
	com.cognitect.transit.handlers.KeywordHandler.prototype.stringRep = function(a, b) {
	  return b.rep(a);
	};
	com.cognitect.transit.handlers.SymbolHandler = function() {
	};
	com.cognitect.transit.handlers.SymbolHandler.prototype.tag = function(a) {
	  return "$";
	};
	com.cognitect.transit.handlers.SymbolHandler.prototype.rep = function(a) {
	  return a._name;
	};
	com.cognitect.transit.handlers.SymbolHandler.prototype.stringRep = function(a, b) {
	  return b.rep(a);
	};
	com.cognitect.transit.handlers.TaggedHandler = function() {
	};
	com.cognitect.transit.handlers.TaggedHandler.prototype.tag = function(a) {
	  return a.tag;
	};
	com.cognitect.transit.handlers.TaggedHandler.prototype.rep = function(a) {
	  return a.rep;
	};
	com.cognitect.transit.handlers.TaggedHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.TransitSetHandler = function() {
	};
	com.cognitect.transit.handlers.TransitSetHandler.prototype.tag = function(a) {
	  return "set";
	};
	com.cognitect.transit.handlers.TransitSetHandler.prototype.rep = function(a) {
	  var b = [];
	  a.forEach(function(a, d) {
	    b.push(a);
	  });
	  return com.cognitect.transit.types.taggedValue("array", b);
	};
	com.cognitect.transit.handlers.TransitSetHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler = function() {
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.tag = function(a) {
	  return "map";
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.TransitMapHandler = function() {
	};
	com.cognitect.transit.handlers.TransitMapHandler.prototype.tag = function(a) {
	  return "map";
	};
	com.cognitect.transit.handlers.TransitMapHandler.prototype.rep = function(a) {
	  return a;
	};
	com.cognitect.transit.handlers.TransitMapHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.BufferHandler = function() {
	};
	com.cognitect.transit.handlers.BufferHandler.prototype.tag = function(a) {
	  return "b";
	};
	com.cognitect.transit.handlers.BufferHandler.prototype.rep = function(a) {
	  return a.toString("base64");
	};
	com.cognitect.transit.handlers.BufferHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler = function() {
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.tag = function(a) {
	  return "b";
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.rep = function(a) {
	  return com.cognitect.transit.util.Uint8ToBase64(a);
	};
	com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.stringRep = function(a, b) {
	  return null;
	};
	com.cognitect.transit.handlers.defaultHandlers = function(a) {
	  a.set(null, new com.cognitect.transit.handlers.NilHandler);
	  a.set(String, new com.cognitect.transit.handlers.StringHandler);
	  a.set(Number, new com.cognitect.transit.handlers.NumberHandler);
	  a.set(goog.math.Long, new com.cognitect.transit.handlers.IntegerHandler);
	  a.set(Boolean, new com.cognitect.transit.handlers.BooleanHandler);
	  a.set(Array, new com.cognitect.transit.handlers.ArrayHandler);
	  a.set(Object, new com.cognitect.transit.handlers.MapHandler);
	  a.set(Date, new com.cognitect.transit.handlers.DateHandler);
	  a.set(com.cognitect.transit.types.UUID, new com.cognitect.transit.handlers.UUIDHandler);
	  a.set(com.cognitect.transit.types.Keyword, new com.cognitect.transit.handlers.KeywordHandler);
	  a.set(com.cognitect.transit.types.Symbol, new com.cognitect.transit.handlers.SymbolHandler);
	  a.set(com.cognitect.transit.types.TaggedValue, new com.cognitect.transit.handlers.TaggedHandler);
	  a.set(com.cognitect.transit.types.TransitSet, new com.cognitect.transit.handlers.TransitSetHandler);
	  a.set(com.cognitect.transit.types.TransitArrayMap, new com.cognitect.transit.handlers.TransitArrayMapHandler);
	  a.set(com.cognitect.transit.types.TransitMap, new com.cognitect.transit.handlers.TransitMapHandler);
	  "undefined" != typeof Buffer && a.set(Buffer, new com.cognitect.transit.handlers.BufferHandler);
	  "undefined" != typeof Uint8Array && a.set(Uint8Array, new com.cognitect.transit.handlers.Uint8ArrayHandler);
	  return a;
	};
	com.cognitect.transit.handlers.Handlers = function() {
	  this.handlers = {};
	  com.cognitect.transit.handlers.defaultHandlers(this);
	};
	com.cognitect.transit.handlers.Handlers.prototype.get = function(a) {
	  var b = null, b = "string" === typeof a ? this.handlers[a] : this.handlers[com.cognitect.transit.handlers.typeTag(a)];
	  return null != b ? b : this.handlers["default"];
	};
	com.cognitect.transit.handlers.Handlers.prototype.get = com.cognitect.transit.handlers.Handlers.prototype.get;
	com.cognitect.transit.handlers.validTag = function(a) {
	  switch(a) {
	    case "null":
	    ;
	    case "string":
	    ;
	    case "boolean":
	    ;
	    case "number":
	    ;
	    case "array":
	    ;
	    case "map":
	      return !1;
	  }
	  return !0;
	};
	com.cognitect.transit.handlers.Handlers.prototype.set = function(a, b) {
	  "string" === typeof a && com.cognitect.transit.handlers.validTag(a) ? this.handlers[a] = b : this.handlers[com.cognitect.transit.handlers.typeTag(a)] = b;
	};
	com.cognitect.transit.impl = {};
	com.cognitect.transit.impl.decoder = {};
	com.cognitect.transit.impl.decoder.Tag = function(a) {
	  this.str = a;
	};
	com.cognitect.transit.impl.decoder.tag = function(a) {
	  return new com.cognitect.transit.impl.decoder.Tag(a);
	};
	com.cognitect.transit.impl.decoder.isTag = function(a) {
	  return a && a instanceof com.cognitect.transit.impl.decoder.Tag;
	};
	com.cognitect.transit.impl.decoder.isGroundHandler = function(a) {
	  switch(a) {
	    case "_":
	    ;
	    case "s":
	    ;
	    case "?":
	    ;
	    case "i":
	    ;
	    case "d":
	    ;
	    case "b":
	    ;
	    case "'":
	    ;
	    case "array":
	    ;
	    case "map":
	      return !0;
	  }
	  return !1;
	};
	com.cognitect.transit.impl.decoder.Decoder = function(a) {
	  this.options = a || {};
	  this.handlers = {};
	  for (var b in this.defaults.handlers) {
	    this.handlers[b] = this.defaults.handlers[b];
	  }
	  for (b in this.options.handlers) {
	    if (com.cognitect.transit.impl.decoder.isGroundHandler(b)) {
	      throw Error('Cannot override handler for ground type "' + b + '"');
	    }
	    this.handlers[b] = this.options.handlers[b];
	  }
	  this.preferStrings = null != this.options.preferStrings ? this.options.preferStrings : this.defaults.preferStrings;
	  this.preferBuffers = null != this.options.preferBuffers ? this.options.preferBuffers : this.defaults.preferBuffers;
	  this.defaultHandler = this.options.defaultHandler || this.defaults.defaultHandler;
	  this.mapBuilder = this.options.mapBuilder;
	  this.arrayBuilder = this.options.arrayBuilder;
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.defaults = {handlers:{_:function(a, b) {
	  return com.cognitect.transit.types.nullValue();
	}, "?":function(a, b) {
	  return com.cognitect.transit.types.boolValue(a);
	}, b:function(a, b) {
	  return com.cognitect.transit.types.binary(a, b);
	}, i:function(a, b) {
	  return com.cognitect.transit.types.intValue(a);
	}, n:function(a, b) {
	  return com.cognitect.transit.types.bigInteger(a);
	}, d:function(a, b) {
	  return com.cognitect.transit.types.floatValue(a);
	}, f:function(a, b) {
	  return com.cognitect.transit.types.bigDecimalValue(a);
	}, c:function(a, b) {
	  return com.cognitect.transit.types.charValue(a);
	}, ":":function(a, b) {
	  return com.cognitect.transit.types.keyword(a);
	}, $:function(a, b) {
	  return com.cognitect.transit.types.symbol(a);
	}, r:function(a, b) {
	  return com.cognitect.transit.types.uri(a);
	}, z:function(a, b) {
	  return com.cognitect.transit.types.specialDouble(a);
	}, "'":function(a, b) {
	  return a;
	}, m:function(a, b) {
	  return com.cognitect.transit.types.date(a);
	}, t:function(a, b) {
	  return com.cognitect.transit.types.verboseDate(a);
	}, u:function(a, b) {
	  return com.cognitect.transit.types.uuid(a);
	}, set:function(a, b) {
	  return com.cognitect.transit.types.set(a);
	}, list:function(a, b) {
	  return com.cognitect.transit.types.list(a);
	}, link:function(a, b) {
	  return com.cognitect.transit.types.link(a);
	}, cmap:function(a, b) {
	  return com.cognitect.transit.types.map(a, !1);
	}}, defaultHandler:function(a, b) {
	  return com.cognitect.transit.types.taggedValue(a, b);
	}, preferStrings:!0, preferBuffers:!0};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decode = function(a, b, c, d) {
	  if (null == a) {
	    return null;
	  }
	  switch(typeof a) {
	    case "string":
	      return this.decodeString(a, b, c, d);
	    case "object":
	      return com.cognitect.transit.util.isArray(a) ? "^ " === a[0] ? this.decodeArrayHash(a, b, c, d) : this.decodeArray(a, b, c, d) : this.decodeHash(a, b, c, d);
	  }
	  return a;
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decode = com.cognitect.transit.impl.decoder.Decoder.prototype.decode;
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeString = function(a, b, c, d) {
	  return com.cognitect.transit.caching.isCacheable(a, c) ? (a = this.parseString(a, b, !1), b && b.write(a, c), a) : com.cognitect.transit.caching.isCacheCode(a) ? b.read(a, c) : this.parseString(a, b, c);
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeHash = function(a, b, c, d) {
	  c = com.cognitect.transit.util.objectKeys(a);
	  var e = c[0];
	  d = 1 == c.length ? this.decode(e, b, !1, !1) : null;
	  if (com.cognitect.transit.impl.decoder.isTag(d)) {
	    return a = a[e], c = this.handlers[d.str], null != c ? c(this.decode(a, b, !1, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, !1, !1));
	  }
	  if (this.mapBuilder) {
	    if (c.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD && this.mapBuilder.fromArray) {
	      var f = [];
	      for (d = 0;d < c.length;d++) {
	        e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
	      }
	      return this.mapBuilder.fromArray(f, a);
	    }
	    f = this.mapBuilder.init(a);
	    for (d = 0;d < c.length;d++) {
	      e = c[d], f = this.mapBuilder.add(f, this.decode(e, b, !0, !1), this.decode(a[e], b, !1, !1), a);
	    }
	    return this.mapBuilder.finalize(f, a);
	  }
	  f = [];
	  for (d = 0;d < c.length;d++) {
	    e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
	  }
	  return com.cognitect.transit.types.map(f, !1);
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArrayHash = function(a, b, c, d) {
	  if (this.mapBuilder) {
	    if (a.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD + 1 && this.mapBuilder.fromArray) {
	      d = [];
	      for (c = 1;c < a.length;c += 2) {
	        d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
	      }
	      return this.mapBuilder.fromArray(d, a);
	    }
	    d = this.mapBuilder.init(a);
	    for (c = 1;c < a.length;c += 2) {
	      d = this.mapBuilder.add(d, this.decode(a[c], b, !0, !1), this.decode(a[c + 1], b, !1, !1), a);
	    }
	    return this.mapBuilder.finalize(d, a);
	  }
	  d = [];
	  for (c = 1;c < a.length;c += 2) {
	    d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
	  }
	  return com.cognitect.transit.types.map(d, !1);
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArray = function(a, b, c, d) {
	  if (d) {
	    var e = [];
	    for (d = 0;d < a.length;d++) {
	      e.push(this.decode(a[d], b, c, !1));
	    }
	    return e;
	  }
	  e = b && b.idx;
	  if (2 === a.length && "string" === typeof a[0] && (d = this.decode(a[0], b, !1, !1), com.cognitect.transit.impl.decoder.isTag(d))) {
	    return a = a[1], e = this.handlers[d.str], null != e ? e = e(this.decode(a, b, c, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, c, !1));
	  }
	  b && e != b.idx && (b.idx = e);
	  if (this.arrayBuilder) {
	    if (32 >= a.length && this.arrayBuilder.fromArray) {
	      e = [];
	      for (d = 0;d < a.length;d++) {
	        e.push(this.decode(a[d], b, c, !1));
	      }
	      return this.arrayBuilder.fromArray(e, a);
	    }
	    e = this.arrayBuilder.init(a);
	    for (d = 0;d < a.length;d++) {
	      e = this.arrayBuilder.add(e, this.decode(a[d], b, c, !1), a);
	    }
	    return this.arrayBuilder.finalize(e, a);
	  }
	  e = [];
	  for (d = 0;d < a.length;d++) {
	    e.push(this.decode(a[d], b, c, !1));
	  }
	  return e;
	};
	com.cognitect.transit.impl.decoder.Decoder.prototype.parseString = function(a, b, c) {
	  if (a.charAt(0) === com.cognitect.transit.delimiters.ESC) {
	    b = a.charAt(1);
	    if (b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES) {
	      return a.substring(1);
	    }
	    if (b === com.cognitect.transit.delimiters.TAG) {
	      return com.cognitect.transit.impl.decoder.tag(a.substring(2));
	    }
	    c = this.handlers[b];
	    return null == c ? this.defaultHandler(b, a.substring(2)) : c(a.substring(2), this);
	  }
	  return a;
	};
	com.cognitect.transit.impl.decoder.decoder = function(a) {
	  return new com.cognitect.transit.impl.decoder.Decoder(a);
	};
	com.cognitect.transit.impl.reader = {};
	com.cognitect.transit.impl.reader.JSONUnmarshaller = function(a) {
	  this.decoder = new com.cognitect.transit.impl.decoder.Decoder(a);
	};
	com.cognitect.transit.impl.reader.JSONUnmarshaller.prototype.unmarshal = function(a, b) {
	  return this.decoder.decode(JSON.parse(a), b);
	};
	com.cognitect.transit.impl.reader.Reader = function(a, b) {
	  this.unmarshaller = a;
	  this.options = b || {};
	  this.cache = this.options.cache ? this.options.cache : new com.cognitect.transit.caching.ReadCache;
	};
	com.cognitect.transit.impl.reader.Reader.prototype.read = function(a) {
	  a = this.unmarshaller.unmarshal(a, this.cache);
	  this.cache.clear();
	  return a;
	};
	com.cognitect.transit.impl.reader.Reader.prototype.read = com.cognitect.transit.impl.reader.Reader.prototype.read;
	com.cognitect.transit.impl.writer = {};
	com.cognitect.transit.impl.writer.escape = function(a) {
	  if (0 < a.length) {
	    var b = a.charAt(0);
	    return b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES ? com.cognitect.transit.delimiters.ESC + a : a;
	  }
	  return a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller = function(a) {
	  this.opts = a || {};
	  this.preferStrings = null != this.opts.preferStrings ? this.opts.preferStrings : !0;
	  this.objectBuilder = this.opts.objectBuilder || null;
	  this.handlers = new com.cognitect.transit.handlers.Handlers;
	  if (a = this.opts.handlers) {
	    if (com.cognitect.transit.util.isArray(a) || !a.forEach) {
	      throw Error('transit writer "handlers" option must be a map');
	    }
	    var b = this;
	    a.forEach(function(a, d) {
	      if (void 0 !== d) {
	        b.handlers.set(d, a);
	      } else {
	        throw Error("Cannot create handler for JavaScript undefined");
	      }
	    });
	  }
	  this.handlerForForeign = this.opts.handlerForForeign;
	  this.unpack = this.opts.unpack || function(a) {
	    return com.cognitect.transit.types.isArrayMap(a) && null === a.backingMap ? a._entries : !1;
	  };
	  this.verbose = this.opts && this.opts.verbose || !1;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.handler = function(a) {
	  var b = this.handlers.get(com.cognitect.transit.handlers.constructor(a));
	  return null != b ? b : (a = a && a.transitTag) ? this.handlers.get(a) : null;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.registerHandler = function(a, b) {
	  this.handlers.set(a, b);
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitNil = function(a, b) {
	  return a ? this.emitString(com.cognitect.transit.delimiters.ESC, "_", "", a, b) : null;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitString = function(a, b, c, d, e) {
	  a = a + b + c;
	  return e ? e.write(a, d) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBoolean = function(a, b, c) {
	  return b ? this.emitString(com.cognitect.transit.delimiters.ESC, "?", a.toString()[0], b, c) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitInteger = function(a, b, c) {
	  return Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "INF", b, c) : -Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "-INF", b, c) : isNaN(a) ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "NaN", b, c) : b || "string" === typeof a || a instanceof goog.math.Long ? this.emitString(com.cognitect.transit.delimiters.ESC, "i", a.toString(), b, c) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitDouble = function(a, b, c) {
	  return b ? this.emitString(a.ESC, "d", a, b, c) : a;
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBinary = function(a, b, c) {
	  return this.emitString(com.cognitect.transit.delimiters.ESC, "b", a, b, c);
	};
	com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitQuoted = function(a, b, c) {
	  if (a.verbose) {
	    a = {};
	    var d = this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c);
	    a[d] = com.cognitect.transit.impl.writer.marshal(this, b, !1, c);
	    return a;
	  }
	  return [this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c), com.cognitect.transit.impl.writer.marshal(this, b, !1, c)];
	};
	com.cognitect.transit.impl.writer.emitObjects = function(a, b, c) {
	  var d = [];
	  if (com.cognitect.transit.util.isArray(b)) {
	    for (var e = 0;e < b.length;e++) {
	      d.push(com.cognitect.transit.impl.writer.marshal(a, b[e], !1, c));
	    }
	  } else {
	    b.forEach(function(b, e) {
	      d.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, c));
	    });
	  }
	  return d;
	};
	com.cognitect.transit.impl.writer.emitArray = function(a, b, c, d) {
	  return com.cognitect.transit.impl.writer.emitObjects(a, b, d);
	};
	com.cognitect.transit.impl.writer.isStringableKey = function(a, b) {
	  if ("string" !== typeof b) {
	    var c = a.handler(b);
	    return c && 1 === c.tag(b).length;
	  }
	  return !0;
	};
	com.cognitect.transit.impl.writer.stringableKeys = function(a, b) {
	  var c = a.unpack(b), d = !0;
	  if (c) {
	    for (var e = 0;e < c.length && (d = com.cognitect.transit.impl.writer.isStringableKey(a, c[e]), d);e += 2) {
	    }
	    return d;
	  }
	  if (b.keys && (c = b.keys(), e = null, c.next)) {
	    for (e = c.next();!e.done;) {
	      d = com.cognitect.transit.impl.writer.isStringableKey(a, e.value);
	      if (!d) {
	        break;
	      }
	      e = c.next();
	    }
	    return d;
	  }
	  if (b.forEach) {
	    return b.forEach(function(b, c) {
	      d = d && com.cognitect.transit.impl.writer.isStringableKey(a, c);
	    }), d;
	  }
	  throw Error("Cannot walk keys of object type " + com.cognitect.transit.handlers.constructor(b).name);
	};
	com.cognitect.transit.impl.writer.isForeignObject = function(a) {
	  if (a.constructor.transit$isObject) {
	    return !0;
	  }
	  var b = a.constructor.toString(), b = b.substr(9), b = b.substr(0, b.indexOf("("));
	  isObject = "Object" == b;
	  "undefined" != typeof Object.defineProperty ? Object.defineProperty(a.constructor, "transit$isObject", {value:isObject, enumerable:!1}) : a.constructor.transit$isObject = isObject;
	  return isObject;
	};
	com.cognitect.transit.impl.writer.emitMap = function(a, b, c, d) {
	  var e = null, f = null, g = null, e = null;
	  c = 0;
	  if (b.constructor === Object || null != b.forEach || a.handlerForForeign && com.cognitect.transit.impl.writer.isForeignObject(b)) {
	    if (a.verbose) {
	      if (null != b.forEach) {
	        if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
	          var h = {};
	          b.forEach(function(b, c) {
	            h[com.cognitect.transit.impl.writer.marshal(a, c, !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
	          });
	        } else {
	          e = a.unpack(b);
	          f = [];
	          g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
	          if (e) {
	            for (;c < e.length;c += 2) {
	              f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, !1)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
	            }
	          } else {
	            b.forEach(function(b, c) {
	              f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, !1));
	              f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
	            });
	          }
	          h = {};
	          h[g] = f;
	        }
	      } else {
	        for (e = com.cognitect.transit.util.objectKeys(b), h = {};c < e.length;c++) {
	          h[com.cognitect.transit.impl.writer.marshal(a, e[c], !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d);
	        }
	      }
	      return h;
	    }
	    if (null != b.forEach) {
	      if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
	        e = a.unpack(b);
	        h = ["^ "];
	        if (e) {
	          for (;c < e.length;c += 2) {
	            h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
	          }
	        } else {
	          b.forEach(function(b, c) {
	            h.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, d));
	            h.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
	          });
	        }
	        return h;
	      }
	      e = a.unpack(b);
	      f = [];
	      g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
	      if (e) {
	        for (;c < e.length;c += 2) {
	          f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, d)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
	        }
	      } else {
	        b.forEach(function(b, c) {
	          f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, d));
	          f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
	        });
	      }
	      return [g, f];
	    }
	    h = ["^ "];
	    for (e = com.cognitect.transit.util.objectKeys(b);c < e.length;c++) {
	      h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d));
	    }
	    return h;
	  }
	  if (null != a.objectBuilder) {
	    return a.objectBuilder(b, function(b) {
	      return com.cognitect.transit.impl.writer.marshal(a, b, !0, d);
	    }, function(b) {
	      return com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
	    });
	  }
	  c = com.cognitect.transit.handlers.constructor(b).name;
	  e = Error("Cannot write " + c);
	  e.data = {obj:b, type:c};
	  throw e;
	};
	com.cognitect.transit.impl.writer.emitTaggedMap = function(a, b, c, d, e) {
	  return a.verbose ? (d = {}, d[a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e)] = com.cognitect.transit.impl.writer.marshal(a, c, !1, e), d) : [a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e), com.cognitect.transit.impl.writer.marshal(a, c, !1, e)];
	};
	com.cognitect.transit.impl.writer.emitEncoded = function(a, b, c, d, e, f, g) {
	  if (1 === c.length) {
	    if ("string" === typeof d) {
	      return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
	    }
	    if (f || a.preferStrings) {
	      (d = a.verbose && b.getVerboseHandler()) ? (c = d.tag(e), d = d.stringRep(e, d)) : d = b.stringRep(e, b);
	      if (null !== d) {
	        return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
	      }
	      a = Error('Tag "' + c + '" cannot be encoded as string');
	      a.data = {tag:c, rep:d, obj:e};
	      throw a;
	    }
	  }
	  return com.cognitect.transit.impl.writer.emitTaggedMap(a, c, d, f, g);
	};
	com.cognitect.transit.impl.writer.marshal = function(a, b, c, d) {
	  var e = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null), f = e ? e.tag(b) : null, g = e ? e.rep(b) : null;
	  if (null != e && null != f) {
	    switch(f) {
	      case "_":
	        return a.emitNil(c, d);
	      case "s":
	        return a.emitString("", "", com.cognitect.transit.impl.writer.escape(g), c, d);
	      case "?":
	        return a.emitBoolean(g, c, d);
	      case "i":
	        return a.emitInteger(g, c, d);
	      case "d":
	        return a.emitDouble(g, c, d);
	      case "b":
	        return a.emitBinary(g, c, d);
	      case "'":
	        return a.emitQuoted(a, g, d);
	      case "array":
	        return com.cognitect.transit.impl.writer.emitArray(a, g, c, d);
	      case "map":
	        return com.cognitect.transit.impl.writer.emitMap(a, g, c, d);
	      default:
	        return com.cognitect.transit.impl.writer.emitEncoded(a, e, f, g, b, c, d);
	    }
	  } else {
	    throw a = com.cognitect.transit.handlers.constructor(b).name, c = Error("Cannot write " + a), c.data = {obj:b, type:a}, c;
	  }
	};
	com.cognitect.transit.impl.writer.maybeQuoted = function(a, b) {
	  var c = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null);
	  if (null != c) {
	    return 1 === c.tag(b).length ? com.cognitect.transit.types.quoted(b) : b;
	  }
	  var c = com.cognitect.transit.handlers.constructor(b).name, d = Error("Cannot write " + c);
	  d.data = {obj:b, type:c};
	  throw d;
	};
	com.cognitect.transit.impl.writer.marshalTop = function(a, b, c, d) {
	  return JSON.stringify(com.cognitect.transit.impl.writer.marshal(a, com.cognitect.transit.impl.writer.maybeQuoted(a, b), c, d));
	};
	com.cognitect.transit.impl.writer.Writer = function(a, b) {
	  this._marshaller = a;
	  this.options = b || {};
	  this.cache = !1 === this.options.cache ? null : this.options.cache ? this.options.cache : new com.cognitect.transit.caching.WriteCache;
	};
	com.cognitect.transit.impl.writer.Writer.prototype.marshaller = function() {
	  return this._marshaller;
	};
	com.cognitect.transit.impl.writer.Writer.prototype.marshaller = com.cognitect.transit.impl.writer.Writer.prototype.marshaller;
	com.cognitect.transit.impl.writer.Writer.prototype.write = function(a, b) {
	  var c = null, c = b || {}, d = c.asMapKey || !1, e = this._marshaller.verbose ? !1 : this.cache, c = !1 === c.marshalTop ? com.cognitect.transit.impl.writer.marshal(this._marshaller, a, d, e) : com.cognitect.transit.impl.writer.marshalTop(this._marshaller, a, d, e);
	  null != this.cache && this.cache.clear();
	  return c;
	};
	com.cognitect.transit.impl.writer.Writer.prototype.write = com.cognitect.transit.impl.writer.Writer.prototype.write;
	com.cognitect.transit.impl.writer.Writer.prototype.register = function(a, b) {
	  this._marshaller.registerHandler(a, b);
	};
	com.cognitect.transit.impl.writer.Writer.prototype.register = com.cognitect.transit.impl.writer.Writer.prototype.register;
	var TRANSIT_DEV = !0, TRANSIT_NODE_TARGET = !0, TRANSIT_BROWSER_TARGET = !1, TRANSIT_BROWSER_AMD_TARGET = !1;
	com.cognitect.transit.reader = function(a, b) {
	  if ("json" === a || "json-verbose" === a || null == a) {
	    var c = new com.cognitect.transit.impl.reader.JSONUnmarshaller(b);
	    return new com.cognitect.transit.impl.reader.Reader(c, b);
	  }
	  throw Error("Cannot create reader of type " + a);
	};
	com.cognitect.transit.writer = function(a, b) {
	  if ("json" === a || "json-verbose" === a || null == a) {
	    "json-verbose" === a && (null == b && (b = {}), b.verbose = !0);
	    var c = new com.cognitect.transit.impl.writer.JSONMarshaller(b);
	    return new com.cognitect.transit.impl.writer.Writer(c, b);
	  }
	  c = Error('Type must be "json"');
	  c.data = {type:a};
	  throw c;
	};
	com.cognitect.transit.makeWriteHandler = function(a) {
	  var b = function() {
	  };
	  b.prototype.tag = a.tag;
	  b.prototype.rep = a.rep;
	  b.prototype.stringRep = a.stringRep;
	  b.prototype.getVerboseHandler = a.getVerboseHandler;
	  return new b;
	};
	com.cognitect.transit.makeBuilder = function(a) {
	  var b = function() {
	  };
	  b.prototype.init = a.init;
	  b.prototype.add = a.add;
	  b.prototype.finalize = a.finalize;
	  b.prototype.fromArray = a.fromArray;
	  return new b;
	};
	com.cognitect.transit.date = com.cognitect.transit.types.date;
	com.cognitect.transit.integer = com.cognitect.transit.types.intValue;
	com.cognitect.transit.isInteger = com.cognitect.transit.types.isInteger;
	com.cognitect.transit.uuid = com.cognitect.transit.types.uuid;
	com.cognitect.transit.isUUID = com.cognitect.transit.types.isUUID;
	com.cognitect.transit.bigInt = com.cognitect.transit.types.bigInteger;
	com.cognitect.transit.isBigInt = com.cognitect.transit.types.isBigInteger;
	com.cognitect.transit.bigDec = com.cognitect.transit.types.bigDecimalValue;
	com.cognitect.transit.isBigDec = com.cognitect.transit.types.isBigDecimal;
	com.cognitect.transit.keyword = com.cognitect.transit.types.keyword;
	com.cognitect.transit.isKeyword = com.cognitect.transit.types.isKeyword;
	com.cognitect.transit.symbol = com.cognitect.transit.types.symbol;
	com.cognitect.transit.isSymbol = com.cognitect.transit.types.isSymbol;
	com.cognitect.transit.binary = com.cognitect.transit.types.binary;
	com.cognitect.transit.isBinary = com.cognitect.transit.types.isBinary;
	com.cognitect.transit.uri = com.cognitect.transit.types.uri;
	com.cognitect.transit.isURI = com.cognitect.transit.types.isURI;
	com.cognitect.transit.map = com.cognitect.transit.types.map;
	com.cognitect.transit.isMap = com.cognitect.transit.types.isMap;
	com.cognitect.transit.set = com.cognitect.transit.types.set;
	com.cognitect.transit.isSet = com.cognitect.transit.types.isSet;
	com.cognitect.transit.list = com.cognitect.transit.types.list;
	com.cognitect.transit.isList = com.cognitect.transit.types.isList;
	com.cognitect.transit.quoted = com.cognitect.transit.types.quoted;
	com.cognitect.transit.isQuoted = com.cognitect.transit.types.isQuoted;
	com.cognitect.transit.tagged = com.cognitect.transit.types.taggedValue;
	com.cognitect.transit.isTaggedValue = com.cognitect.transit.types.isTaggedValue;
	com.cognitect.transit.link = com.cognitect.transit.types.link;
	com.cognitect.transit.isLink = com.cognitect.transit.types.isLink;
	com.cognitect.transit.hash = com.cognitect.transit.eq.hashCode;
	com.cognitect.transit.hashMapLike = com.cognitect.transit.eq.hashMapLike;
	com.cognitect.transit.hashArrayLike = com.cognitect.transit.eq.hashArrayLike;
	com.cognitect.transit.equals = com.cognitect.transit.eq.equals;
	com.cognitect.transit.extendToEQ = com.cognitect.transit.eq.extendToEQ;
	com.cognitect.transit.mapToObject = function(a) {
	  var b = {};
	  a.forEach(function(a, d) {
	    if ("string" !== typeof d) {
	      throw Error("Cannot convert map with non-string keys");
	    }
	    b[d] = a;
	  });
	  return b;
	};
	com.cognitect.transit.objectToMap = function(a) {
	  var b = com.cognitect.transit.map(), c;
	  for (c in a) {
	    a.hasOwnProperty(c) && b.set(c, a[c]);
	  }
	  return b;
	};
	com.cognitect.transit.decoder = com.cognitect.transit.impl.decoder.decoder;
	com.cognitect.transit.readCache = com.cognitect.transit.caching.readCache;
	com.cognitect.transit.writeCache = com.cognitect.transit.caching.writeCache;
	com.cognitect.transit.UUIDfromString = com.cognitect.transit.types.UUIDfromString;
	com.cognitect.transit.randomUUID = com.cognitect.transit.util.randomUUID;
	com.cognitect.transit.stringableKeys = com.cognitect.transit.impl.writer.stringableKeys;
	TRANSIT_BROWSER_TARGET && (goog.exportSymbol("transit.reader", com.cognitect.transit.reader), goog.exportSymbol("transit.writer", com.cognitect.transit.writer), goog.exportSymbol("transit.makeBuilder", com.cognitect.transit.makeBuilder), goog.exportSymbol("transit.makeWriteHandler", com.cognitect.transit.makeWriteHandler), goog.exportSymbol("transit.date", com.cognitect.transit.types.date), goog.exportSymbol("transit.integer", com.cognitect.transit.types.intValue), goog.exportSymbol("transit.isInteger", 
	com.cognitect.transit.types.isInteger), goog.exportSymbol("transit.uuid", com.cognitect.transit.types.uuid), goog.exportSymbol("transit.isUUID", com.cognitect.transit.types.isUUID), goog.exportSymbol("transit.bigInt", com.cognitect.transit.types.bigInteger), goog.exportSymbol("transit.isBigInt", com.cognitect.transit.types.isBigInteger), goog.exportSymbol("transit.bigDec", com.cognitect.transit.types.bigDecimalValue), goog.exportSymbol("transit.isBigDec", com.cognitect.transit.types.isBigDecimal), 
	goog.exportSymbol("transit.keyword", com.cognitect.transit.types.keyword), goog.exportSymbol("transit.isKeyword", com.cognitect.transit.types.isKeyword), goog.exportSymbol("transit.symbol", com.cognitect.transit.types.symbol), goog.exportSymbol("transit.isSymbol", com.cognitect.transit.types.isSymbol), goog.exportSymbol("transit.binary", com.cognitect.transit.types.binary), goog.exportSymbol("transit.isBinary", com.cognitect.transit.types.isBinary), goog.exportSymbol("transit.uri", com.cognitect.transit.types.uri), 
	goog.exportSymbol("transit.isURI", com.cognitect.transit.types.isURI), goog.exportSymbol("transit.map", com.cognitect.transit.types.map), goog.exportSymbol("transit.isMap", com.cognitect.transit.types.isMap), goog.exportSymbol("transit.set", com.cognitect.transit.types.set), goog.exportSymbol("transit.isSet", com.cognitect.transit.types.isSet), goog.exportSymbol("transit.list", com.cognitect.transit.types.list), goog.exportSymbol("transit.isList", com.cognitect.transit.types.isList), goog.exportSymbol("transit.quoted", 
	com.cognitect.transit.types.quoted), goog.exportSymbol("transit.isQuoted", com.cognitect.transit.types.isQuoted), goog.exportSymbol("transit.tagged", com.cognitect.transit.types.taggedValue), goog.exportSymbol("transit.isTaggedValue", com.cognitect.transit.types.isTaggedValue), goog.exportSymbol("transit.link", com.cognitect.transit.types.link), goog.exportSymbol("transit.isLink", com.cognitect.transit.types.isLink), goog.exportSymbol("transit.hash", com.cognitect.transit.eq.hashCode), goog.exportSymbol("transit.hashMapLike", 
	com.cognitect.transit.eq.hashMapLike), goog.exportSymbol("transit.hashArrayLike", com.cognitect.transit.eq.hashArrayLike), goog.exportSymbol("transit.equals", com.cognitect.transit.eq.equals), goog.exportSymbol("transit.extendToEQ", com.cognitect.transit.eq.extendToEQ), goog.exportSymbol("transit.mapToObject", com.cognitect.transit.mapToObject), goog.exportSymbol("transit.objectToMap", com.cognitect.transit.objectToMap), goog.exportSymbol("transit.decoder", com.cognitect.transit.impl.decoder.decoder), 
	goog.exportSymbol("transit.UUIDfromString", com.cognitect.transit.types.UUIDfromString), goog.exportSymbol("transit.randomUUID", com.cognitect.transit.util.randomUUID), goog.exportSymbol("transit.stringableKeys", com.cognitect.transit.impl.writer.stringableKeys), goog.exportSymbol("transit.readCache", com.cognitect.transit.caching.readCache), goog.exportSymbol("transit.writeCache", com.cognitect.transit.caching.writeCache));
	TRANSIT_NODE_TARGET && (module.exports = {reader:com.cognitect.transit.reader, writer:com.cognitect.transit.writer, makeBuilder:com.cognitect.transit.makeBuilder, makeWriteHandler:com.cognitect.transit.makeWriteHandler, date:com.cognitect.transit.types.date, integer:com.cognitect.transit.types.intValue, isInteger:com.cognitect.transit.types.isInteger, uuid:com.cognitect.transit.types.uuid, isUUID:com.cognitect.transit.types.isUUID, bigInt:com.cognitect.transit.types.bigInteger, isBigInt:com.cognitect.transit.types.isBigInteger, 
	bigDec:com.cognitect.transit.types.bigDecimalValue, isBigDec:com.cognitect.transit.types.isBigDecimal, keyword:com.cognitect.transit.types.keyword, isKeyword:com.cognitect.transit.types.isKeyword, symbol:com.cognitect.transit.types.symbol, isSymbol:com.cognitect.transit.types.isSymbol, binary:com.cognitect.transit.types.binary, isBinary:com.cognitect.transit.types.isBinary, uri:com.cognitect.transit.types.uri, isURI:com.cognitect.transit.types.isURI, map:com.cognitect.transit.types.map, isMap:com.cognitect.transit.types.isMap, 
	set:com.cognitect.transit.types.set, isSet:com.cognitect.transit.types.isSet, list:com.cognitect.transit.types.list, isList:com.cognitect.transit.types.isList, quoted:com.cognitect.transit.types.quoted, isQuoted:com.cognitect.transit.types.isQuoted, tagged:com.cognitect.transit.types.taggedValue, isTaggedValue:com.cognitect.transit.types.isTaggedValue, link:com.cognitect.transit.types.link, isLink:com.cognitect.transit.types.isLink, hash:com.cognitect.transit.eq.hashCode, hashArrayLike:com.cognitect.transit.eq.hashArrayLike, 
	hashMapLike:com.cognitect.transit.eq.hashMapLike, equals:com.cognitect.transit.eq.equals, extendToEQ:com.cognitect.transit.eq.extendToEQ, mapToObject:com.cognitect.transit.mapToObject, objectToMap:com.cognitect.transit.objectToMap, decoder:com.cognitect.transit.impl.decoder.decoder, UUIDfromString:com.cognitect.transit.types.UUIDfromString, randomUUID:com.cognitect.transit.util.randomUUID, stringableKeys:com.cognitect.transit.impl.writer.stringableKeys, readCache:com.cognitect.transit.caching.readCache, 
	writeCache:com.cognitect.transit.caching.writeCache});


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40).Buffer))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(41)
	var ieee754 = __webpack_require__(42)
	var isArray = __webpack_require__(43)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40).Buffer, (function() { return this; }())))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 42 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 43 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Enforester = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _transforms = __webpack_require__(33);

	var _immutable = __webpack_require__(9);

	var _errors = __webpack_require__(12);

	var _operators = __webpack_require__(45);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _scope = __webpack_require__(31);

	var _macroContext = __webpack_require__(46);

	var _macroContext2 = _interopRequireDefault(_macroContext);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EXPR_LOOP_OPERATOR = {};
	var EXPR_LOOP_NO_CHANGE = {};
	var EXPR_LOOP_EXPANSION = {};

	var Enforester = exports.Enforester = function () {
	  function Enforester(stxl, prev, context) {
	    _classCallCheck(this, Enforester);

	    this.done = false;
	    (0, _errors.assert)(_immutable.List.isList(stxl), "expecting a list of terms to enforest");
	    (0, _errors.assert)(_immutable.List.isList(prev), "expecting a list of terms to enforest");
	    (0, _errors.assert)(context, "expecting a context to enforest");
	    this.term = null;

	    this.rest = stxl;
	    this.prev = prev;

	    this.context = context;
	  }

	  _createClass(Enforester, [{
	    key: "peek",
	    value: function peek() {
	      var n = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	      return this.rest.get(n);
	    }
	  }, {
	    key: "advance",
	    value: function advance() {
	      var ret = this.rest.first();
	      this.rest = this.rest.rest();
	      return ret;
	    }

	    /*
	     enforest works over:
	     prev - a list of the previously enforest Terms
	     term - the current term being enforested (initially null)
	     rest - remaining Terms to enforest
	     */

	  }, {
	    key: "enforest",
	    value: function enforest() {
	      var type = arguments.length <= 0 || arguments[0] === undefined ? "Module" : arguments[0];

	      // initialize the term
	      this.term = null;

	      if (this.rest.size === 0) {
	        this.done = true;
	        return this.term;
	      }

	      if (this.isEOF(this.peek())) {
	        this.term = new _terms2.default("EOF", {});
	        this.advance();
	        return this.term;
	      }

	      var result = undefined;
	      if (type === "expression") {
	        result = this.enforestExpressionLoop();
	      } else {
	        result = this.enforestModule();
	      }

	      if (this.rest.size === 0) {
	        this.done = true;
	      }
	      return result;
	    }
	  }, {
	    key: "enforestModule",
	    value: function enforestModule() {
	      return this.enforestBody();
	    }
	  }, {
	    key: "enforestBody",
	    value: function enforestBody() {
	      return this.enforestModuleItem();
	    }
	  }, {
	    key: "enforestModuleItem",
	    value: function enforestModuleItem() {
	      var lookahead = this.peek();
	      if (this.isKeyword(lookahead, 'import')) {
	        this.advance();
	        return this.enforestImportDeclaration();
	      } else if (this.isKeyword(lookahead, 'export')) {
	        this.advance();
	        return this.enforestExportDeclaration();
	      }
	      return this.enforestStatement();
	    }
	  }, {
	    key: "enforestExportDeclaration",
	    value: function enforestExportDeclaration() {
	      var lookahead = this.peek();
	      if (this.isPunctuator(lookahead, '*')) {
	        this.advance();
	        var moduleSpecifier = this.enforestFromClause();
	        return new _terms2.default('ExportAllFrom', { moduleSpecifier: moduleSpecifier });
	      } else if (this.isBraces(lookahead)) {
	        var namedExports = this.enforestExportClause();
	        var moduleSpecifier = null;
	        if (this.isIdentifier(this.peek(), 'from')) {
	          moduleSpecifier = this.enforestFromClause();
	        }
	        return new _terms2.default('ExportFrom', { namedExports: namedExports, moduleSpecifier: moduleSpecifier });
	      } else if (this.isKeyword(lookahead, 'class')) {
	        return new _terms2.default('Export', {
	          declaration: this.enforestClass({ isExpr: false })
	        });
	      } else if (this.isFnDeclTransform(lookahead)) {
	        return new _terms2.default('Export', {
	          declaration: this.enforestFunction({ isExpr: false, inDefault: false })
	        });
	      } else if (this.isKeyword(lookahead, 'default')) {
	        this.advance();
	        if (this.isFnDeclTransform(this.peek())) {
	          return new _terms2.default('ExportDefault', {
	            body: this.enforestFunction({ isExpr: false, inDefault: true })
	          });
	        } else if (this.isKeyword(this.peek(), 'class')) {
	          return new _terms2.default('ExportDefault', {
	            body: this.enforestClass({ isExpr: false, inDefault: true })
	          });
	        } else {
	          var body = this.enforestExpressionLoop();
	          this.consumeSemicolon();
	          return new _terms2.default('ExportDefault', { body: body });
	        }
	      } else if (this.isVarDeclTransform(lookahead) || this.isLetDeclTransform(lookahead) || this.isConstDeclTransform(lookahead) || this.isSyntaxrecDeclTransform(lookahead) || this.isSyntaxDeclTransform(lookahead)) {
	        return new _terms2.default('Export', {
	          declaration: this.enforestVariableDeclaration()
	        });
	      }
	      throw this.createError(lookahead, 'unexpected syntax');
	    }
	  }, {
	    key: "enforestExportClause",
	    value: function enforestExportClause() {
	      var enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	      var result = [];
	      while (enf.rest.size !== 0) {
	        result.push(enf.enforestExportSpecifier());
	        enf.consumeComma();
	      }
	      return (0, _immutable.List)(result);
	    }
	  }, {
	    key: "enforestExportSpecifier",
	    value: function enforestExportSpecifier() {
	      var name = this.enforestIdentifier();
	      if (this.isIdentifier(this.peek(), 'as')) {
	        this.advance();
	        var exportedName = this.enforestIdentifier();
	        return new _terms2.default('ExportSpecifier', { name: name, exportedName: exportedName });
	      }
	      return new _terms2.default('ExportSpecifier', {
	        name: null,
	        exportedName: name
	      });
	    }
	  }, {
	    key: "enforestImportDeclaration",
	    value: function enforestImportDeclaration() {
	      var lookahead = this.peek();
	      var defaultBinding = null;
	      var namedImports = (0, _immutable.List)();

	      if (this.isStringLiteral(lookahead)) {
	        var moduleSpecifier = this.advance();
	        this.consumeSemicolon();
	        return new _terms2.default('Import', {
	          defaultBinding: defaultBinding, namedImports: namedImports, moduleSpecifier: moduleSpecifier
	        });
	      }

	      if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {
	        defaultBinding = this.enforestBindingIdentifier();
	        if (!this.isPunctuator(this.peek(), ',')) {
	          var moduleSpecifier = this.enforestFromClause();
	          return new _terms2.default('Import', {
	            defaultBinding: defaultBinding, moduleSpecifier: moduleSpecifier,
	            namedImports: (0, _immutable.List)()
	          });
	        }
	      }
	      this.consumeComma();
	      lookahead = this.peek();
	      if (this.isBraces(lookahead)) {
	        var imports = this.enforestNamedImports();
	        var fromClause = this.enforestFromClause();

	        return new _terms2.default("Import", {
	          defaultBinding: defaultBinding,
	          namedImports: imports,
	          moduleSpecifier: fromClause

	        });
	      } else if (this.isPunctuator(lookahead, '*')) {
	        var namespaceBinding = this.enforestNamespaceBinding();
	        var moduleSpecifier = this.enforestFromClause();
	        return new _terms2.default('ImportNamespace', {
	          defaultBinding: defaultBinding, namespaceBinding: namespaceBinding, moduleSpecifier: moduleSpecifier
	        });
	      }
	      throw this.createError(lookahead, 'unexpected syntax');
	    }
	  }, {
	    key: "enforestNamespaceBinding",
	    value: function enforestNamespaceBinding() {
	      this.matchPunctuator('*');
	      this.matchIdentifier('as');
	      return this.enforestBindingIdentifier();
	    }
	  }, {
	    key: "enforestNamedImports",
	    value: function enforestNamedImports() {
	      var enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	      var result = [];
	      while (enf.rest.size !== 0) {
	        result.push(enf.enforestImportSpecifiers());
	        enf.consumeComma();
	      }
	      return (0, _immutable.List)(result);
	    }
	  }, {
	    key: "enforestImportSpecifiers",
	    value: function enforestImportSpecifiers() {
	      var lookahead = this.peek();
	      var name = undefined;
	      if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {
	        name = this.advance();
	        if (!this.isIdentifier(this.peek(), 'as')) {
	          return new _terms2.default('ImportSpecifier', {
	            name: null,
	            binding: new _terms2.default('BindingIdentifier', {
	              name: name
	            })
	          });
	        } else {
	          this.matchIdentifier('as');
	        }
	      } else {
	        throw this.createError(lookahead, 'unexpected token in import specifier');
	      }
	      return new _terms2.default('ImportSpecifier', {
	        name: name, binding: this.enforestBindingIdentifier()
	      });
	    }
	  }, {
	    key: "enforestFromClause",
	    value: function enforestFromClause() {
	      this.matchIdentifier('from');
	      var lookahead = this.matchStringLiteral();
	      this.consumeSemicolon();
	      return lookahead;
	    }
	  }, {
	    key: "enforestStatementListItem",
	    value: function enforestStatementListItem() {
	      var lookahead = this.peek();

	      if (this.isFnDeclTransform(lookahead)) {
	        return this.enforestFunctionDeclaration({ isExpr: false });
	      } else if (this.isKeyword(lookahead, 'class')) {
	        return this.enforestClass({ isExpr: false });
	      } else {
	        return this.enforestStatement();
	      }
	    }
	  }, {
	    key: "enforestStatement",
	    value: function enforestStatement() {
	      var lookahead = this.peek();

	      if (this.term === null && this.isCompiletimeTransform(lookahead)) {
	        this.rest = this.expandMacro().concat(this.rest);
	        lookahead = this.peek();
	      }

	      if (this.term === null && this.isBraces(lookahead)) {
	        return this.enforestBlockStatement();
	      }

	      if (this.term === null && this.isWhileTransform(lookahead)) {
	        return this.enforestWhileStatement();
	      }

	      if (this.term === null && this.isIfTransform(lookahead)) {
	        return this.enforestIfStatement();
	      }
	      if (this.term === null && this.isForTransform(lookahead)) {
	        return this.enforestForStatement();
	      }
	      if (this.term === null && this.isSwitchTransform(lookahead)) {
	        return this.enforestSwitchStatement();
	      }
	      if (this.term === null && this.isBreakTransform(lookahead)) {
	        return this.enforestBreakStatement();
	      }
	      if (this.term === null && this.isContinueTransform(lookahead)) {
	        return this.enforestContinueStatement();
	      }
	      if (this.term === null && this.isDoTransform(lookahead)) {
	        return this.enforestDoStatement();
	      }
	      if (this.term === null && this.isDebuggerTransform(lookahead)) {
	        return this.enforestDebuggerStatement();
	      }
	      if (this.term === null && this.isWithTransform(lookahead)) {
	        return this.enforestWithStatement();
	      }
	      if (this.term === null && this.isTryTransform(lookahead)) {
	        return this.enforestTryStatement();
	      }
	      if (this.term === null && this.isThrowTransform(lookahead)) {
	        return this.enforestThrowStatement();
	      }

	      // TODO: put somewhere else
	      if (this.term === null && this.isKeyword(lookahead, "class")) {
	        return this.enforestClass({ isExpr: false });
	      }

	      if (this.term === null && this.isFnDeclTransform(lookahead)) {
	        return this.enforestFunctionDeclaration();
	      }

	      if (this.term === null && this.isIdentifier(lookahead) && this.isPunctuator(this.peek(1), ':')) {
	        return this.enforestLabeledStatement();
	      }

	      if (this.term === null && (this.isVarDeclTransform(lookahead) || this.isLetDeclTransform(lookahead) || this.isConstDeclTransform(lookahead) || this.isSyntaxrecDeclTransform(lookahead) || this.isSyntaxDeclTransform(lookahead))) {
	        var stmt = new _terms2.default('VariableDeclarationStatement', {
	          declaration: this.enforestVariableDeclaration()
	        });
	        this.consumeSemicolon();
	        return stmt;
	      }

	      if (this.term === null && this.isReturnStmtTransform(lookahead)) {
	        return this.enforestReturnStatement();
	      }

	      if (this.term === null && this.isPunctuator(lookahead, ";")) {
	        this.advance();
	        return new _terms2.default("EmptyStatement", {});
	      }

	      return this.enforestExpressionStatement();
	    }
	  }, {
	    key: "enforestLabeledStatement",
	    value: function enforestLabeledStatement() {
	      var label = this.matchIdentifier();
	      var punc = this.matchPunctuator(':');
	      var stmt = this.enforestStatement();

	      return new _terms2.default('LabeledStatement', {
	        label: label,
	        body: stmt
	      });
	    }
	  }, {
	    key: "enforestBreakStatement",
	    value: function enforestBreakStatement() {
	      this.matchKeyword('break');
	      var lookahead = this.peek();
	      var label = null;
	      if (this.rest.size === 0 || this.isPunctuator(lookahead, ';')) {
	        this.consumeSemicolon();
	        return new _terms2.default('BreakStatement', { label: label });
	      }
	      if (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'yield') || this.isKeyword(lookahead, 'let')) {
	        label = this.enforestIdentifier();
	      }
	      this.consumeSemicolon();

	      return new _terms2.default('BreakStatement', { label: label });
	    }
	  }, {
	    key: "enforestTryStatement",
	    value: function enforestTryStatement() {
	      this.matchKeyword('try');
	      var body = this.enforestBlock();
	      if (this.isKeyword(this.peek(), 'catch')) {
	        var catchClause = this.enforestCatchClause();
	        if (this.isKeyword(this.peek(), 'finally')) {
	          this.advance();
	          var finalizer = this.enforestBlock();
	          return new _terms2.default('TryFinallyStatement', {
	            body: body, catchClause: catchClause, finalizer: finalizer
	          });
	        }
	        return new _terms2.default('TryCatchStatement', { body: body, catchClause: catchClause });
	      }
	      if (this.isKeyword(this.peek(), 'finally')) {
	        this.advance();
	        var finalizer = this.enforestBlock();
	        return new _terms2.default('TryFinallyStatement', { body: body, catchClause: null, finalizer: finalizer });
	      }
	      throw this.createError(this.peek(), 'try with no catch or finally');
	    }
	  }, {
	    key: "enforestCatchClause",
	    value: function enforestCatchClause() {
	      this.matchKeyword('catch');
	      var bindingParens = this.matchParens();
	      var enf = new Enforester(bindingParens, (0, _immutable.List)(), this.context);
	      var binding = enf.enforestBindingTarget();
	      var body = this.enforestBlock();
	      return new _terms2.default('CatchClause', { binding: binding, body: body });
	    }
	  }, {
	    key: "enforestThrowStatement",
	    value: function enforestThrowStatement() {
	      this.matchKeyword('throw');
	      var expression = this.enforestExpression();
	      this.consumeSemicolon();
	      return new _terms2.default('ThrowStatement', { expression: expression });
	    }
	  }, {
	    key: "enforestWithStatement",
	    value: function enforestWithStatement() {
	      this.matchKeyword('with');
	      var objParens = this.matchParens();
	      var enf = new Enforester(objParens, (0, _immutable.List)(), this.context);
	      var object = enf.enforestExpression();
	      var body = this.enforestStatement();
	      return new _terms2.default('WithStatement', { object: object, body: body });
	    }
	  }, {
	    key: "enforestDebuggerStatement",
	    value: function enforestDebuggerStatement() {
	      this.matchKeyword('debugger');

	      return new _terms2.default('DebuggerStatement', {});
	    }
	  }, {
	    key: "enforestDoStatement",
	    value: function enforestDoStatement() {
	      this.matchKeyword('do');
	      var body = this.enforestStatement();
	      this.matchKeyword('while');
	      var testBody = this.matchParens();
	      var enf = new Enforester(testBody, (0, _immutable.List)(), this.context);
	      var test = enf.enforestExpression();
	      this.consumeSemicolon();
	      return new _terms2.default('DoWhileStatement', { body: body, test: test });
	    }
	  }, {
	    key: "enforestContinueStatement",
	    value: function enforestContinueStatement() {
	      var kwd = this.matchKeyword('continue');
	      var lookahead = this.peek();
	      var label = null;
	      if (this.rest.size === 0 || this.isPunctuator(lookahead, ';')) {
	        this.consumeSemicolon();
	        return new _terms2.default('ContinueStatement', { label: label });
	      }
	      if (this.lineNumberEq(kwd, lookahead) && (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'yield') || this.isKeyword(lookahead, 'let'))) {
	        label = this.enforestIdentifier();
	      }
	      this.consumeSemicolon();

	      return new _terms2.default('ContinueStatement', { label: label });
	    }
	  }, {
	    key: "enforestSwitchStatement",
	    value: function enforestSwitchStatement() {
	      this.matchKeyword('switch');
	      var cond = this.matchParens();
	      var enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	      var discriminant = enf.enforestExpression();
	      var body = this.matchCurlies();

	      if (body.size === 0) {
	        return new _terms2.default('SwitchStatement', {
	          discriminant: discriminant,
	          cases: (0, _immutable.List)()
	        });
	      }
	      enf = new Enforester(body, (0, _immutable.List)(), this.context);
	      var cases = enf.enforestSwitchCases();
	      var lookahead = enf.peek();
	      if (enf.isKeyword(lookahead, 'default')) {
	        var defaultCase = enf.enforestSwitchDefault();
	        var postDefaultCases = enf.enforestSwitchCases();
	        return new _terms2.default('SwitchStatementWithDefault', {
	          discriminant: discriminant,
	          preDefaultCases: cases,
	          defaultCase: defaultCase,
	          postDefaultCases: postDefaultCases
	        });
	      }
	      return new _terms2.default('SwitchStatement', { discriminant: discriminant, cases: cases });
	    }
	  }, {
	    key: "enforestSwitchCases",
	    value: function enforestSwitchCases() {
	      var cases = [];
	      while (!(this.rest.size === 0 || this.isKeyword(this.peek(), 'default'))) {
	        cases.push(this.enforestSwitchCase());
	      }
	      return (0, _immutable.List)(cases);
	    }
	  }, {
	    key: "enforestSwitchCase",
	    value: function enforestSwitchCase() {
	      this.matchKeyword('case');
	      return new _terms2.default('SwitchCase', {
	        test: this.enforestExpression(),
	        consequent: this.enforestSwitchCaseBody()
	      });
	    }
	  }, {
	    key: "enforestSwitchCaseBody",
	    value: function enforestSwitchCaseBody() {
	      this.matchPunctuator(':');
	      return this.enforestStatementListInSwitchCaseBody();
	    }
	  }, {
	    key: "enforestStatementListInSwitchCaseBody",
	    value: function enforestStatementListInSwitchCaseBody() {
	      var result = [];
	      while (!(this.rest.size === 0 || this.isKeyword(this.peek(), 'default') || this.isKeyword(this.peek(), 'case'))) {
	        result.push(this.enforestStatementListItem());
	      }
	      return (0, _immutable.List)(result);
	    }
	  }, {
	    key: "enforestSwitchDefault",
	    value: function enforestSwitchDefault() {
	      this.matchKeyword('default');
	      return new _terms2.default('SwitchDefault', {
	        consequent: this.enforestSwitchCaseBody()
	      });
	    }
	  }, {
	    key: "enforestForStatement",
	    value: function enforestForStatement() {
	      this.matchKeyword('for');
	      var cond = this.matchParens();
	      var enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	      var lookahead = undefined,
	          test = undefined,
	          init = undefined,
	          right = undefined,
	          type = undefined,
	          left = undefined,
	          update = undefined;

	      // case where init is null
	      if (enf.isPunctuator(enf.peek(), ';')) {
	        enf.advance();
	        if (!enf.isPunctuator(enf.peek(), ';')) {
	          test = enf.enforestExpression();
	        }
	        enf.matchPunctuator(';');
	        if (enf.rest.size !== 0) {
	          right = enf.enforestExpression();
	        }
	        return new _terms2.default('ForStatement', {
	          init: null,
	          test: test,
	          update: right,
	          body: this.enforestStatement()
	        });
	        // case where init is not null
	      } else {
	          // testing
	          lookahead = enf.peek();
	          if (enf.isVarDeclTransform(lookahead) || enf.isLetDeclTransform(lookahead) || enf.isConstDeclTransform(lookahead)) {
	            init = enf.enforestVariableDeclaration();
	            lookahead = enf.peek();
	            if (this.isKeyword(lookahead, 'in') || this.isIdentifier(lookahead, 'of')) {
	              if (this.isKeyword(lookahead, 'in')) {
	                enf.advance();
	                right = enf.enforestExpression();
	                type = 'ForInStatement';
	              } else if (this.isIdentifier(lookahead, 'of')) {
	                enf.advance();
	                right = enf.enforestExpression();
	                type = 'ForOfStatement';
	              }
	              return new _terms2.default(type, {
	                left: init, right: right, body: this.enforestStatement()
	              });
	            }
	            enf.matchPunctuator(';');
	            if (enf.isPunctuator(enf.peek(), ';')) {
	              enf.advance();
	              test = null;
	            } else {
	              test = enf.enforestExpression();
	              enf.matchPunctuator(';');
	            }
	            update = enf.enforestExpression();
	          } else {
	            if (this.isKeyword(enf.peek(1), 'in') || this.isIdentifier(enf.peek(1), 'of')) {
	              left = enf.enforestBindingIdentifier();
	              var kind = enf.advance();
	              if (this.isKeyword(kind, 'in')) {
	                type = 'ForInStatement';
	              } else {
	                type = 'ForOfStatement';
	              }
	              right = enf.enforestExpression();
	              return new _terms2.default(type, {
	                left: left, right: right, body: this.enforestStatement()
	              });
	            }
	            init = enf.enforestExpression();
	            enf.matchPunctuator(';');
	            if (enf.isPunctuator(enf.peek(), ';')) {
	              enf.advance();
	              test = null;
	            } else {
	              test = enf.enforestExpression();
	              enf.matchPunctuator(';');
	            }
	            update = enf.enforestExpression();
	          }
	          return new _terms2.default('ForStatement', { init: init, test: test, update: update, body: this.enforestStatement() });
	        }
	    }
	  }, {
	    key: "enforestIfStatement",
	    value: function enforestIfStatement() {
	      this.matchKeyword('if');
	      var cond = this.matchParens();
	      var enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	      var lookahead = enf.peek();
	      var test = enf.enforestExpression();
	      if (test === null) {
	        throw enf.createError(lookahead, 'expecting an expression');
	      }
	      var consequent = this.enforestStatement();
	      var alternate = null;
	      if (this.isKeyword(this.peek(), 'else')) {
	        this.advance();
	        alternate = this.enforestStatement();
	      }
	      return new _terms2.default('IfStatement', { test: test, consequent: consequent, alternate: alternate });
	    }
	  }, {
	    key: "enforestWhileStatement",
	    value: function enforestWhileStatement() {
	      this.matchKeyword('while');
	      var cond = this.matchParens();
	      var enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	      var lookahead = enf.peek();
	      var test = enf.enforestExpression();
	      if (test === null) {
	        throw enf.createError(lookahead, 'expecting an expression');
	      }
	      var body = this.enforestStatement();

	      return new _terms2.default('WhileStatement', { test: test, body: body });
	    }
	  }, {
	    key: "enforestBlockStatement",
	    value: function enforestBlockStatement() {
	      return new _terms2.default('BlockStatement', {
	        block: this.enforestBlock()
	      });
	    }
	  }, {
	    key: "enforestBlock",
	    value: function enforestBlock() {
	      var b = this.matchCurlies();
	      var body = [];
	      var enf = new Enforester(b, (0, _immutable.List)(), this.context);

	      while (enf.rest.size !== 0) {
	        var lookahead = enf.peek();
	        var stmt = enf.enforestStatement();
	        if (stmt == null) {
	          throw enf.createError(lookahead, 'not a statement');
	        }
	        body.push(stmt);
	      }

	      return new _terms2.default('Block', {
	        statements: (0, _immutable.List)(body)
	      });
	    }
	  }, {
	    key: "enforestClass",
	    value: function enforestClass(_ref) {
	      var isExpr = _ref.isExpr;
	      var inDefault = _ref.inDefault;

	      var kw = this.advance();
	      var name = null,
	          supr = null;
	      var type = isExpr ? 'ClassExpression' : 'ClassDeclaration';

	      if (this.isIdentifier(this.peek())) {
	        name = this.enforestBindingIdentifier();
	      } else if (!isExpr) {
	        if (inDefault) {
	          name = new _terms2.default('BindingIdentifier', {
	            name: _syntax2.default.fromIdentifier('*default*', kw)
	          });
	        } else {
	          throw this.createError(this.peek(), 'unexpected syntax');
	        }
	      }

	      if (this.isKeyword(this.peek(), 'extends')) {
	        this.advance();
	        supr = this.enforestExpressionLoop();
	      }

	      var elements = [];
	      var enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	      while (enf.rest.size !== 0) {
	        if (enf.isPunctuator(enf.peek(), ';')) {
	          enf.advance();
	          continue;
	        }

	        var isStatic = false;

	        var _enf$enforestMethodDe = enf.enforestMethodDefinition();

	        var methodOrKey = _enf$enforestMethodDe.methodOrKey;
	        var kind = _enf$enforestMethodDe.kind;

	        if (kind === 'identifier' && methodOrKey.value.val() === 'static') {
	          isStatic = true;

	          var _enf$enforestMethodDe2 = enf.enforestMethodDefinition();

	          methodOrKey = _enf$enforestMethodDe2.methodOrKey;
	          kind = _enf$enforestMethodDe2.kind;
	        }
	        if (kind === 'method') {
	          elements.push(new _terms2.default('ClassElement', { isStatic: isStatic, method: methodOrKey }));
	        } else {
	          throw this.createError(enf.peek(), "Only methods are allowed in classes");
	        }
	      }

	      return new _terms2.default(type, {
	        name: name, super: supr,
	        elements: (0, _immutable.List)(elements)
	      });
	    }
	  }, {
	    key: "enforestBindingTarget",
	    value: function enforestBindingTarget() {
	      var lookahead = this.peek();
	      if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {
	        return this.enforestBindingIdentifier();
	      } else if (this.isBrackets(lookahead)) {
	        return this.enforestArrayBinding();
	      } else if (this.isBraces(lookahead)) {
	        return this.enforestObjectBinding();
	      }
	      (0, _errors.assert)(false, 'not implemented yet');
	    }
	  }, {
	    key: "enforestObjectBinding",
	    value: function enforestObjectBinding() {
	      var enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	      var properties = [];
	      while (enf.rest.size !== 0) {
	        properties.push(enf.enforestBindingProperty());
	        enf.consumeComma();
	      }

	      return new _terms2.default('ObjectBinding', {
	        properties: (0, _immutable.List)(properties)
	      });
	    }
	  }, {
	    key: "enforestBindingProperty",
	    value: function enforestBindingProperty() {
	      var lookahead = this.peek();

	      var _enforestPropertyName = this.enforestPropertyName();

	      var name = _enforestPropertyName.name;
	      var binding = _enforestPropertyName.binding;

	      if (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'let') || this.isKeyword(lookahead, 'yield')) {
	        if (!this.isPunctuator(this.peek(), ':')) {
	          var defaultValue = null;
	          if (this.isAssign(this.peek())) {
	            this.advance();
	            var expr = this.enforestExpressionLoop();
	            defaultValue = expr;
	          }
	          return new _terms2.default('BindingPropertyIdentifier', {
	            binding: binding, init: defaultValue
	          });
	        }
	      }
	      this.matchPunctuator(':');
	      binding = this.enforestBindingElement();
	      return new _terms2.default('BindingPropertyProperty', {
	        name: name, binding: binding
	      });
	    }
	  }, {
	    key: "enforestArrayBinding",
	    value: function enforestArrayBinding() {
	      var bracket = this.matchSquares();
	      var enf = new Enforester(bracket, (0, _immutable.List)(), this.context);
	      var elements = [],
	          restElement = null;
	      while (enf.rest.size !== 0) {
	        var el = undefined;
	        if (enf.isPunctuator(enf.peek(), ',')) {
	          enf.consumeComma();
	          el = null;
	        } else {
	          if (enf.isPunctuator(enf.peek(), '...')) {
	            enf.advance();
	            restElement = enf.enforestBindingTarget();
	            break;
	          } else {
	            el = enf.enforestBindingElement();
	          }
	          enf.consumeComma();
	        }
	        elements.push(el);
	      }
	      return new _terms2.default('ArrayBinding', {
	        elements: (0, _immutable.List)(elements),
	        restElement: restElement
	      });
	    }
	  }, {
	    key: "enforestBindingElement",
	    value: function enforestBindingElement() {
	      var binding = this.enforestBindingTarget();

	      if (this.isAssign(this.peek())) {
	        this.advance();
	        var init = this.enforestExpressionLoop();
	        binding = new _terms2.default('BindingWithDefault', { binding: binding, init: init });
	      }
	      return binding;
	    }
	  }, {
	    key: "enforestBindingIdentifier",
	    value: function enforestBindingIdentifier() {
	      return new _terms2.default("BindingIdentifier", {
	        name: this.enforestIdentifier()
	      });
	    }
	  }, {
	    key: "enforestIdentifier",
	    value: function enforestIdentifier() {
	      var lookahead = this.peek();
	      if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {
	        return this.advance();
	      }
	      throw this.createError(lookahead, "expecting an identifier");
	    }
	  }, {
	    key: "enforestReturnStatement",
	    value: function enforestReturnStatement() {
	      var kw = this.advance();
	      var lookahead = this.peek();

	      // short circuit for the empty expression case
	      if (this.rest.size === 0 || lookahead && !this.lineNumberEq(kw, lookahead)) {
	        return new _terms2.default("ReturnStatement", {
	          expression: null
	        });
	      }

	      var term = null;
	      if (!this.isPunctuator(lookahead, ';')) {
	        term = this.enforestExpression();
	        (0, _errors.expect)(term != null, "Expecting an expression to follow return keyword", lookahead, this.rest);
	      }

	      this.consumeSemicolon();
	      return new _terms2.default("ReturnStatement", {
	        expression: term
	      });
	    }
	  }, {
	    key: "enforestVariableDeclaration",
	    value: function enforestVariableDeclaration() {
	      var kind = undefined;
	      var lookahead = this.advance();
	      var kindSyn = lookahead;

	      if (kindSyn && this.context.env.get(kindSyn.resolve()) === _transforms.VariableDeclTransform) {
	        kind = "var";
	      } else if (kindSyn && this.context.env.get(kindSyn.resolve()) === _transforms.LetDeclTransform) {
	        kind = "let";
	      } else if (kindSyn && this.context.env.get(kindSyn.resolve()) === _transforms.ConstDeclTransform) {
	        kind = "const";
	      } else if (kindSyn && this.context.env.get(kindSyn.resolve()) === _transforms.SyntaxDeclTransform) {
	        kind = "syntax";
	      } else if (kindSyn && this.context.env.get(kindSyn.resolve()) === _transforms.SyntaxrecDeclTransform) {
	        kind = "syntaxrec";
	      }

	      var decls = (0, _immutable.List)();

	      while (true) {
	        var term = this.enforestVariableDeclarator();
	        var _lookahead = this.peek();
	        decls = decls.concat(term);

	        if (this.isPunctuator(_lookahead, ",")) {
	          this.advance();
	        } else {
	          break;
	        }
	      }

	      return new _terms2.default('VariableDeclaration', {
	        kind: kind,
	        declarators: decls
	      });
	    }
	  }, {
	    key: "enforestVariableDeclarator",
	    value: function enforestVariableDeclarator() {
	      var id = this.enforestBindingTarget();
	      var lookahead = this.peek();

	      var init = undefined,
	          rest = undefined;
	      if (this.isPunctuator(lookahead, '=')) {
	        this.advance();
	        var enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	        init = enf.enforest("expression");
	        this.rest = enf.rest;
	      } else {
	        init = null;
	      }
	      return new _terms2.default("VariableDeclarator", {
	        binding: id,
	        init: init
	      });
	    }
	  }, {
	    key: "enforestExpressionStatement",
	    value: function enforestExpressionStatement() {
	      var start = this.rest.get(0);
	      var expr = this.enforestExpression();
	      if (expr === null) {
	        throw this.createError(start, "not a valid expression");
	      }
	      this.consumeSemicolon();

	      return new _terms2.default("ExpressionStatement", {
	        expression: expr
	      });
	    }
	  }, {
	    key: "enforestExpression",
	    value: function enforestExpression() {
	      var left = this.enforestExpressionLoop();
	      var lookahead = this.peek();
	      if (this.isPunctuator(lookahead, ',')) {
	        while (this.rest.size !== 0) {
	          if (!this.isPunctuator(this.peek(), ',')) {
	            break;
	          }
	          var operator = this.advance();
	          var right = this.enforestExpressionLoop();
	          left = new _terms2.default('BinaryExpression', { left: left, operator: operator, right: right });
	        }
	      }
	      this.term = null;
	      return left;
	    }
	  }, {
	    key: "enforestExpressionLoop",
	    value: function enforestExpressionLoop() {
	      this.term = null;
	      this.opCtx = {
	        prec: 0,
	        combine: function combine(x) {
	          return x;
	        },
	        stack: (0, _immutable.List)()
	      };

	      do {
	        var term = this.enforestAssignmentExpression();
	        // no change means we've done as much enforesting as possible
	        // if nothing changed, maybe we just need to pop the expr stack
	        if (term === EXPR_LOOP_NO_CHANGE && this.opCtx.stack.size > 0) {
	          this.term = this.opCtx.combine(this.term);

	          var _opCtx$stack$last = this.opCtx.stack.last();

	          var prec = _opCtx$stack$last.prec;
	          var combine = _opCtx$stack$last.combine;

	          this.opCtx.prec = prec;
	          this.opCtx.combine = combine;
	          this.opCtx.stack = this.opCtx.stack.pop();
	        } else if (term === EXPR_LOOP_NO_CHANGE) {
	          break;
	        } else if (term === EXPR_LOOP_OPERATOR || term === EXPR_LOOP_EXPANSION) {
	          // operator means an opCtx was pushed on the stack
	          this.term = null;
	        } else {
	          this.term = term;
	        }
	      } while (true); // get a fixpoint
	      return this.term;
	    }
	  }, {
	    key: "enforestAssignmentExpression",
	    value: function enforestAssignmentExpression() {
	      var lookahead = this.peek();

	      if (this.term === null && this.isTerm(lookahead)) {
	        // TODO: check that this is actually an expression
	        return this.advance();
	      }

	      if (this.term === null && this.isCompiletimeTransform(lookahead)) {
	        var result = this.expandMacro();
	        this.rest = result.concat(this.rest);
	        return EXPR_LOOP_EXPANSION;
	      }

	      if (this.term === null && this.isKeyword(lookahead, 'yield')) {
	        return this.enforestYieldExpression();
	      }

	      if (this.term === null && this.isKeyword(lookahead, 'class')) {
	        return this.enforestClass({ isExpr: true });
	      }

	      if (this.term === null && (this.isIdentifier(lookahead) || this.isParens(lookahead)) && this.isPunctuator(this.peek(1), '=>') && this.lineNumberEq(lookahead, this.peek(1))) {
	        return this.enforestArrowExpression();
	      }

	      if (this.term === null && this.isSyntaxTemplate(lookahead)) {
	        return this.enforestSyntaxTemplate();
	      }
	      // syntaxQuote ` ... `
	      if (this.term === null && this.isSyntaxQuoteTransform(lookahead)) {
	        return this.enforestSyntaxQuote();
	      }

	      if (this.term === null && this.isNewTransform(lookahead)) {
	        return this.enforestNewExpression();
	      }

	      // $x:ThisExpression
	      if (this.term === null && this.isKeyword(lookahead, "this")) {
	        return new _terms2.default("ThisExpression", {
	          stx: this.advance()
	        });
	      }
	      // $x:ident
	      if (this.term === null && (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'let') || this.isKeyword(lookahead, 'yield'))) {
	        return new _terms2.default("IdentifierExpression", {
	          name: this.advance()
	        });
	      }
	      if (this.term === null && this.isNumericLiteral(lookahead)) {
	        var num = this.advance();
	        if (num.val() === 1 / 0) {
	          return new _terms2.default('LiteralInfinityExpression', {});
	        }
	        return new _terms2.default("LiteralNumericExpression", {
	          value: num
	        });
	      }
	      if (this.term === null && this.isStringLiteral(lookahead)) {
	        return new _terms2.default("LiteralStringExpression", {
	          value: this.advance()
	        });
	      }
	      if (this.term === null && this.isTemplate(lookahead)) {
	        return new _terms2.default('TemplateExpression', {
	          tag: null,
	          elements: this.enforestTemplateElements()
	        });
	      }
	      if (this.term === null && this.isBooleanLiteral(lookahead)) {
	        return new _terms2.default("LiteralBooleanExpression", {
	          value: this.advance()
	        });
	      }
	      if (this.term === null && this.isNullLiteral(lookahead)) {
	        this.advance();
	        return new _terms2.default("LiteralNullExpression", {});
	      }
	      if (this.term === null && this.isRegularExpression(lookahead)) {
	        var reStx = this.advance();
	        return new _terms2.default("LiteralRegExpExpression", {
	          pattern: reStx.token.regex.pattern,
	          flags: reStx.token.regex.flags
	        });
	      }
	      // ($x:expr)
	      if (this.term === null && this.isParens(lookahead)) {
	        return new _terms2.default("ParenthesizedExpression", {
	          inner: this.advance().inner()
	        });
	      }
	      // $x:FunctionExpression
	      if (this.term === null && this.isFnDeclTransform(lookahead)) {
	        return this.enforestFunctionExpression();
	      }

	      // { $p:prop (,) ... }
	      if (this.term === null && this.isBraces(lookahead)) {
	        return this.enforestObjectExpression();
	      }

	      // [$x:expr (,) ...]
	      if (this.term === null && this.isBrackets(lookahead)) {
	        return this.enforestArrayExpression();
	      }

	      // prefix unary
	      if (this.term === null && this.isOperator(lookahead)) {
	        return this.enforestUnaryExpression();
	      }

	      // and then check the cases where the term part of p is something...

	      // postfix unary
	      if (this.term && this.isUpdateOperator(lookahead)) {
	        return this.enforestUpdateExpression();
	      }

	      // $l:expr $op:binaryOperator $r:expr
	      if (this.term && this.isOperator(lookahead)) {
	        return this.enforestBinaryExpression();
	      }
	      // $x:expr . $prop:ident
	      if (this.term && this.isPunctuator(lookahead, ".") && (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1)))) {
	        return this.enforestStaticMemberExpression();
	      }
	      // $x:expr [ $b:expr ]
	      if (this.term && this.isBrackets(lookahead)) {
	        return this.enforestComputedMemberExpression();
	      }
	      // $x:expr (...)
	      if (this.term && this.isParens(lookahead)) {
	        var paren = this.advance();
	        return new _terms2.default("CallExpression", {
	          callee: this.term,
	          arguments: paren.inner()
	        });
	      }
	      // $x:id `...`
	      if (this.term && this.isTemplate(lookahead)) {
	        return new _terms2.default('TemplateExpression', {
	          tag: this.term,
	          elements: this.enforestTemplateElements()
	        });
	      }
	      // $x:expr = $init:expr
	      if (this.term && this.isAssign(lookahead)) {
	        var binding = this.transformDestructuring(this.term);
	        var op = this.advance();

	        var enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	        var init = enf.enforest("expression");
	        this.rest = enf.rest;

	        return new _terms2.default("AssignmentExpression", {
	          binding: binding,
	          expression: init
	        });
	      }

	      if (this.term && this.isPunctuator(lookahead, '?')) {
	        return this.enforestConditionalExpression();
	      }

	      return EXPR_LOOP_NO_CHANGE;
	    }
	  }, {
	    key: "enforestArgumentList",
	    value: function enforestArgumentList() {
	      var result = [];
	      while (this.rest.size > 0) {
	        var arg = undefined;
	        if (this.isPunctuator(this.peek(), '...')) {
	          this.advance();
	          arg = new _terms2.default('SpreadElement', {
	            expression: this.enforestExpressionLoop()
	          });
	        } else {
	          arg = this.enforestExpressionLoop();
	        }
	        if (this.rest.size > 0) {
	          this.matchPunctuator(',');
	        }
	        result.push(arg);
	      }
	      return (0, _immutable.List)(result);
	    }
	  }, {
	    key: "enforestNewExpression",
	    value: function enforestNewExpression() {
	      this.matchKeyword('new');
	      var callee = undefined;
	      if (this.isKeyword(this.peek(), 'new')) {
	        callee = this.enforestNewExpression();
	      } else {
	        callee = new _terms2.default('IdentifierExpression', { name: this.enforestIdentifier() });
	      }
	      var args = undefined;
	      if (this.isParens(this.peek())) {
	        args = this.matchParens();
	      } else {
	        args = (0, _immutable.List)();
	      }
	      return new _terms2.default('NewExpression', {
	        callee: callee,
	        arguments: args
	      });
	    }
	  }, {
	    key: "enforestComputedMemberExpression",
	    value: function enforestComputedMemberExpression() {
	      var enf = new Enforester(this.matchSquares(), (0, _immutable.List)(), this.context);
	      return new _terms2.default('ComputedMemberExpression', {
	        object: this.term,
	        expression: enf.enforestExpression()
	      });
	    }
	  }, {
	    key: "transformDestructuring",
	    value: function transformDestructuring(term) {
	      var _this = this;

	      switch (term.type) {
	        case 'IdentifierExpression':
	          return new _terms2.default('BindingIdentifier', { name: term.name });

	        case 'ParenthesizedExpression':
	          if (term.inner.size === 1 && this.isIdentifier(term.inner.get(0))) {
	            return new _terms2.default('BindingIdentifier', { name: term.inner.get(0) });
	          }
	        case 'DataProperty':
	          return new _terms2.default('BindingPropertyProperty', {
	            name: term.name,
	            binding: this.transformDestructuringWithDefault(term.expression)
	          });
	        case 'ShorthandProperty':
	          return new _terms2.default('BindingPropertyIdentifier', {
	            binding: new _terms2.default('BindingIdentifier', { name: term.name }),
	            init: null
	          });
	        case 'ObjectExpression':
	          return new _terms2.default('ObjectBinding', {
	            properties: term.properties.map(function (t) {
	              return _this.transformDestructuring(t);
	            })
	          });
	        case 'ArrayExpression':
	          var last = term.elements.last();
	          if (last != null && last.type === 'SpreadElement') {
	            return new _terms2.default('ArrayBinding', {
	              elements: term.elements.slice(0, -1).map(function (t) {
	                return t && _this.transformDestructuringWithDefault(t);
	              }),
	              restElement: this.transformDestructuringWithDefault(last.expression)
	            });
	          } else {
	            return new _terms2.default('ArrayBinding', {
	              elements: term.elements.map(function (t) {
	                return t && _this.transformDestructuringWithDefault(t);
	              }),
	              restElement: null
	            });
	          }
	          return new _terms2.default('ArrayBinding', {
	            elements: term.elements.map(function (t) {
	              return t && _this.transformDestructuring(t);
	            }),
	            restElement: null
	          });
	        case 'StaticPropertyName':
	          return new _terms2.default('BindingIdentifier', {
	            name: term.value
	          });
	        case 'ComputedMemberExpression':
	        case 'StaticMemberExpression':
	        case 'ArrayBinding':
	        case 'BindingIdentifier':
	        case 'BindingPropertyIdentifier':
	        case 'BindingPropertyProperty':
	        case 'BindingWithDefault':
	        case 'ObjectBinding':
	          return term;
	      }
	      (0, _errors.assert)(false, 'not implemented yet for ' + term.type);
	    }
	  }, {
	    key: "transformDestructuringWithDefault",
	    value: function transformDestructuringWithDefault(term) {
	      switch (term.type) {
	        case "AssignmentExpression":
	          return new _terms2.default('BindingWithDefault', {
	            binding: this.transformDestructuring(term.binding),
	            init: term.expression
	          });
	      }
	      return this.transformDestructuring(term);
	    }
	  }, {
	    key: "enforestArrowExpression",
	    value: function enforestArrowExpression() {
	      var enf = undefined;
	      if (this.isIdentifier(this.peek())) {
	        enf = new Enforester(_immutable.List.of(this.advance()), (0, _immutable.List)(), this.context);
	      } else {
	        var p = this.matchParens();
	        enf = new Enforester(p, (0, _immutable.List)(), this.context);
	      }
	      var params = enf.enforestFormalParameters();
	      this.matchPunctuator('=>');

	      var body = undefined;
	      if (this.isBraces(this.peek())) {
	        body = this.matchCurlies();
	      } else {
	        enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	        body = enf.enforestExpressionLoop();
	        this.rest = enf.rest;
	      }
	      return new _terms2.default('ArrowExpression', { params: params, body: body });
	    }
	  }, {
	    key: "enforestYieldExpression",
	    value: function enforestYieldExpression() {
	      var kwd = this.matchKeyword('yield');
	      var lookahead = this.peek();

	      if (this.rest.size === 0 || lookahead && !this.lineNumberEq(kwd, lookahead)) {
	        return new _terms2.default('YieldExpression', {
	          expression: null
	        });
	      } else {
	        var expr = this.enforestExpression();
	        return new _terms2.default('YieldExpression', {
	          expression: expr
	        });
	      }
	    }
	  }, {
	    key: "enforestSyntaxTemplate",
	    value: function enforestSyntaxTemplate() {
	      return new _terms2.default('SyntaxTemplate', {
	        template: this.advance()
	      });
	    }
	  }, {
	    key: "enforestSyntaxQuote",
	    value: function enforestSyntaxQuote() {
	      var name = this.advance();
	      return new _terms2.default('SyntaxQuote', {
	        name: name,
	        template: new _terms2.default('TemplateExpression', {
	          tag: new _terms2.default('IdentifierExpression', {
	            name: name
	          }),
	          elements: this.enforestTemplateElements()
	        })
	      });
	    }
	  }, {
	    key: "enforestStaticMemberExpression",
	    value: function enforestStaticMemberExpression() {
	      var object = this.term;
	      var dot = this.advance();
	      var property = this.advance();

	      return new _terms2.default("StaticMemberExpression", {
	        object: object,
	        property: property
	      });
	    }
	  }, {
	    key: "enforestArrayExpression",
	    value: function enforestArrayExpression() {
	      var arr = this.advance();

	      var elements = [];

	      var enf = new Enforester(arr.inner(), (0, _immutable.List)(), this.context);

	      while (enf.rest.size > 0) {
	        var lookahead = enf.peek();
	        if (enf.isPunctuator(lookahead, ",")) {
	          enf.advance();
	          elements.push(null);
	        } else if (enf.isPunctuator(lookahead, '...')) {
	          enf.advance();
	          var expression = enf.enforestExpressionLoop();
	          if (expression == null) {
	            throw enf.createError(lookahead, 'expecting expression');
	          }
	          elements.push(new _terms2.default('SpreadElement', { expression: expression }));
	        } else {
	          var term = enf.enforestExpressionLoop();
	          if (term == null) {
	            throw enf.createError(lookahead, "expected expression");
	          }
	          elements.push(term);
	          enf.consumeComma();
	        }
	      }

	      return new _terms2.default("ArrayExpression", {
	        elements: (0, _immutable.List)(elements)
	      });
	    }
	  }, {
	    key: "enforestObjectExpression",
	    value: function enforestObjectExpression() {
	      var obj = this.advance();

	      var properties = (0, _immutable.List)();

	      var enf = new Enforester(obj.inner(), (0, _immutable.List)(), this.context);

	      var lastProp = null;
	      while (enf.rest.size > 0) {
	        var prop = enf.enforestPropertyDefinition();
	        enf.consumeComma();
	        properties = properties.concat(prop);

	        if (lastProp === prop) {
	          throw enf.createError(prop, "invalid syntax in object");
	        }
	        lastProp = prop;
	      }

	      return new _terms2.default("ObjectExpression", {
	        properties: properties
	      });
	    }
	  }, {
	    key: "enforestPropertyDefinition",
	    value: function enforestPropertyDefinition() {
	      var _enforestMethodDefini = this.enforestMethodDefinition();

	      var methodOrKey = _enforestMethodDefini.methodOrKey;
	      var kind = _enforestMethodDefini.kind;


	      switch (kind) {
	        case 'method':
	          return methodOrKey;
	        case 'identifier':
	          if (this.isAssign(this.peek())) {
	            this.advance();
	            var init = this.enforestExpressionLoop();
	            return new _terms2.default('BindingPropertyIdentifier', {
	              init: init, binding: this.transformDestructuring(methodOrKey)
	            });
	          } else if (!this.isPunctuator(this.peek(), ':')) {
	            return new _terms2.default('ShorthandProperty', {
	              name: methodOrKey.value
	            });
	          }
	      }

	      this.matchPunctuator(':');
	      var expr = this.enforestExpressionLoop();

	      return new _terms2.default("DataProperty", {
	        name: methodOrKey,
	        expression: expr
	      });
	    }
	  }, {
	    key: "enforestMethodDefinition",
	    value: function enforestMethodDefinition() {
	      var lookahead = this.peek();

	      if (this.isIdentifier(lookahead, 'get') && this.isPropertyName(this.peek(1))) {
	        this.advance();

	        var _enforestPropertyName2 = this.enforestPropertyName();

	        var _name = _enforestPropertyName2.name;

	        this.matchParens();
	        var body = this.matchCurlies();
	        return {
	          methodOrKey: new _terms2.default('Getter', { name: _name, body: body }),
	          kind: 'method'
	        };
	      } else if (this.isIdentifier(lookahead, 'set') && this.isPropertyName(this.peek(1))) {
	        this.advance();

	        var _enforestPropertyName3 = this.enforestPropertyName();

	        var _name2 = _enforestPropertyName3.name;

	        var enf = new Enforester(this.matchParens(), (0, _immutable.List)(), this.context);
	        var param = enf.enforestBindingElement();
	        var body = this.matchCurlies();
	        return {
	          methodOrKey: new _terms2.default('Setter', { name: _name2, param: param, body: body }),
	          kind: 'method'
	        };
	      }

	      var _enforestPropertyName4 = this.enforestPropertyName();

	      var name = _enforestPropertyName4.name;

	      if (this.isParens(this.peek())) {
	        var params = this.matchParens();
	        var enf = new Enforester(params, (0, _immutable.List)(), this.context);
	        var formalParams = enf.enforestFormalParameters();

	        var body = this.matchCurlies();
	        return {
	          methodOrKey: new _terms2.default('Method', {
	            isGenerator: false,
	            name: name, params: formalParams, body: body
	          }),
	          kind: 'method'
	        };
	      }
	      return {
	        methodOrKey: name,
	        kind: this.isIdentifier(lookahead) || this.isKeyword(lookahead) ? 'identifier' : 'property'
	      };
	    }
	  }, {
	    key: "enforestPropertyName",
	    value: function enforestPropertyName() {
	      var lookahead = this.peek();

	      if (this.isStringLiteral(lookahead) || this.isNumericLiteral(lookahead)) {
	        return {
	          name: new _terms2.default('StaticPropertyName', {
	            value: this.advance()
	          }),
	          binding: null
	        };
	      } else if (this.isBrackets(lookahead)) {
	        var enf = new Enforester(this.matchSquares(), (0, _immutable.List)(), this.context);
	        var expr = enf.enforestExpressionLoop();
	        return {
	          name: new _terms2.default('ComputedPropertyName', {
	            expression: expr
	          }),
	          binding: null
	        };
	      }
	      var name = this.advance();
	      return {
	        name: new _terms2.default('StaticPropertyName', { value: name }),
	        binding: new _terms2.default('BindingIdentifier', { name: name })
	      };
	    }
	  }, {
	    key: "enforestFunction",
	    value: function enforestFunction(_ref2) {
	      var isExpr = _ref2.isExpr;
	      var inDefault = _ref2.inDefault;
	      var allowGenerator = _ref2.allowGenerator;

	      var name = null,
	          params = undefined,
	          body = undefined,
	          rest = undefined;
	      var isGenerator = false;
	      // eat the function keyword
	      var fnKeyword = this.advance();
	      var lookahead = this.peek();
	      var type = isExpr ? 'FunctionExpression' : 'FunctionDeclaration';

	      if (this.isPunctuator(lookahead, "*")) {
	        isGenerator = true;
	        this.advance();
	        lookahead = this.peek();
	      }

	      if (!this.isParens(lookahead)) {
	        name = this.enforestBindingIdentifier();
	      } else if (inDefault) {
	        name = new _terms2.default('BindingIdentifier', {
	          name: _syntax2.default.fromIdentifier('*default*', fnKeyword)
	        });
	      }

	      params = this.matchParens();

	      body = this.matchCurlies();

	      var enf = new Enforester(params, (0, _immutable.List)(), this.context);
	      var formalParams = enf.enforestFormalParameters();

	      return new _terms2.default(type, {
	        name: name,
	        isGenerator: isGenerator,
	        params: formalParams,
	        body: body
	      });
	    }
	  }, {
	    key: "enforestFunctionExpression",
	    value: function enforestFunctionExpression() {
	      var name = null,
	          params = undefined,
	          body = undefined,
	          rest = undefined;
	      var isGenerator = false;
	      // eat the function keyword
	      this.advance();
	      var lookahead = this.peek();

	      if (this.isPunctuator(lookahead, "*")) {
	        isGenerator = true;
	        this.advance();
	        lookahead = this.peek();
	      }

	      if (!this.isParens(lookahead)) {
	        name = this.enforestBindingIdentifier();
	      }

	      params = this.matchParens();
	      body = this.matchCurlies();

	      var enf = new Enforester(params, (0, _immutable.List)(), this.context);
	      var formalParams = enf.enforestFormalParameters();

	      return new _terms2.default("FunctionExpression", {
	        name: name,
	        isGenerator: isGenerator,
	        params: formalParams,
	        body: body
	      });
	    }
	  }, {
	    key: "enforestFunctionDeclaration",
	    value: function enforestFunctionDeclaration() {
	      var name = undefined,
	          params = undefined,
	          body = undefined,
	          rest = undefined;
	      var isGenerator = false;
	      // eat the function keyword
	      this.advance();
	      var lookahead = this.peek();

	      if (this.isPunctuator(lookahead, "*")) {
	        isGenerator = true;
	        this.advance();
	      }

	      name = this.enforestBindingIdentifier();

	      params = this.matchParens();
	      body = this.matchCurlies();

	      var enf = new Enforester(params, (0, _immutable.List)(), this.context);
	      var formalParams = enf.enforestFormalParameters();

	      return new _terms2.default("FunctionDeclaration", {
	        name: name,
	        isGenerator: isGenerator,
	        params: formalParams,
	        body: body
	      });
	    }
	  }, {
	    key: "enforestFormalParameters",
	    value: function enforestFormalParameters() {
	      var items = [];
	      var rest = null;
	      while (this.rest.size !== 0) {
	        var lookahead = this.peek();
	        if (this.isPunctuator(lookahead, '...')) {
	          this.matchPunctuator('...');
	          rest = this.enforestBindingIdentifier();
	          break;
	        }
	        items.push(this.enforestParam());
	        this.consumeComma();
	      }
	      return new _terms2.default("FormalParameters", {
	        items: (0, _immutable.List)(items), rest: rest
	      });
	    }
	  }, {
	    key: "enforestParam",
	    value: function enforestParam() {
	      return this.enforestBindingElement();
	    }
	  }, {
	    key: "enforestUpdateExpression",
	    value: function enforestUpdateExpression() {
	      var operator = this.matchUnaryOperator();

	      return new _terms2.default('UpdateExpression', {
	        isPrefix: false,
	        operator: operator.val(),
	        operand: this.transformDestructuring(this.term)
	      });
	    }
	  }, {
	    key: "enforestUnaryExpression",
	    value: function enforestUnaryExpression() {
	      var _this2 = this;

	      var operator = this.matchUnaryOperator();
	      this.opCtx.stack = this.opCtx.stack.push({
	        prec: this.opCtx.prec,
	        combine: this.opCtx.combine
	      });
	      // TODO: all builtins are 14, custom operators will change this
	      this.opCtx.prec = 14;
	      this.opCtx.combine = function (rightTerm) {
	        var type = undefined,
	            term = undefined,
	            isPrefix = undefined;
	        if (operator.val() === '++' || operator.val() === '--') {
	          type = 'UpdateExpression';
	          term = _this2.transformDestructuring(rightTerm);
	          isPrefix = true;
	        } else {
	          type = 'UnaryExpression';
	          isPrefix = undefined;
	          term = rightTerm;
	        }
	        return new _terms2.default(type, {
	          operator: operator.val(),
	          operand: term,
	          isPrefix: isPrefix
	        });
	      };
	      return EXPR_LOOP_OPERATOR;
	    }
	  }, {
	    key: "enforestConditionalExpression",
	    value: function enforestConditionalExpression() {
	      // first, pop the operator stack
	      var test = this.opCtx.combine(this.term);
	      if (this.opCtx.stack.size > 0) {
	        var _opCtx$stack$last2 = this.opCtx.stack.last();

	        var prec = _opCtx$stack$last2.prec;
	        var combine = _opCtx$stack$last2.combine;

	        this.opCtx.stack = this.opCtx.stack.pop();
	        this.opCtx.prec = prec;
	        this.opCtx.combine = combine;
	      }

	      this.matchPunctuator('?');
	      var enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	      var consequent = enf.enforestExpressionLoop();
	      enf.matchPunctuator(':');
	      enf = new Enforester(enf.rest, (0, _immutable.List)(), this.context);
	      var alternate = enf.enforestExpressionLoop();
	      this.rest = enf.rest;
	      return new _terms2.default('ConditionalExpression', {
	        test: test, consequent: consequent, alternate: alternate
	      });
	    }
	  }, {
	    key: "enforestBinaryExpression",
	    value: function enforestBinaryExpression() {

	      var leftTerm = this.term;
	      var opStx = this.peek();
	      var op = opStx.val();
	      var opPrec = (0, _operators.getOperatorPrec)(op);
	      var opAssoc = (0, _operators.getOperatorAssoc)(op);

	      if ((0, _operators.operatorLt)(this.opCtx.prec, opPrec, opAssoc)) {
	        this.opCtx.stack = this.opCtx.stack.push({
	          prec: this.opCtx.prec,
	          combine: this.opCtx.combine
	        });
	        this.opCtx.prec = opPrec;
	        this.opCtx.combine = function (rightTerm) {
	          return new _terms2.default("BinaryExpression", {
	            left: leftTerm,
	            operator: opStx,
	            right: rightTerm
	          });
	        };
	        this.advance();
	        return EXPR_LOOP_OPERATOR;
	      } else {
	        var term = this.opCtx.combine(leftTerm);
	        // this.rest does not change

	        var _opCtx$stack$last3 = this.opCtx.stack.last();

	        var prec = _opCtx$stack$last3.prec;
	        var combine = _opCtx$stack$last3.combine;

	        this.opCtx.stack = this.opCtx.stack.pop();
	        this.opCtx.prec = prec;
	        this.opCtx.combine = combine;
	        return term;
	      }
	    }
	  }, {
	    key: "enforestTemplateElements",
	    value: function enforestTemplateElements() {
	      var _this3 = this;

	      var lookahead = this.matchTemplate();
	      var elements = lookahead.token.items.map(function (it) {
	        if (it instanceof _syntax2.default && it.isDelimiter()) {
	          var enf = new Enforester(it.inner(), (0, _immutable.List)(), _this3.context);
	          return enf.enforest("expression");
	        }
	        return new _terms2.default('TemplateElement', {
	          rawValue: it.slice.text
	        });
	      });
	      return elements;
	    }
	  }, {
	    key: "expandMacro",
	    value: function expandMacro(enforestType) {
	      var _this4 = this;

	      var name = this.advance();

	      var syntaxTransform = this.getCompiletimeTransform(name);
	      if (syntaxTransform == null || typeof syntaxTransform.value !== "function") {
	        throw this.createError(name, "the macro name was not bound to a value that could be invoked");
	      }
	      var useSiteScope = (0, _scope.freshScope)("u");
	      var introducedScope = (0, _scope.freshScope)("i");
	      // TODO: needs to be a list of scopes I think
	      this.context.useScope = useSiteScope;

	      var ctx = new _macroContext2.default(this, name, this.context, useSiteScope, introducedScope);

	      var result = syntaxTransform.value.call(null, ctx);
	      if (Array.isArray(result)) {
	        result = (0, _immutable.List)(result);
	      }
	      if (!_immutable.List.isList(result)) {
	        throw this.createError(name, "macro must return a list but got: " + result);
	      }
	      result = result.map(function (stx) {
	        if (!(stx && typeof stx.addScope === 'function')) {
	          throw _this4.createError(name, 'macro must return syntax objects or terms but got: ' + stx);
	        }
	        return stx.addScope(introducedScope, _this4.context.bindings, { flip: true });
	      });

	      return result;
	    }
	  }, {
	    key: "consumeSemicolon",
	    value: function consumeSemicolon() {
	      var lookahead = this.peek();

	      if (lookahead && this.isPunctuator(lookahead, ";")) {
	        this.advance();
	      }
	    }
	  }, {
	    key: "consumeComma",
	    value: function consumeComma() {
	      var lookahead = this.peek();

	      if (lookahead && this.isPunctuator(lookahead, ',')) {
	        this.advance();
	      }
	    }
	  }, {
	    key: "isTerm",
	    value: function isTerm(term) {
	      return term && term instanceof _terms2.default;
	    }
	  }, {
	    key: "isEOF",
	    value: function isEOF(term) {
	      return term && term instanceof _syntax2.default && term.isEOF();
	    }
	  }, {
	    key: "isIdentifier",
	    value: function isIdentifier(term) {
	      var val = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	      return term && term instanceof _syntax2.default && term.isIdentifier() && (val === null || term.val() === val);
	    }
	  }, {
	    key: "isPropertyName",
	    value: function isPropertyName(term) {
	      return this.isIdentifier(term) || this.isKeyword(term) || this.isNumericLiteral(term) || this.isStringLiteral(term) || this.isBrackets(term);
	    }
	  }, {
	    key: "isNumericLiteral",
	    value: function isNumericLiteral(term) {
	      return term && term instanceof _syntax2.default && term.isNumericLiteral();
	    }
	  }, {
	    key: "isStringLiteral",
	    value: function isStringLiteral(term) {
	      return term && term instanceof _syntax2.default && term.isStringLiteral();
	    }
	  }, {
	    key: "isTemplate",
	    value: function isTemplate(term) {
	      return term && term instanceof _syntax2.default && term.isTemplate();
	    }
	  }, {
	    key: "isBooleanLiteral",
	    value: function isBooleanLiteral(term) {
	      return term && term instanceof _syntax2.default && term.isBooleanLiteral();
	    }
	  }, {
	    key: "isNullLiteral",
	    value: function isNullLiteral(term) {
	      return term && term instanceof _syntax2.default && term.isNullLiteral();
	    }
	  }, {
	    key: "isRegularExpression",
	    value: function isRegularExpression(term) {
	      return term && term instanceof _syntax2.default && term.isRegularExpression();
	    }
	  }, {
	    key: "isParens",
	    value: function isParens(term) {
	      return term && term instanceof _syntax2.default && term.isParens();
	    }
	  }, {
	    key: "isBraces",
	    value: function isBraces(term) {
	      return term && term instanceof _syntax2.default && term.isBraces();
	    }
	  }, {
	    key: "isBrackets",
	    value: function isBrackets(term) {
	      return term && term instanceof _syntax2.default && term.isBrackets();
	    }
	  }, {
	    key: "isAssign",
	    value: function isAssign(term) {
	      return term && term instanceof _syntax2.default && term.isAssign();
	    }
	  }, {
	    key: "isKeyword",
	    value: function isKeyword(term) {
	      var val = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	      return term && term instanceof _syntax2.default && term.isKeyword() && (val === null || term.val() === val);
	    }
	  }, {
	    key: "isPunctuator",
	    value: function isPunctuator(term) {
	      var val = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	      return term && term instanceof _syntax2.default && term.isPunctuator() && (val === null || term.val() === val);
	    }
	  }, {
	    key: "isOperator",
	    value: function isOperator(term) {
	      return term && term instanceof _syntax2.default && (0, _operators.isOperator)(term);
	    }
	  }, {
	    key: "isUpdateOperator",
	    value: function isUpdateOperator(term) {
	      return term && term instanceof _syntax2.default && term.isPunctuator() && (term.val() === '++' || term.val() === '--');
	    }
	  }, {
	    key: "isFnDeclTransform",
	    value: function isFnDeclTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.FunctionDeclTransform;
	    }
	  }, {
	    key: "isVarDeclTransform",
	    value: function isVarDeclTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.VariableDeclTransform;
	    }
	  }, {
	    key: "isLetDeclTransform",
	    value: function isLetDeclTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.LetDeclTransform;
	    }
	  }, {
	    key: "isConstDeclTransform",
	    value: function isConstDeclTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.ConstDeclTransform;
	    }
	  }, {
	    key: "isSyntaxDeclTransform",
	    value: function isSyntaxDeclTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.SyntaxDeclTransform;
	    }
	  }, {
	    key: "isSyntaxrecDeclTransform",
	    value: function isSyntaxrecDeclTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.SyntaxrecDeclTransform;
	    }
	  }, {
	    key: "isSyntaxTemplate",
	    value: function isSyntaxTemplate(term) {
	      return term && term instanceof _syntax2.default && term.isSyntaxTemplate();
	    }
	  }, {
	    key: "isSyntaxQuoteTransform",
	    value: function isSyntaxQuoteTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.SyntaxQuoteTransform;
	    }
	  }, {
	    key: "isReturnStmtTransform",
	    value: function isReturnStmtTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.ReturnStatementTransform;
	    }
	  }, {
	    key: "isWhileTransform",
	    value: function isWhileTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.WhileTransform;
	    }
	  }, {
	    key: "isForTransform",
	    value: function isForTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.ForTransform;
	    }
	  }, {
	    key: "isSwitchTransform",
	    value: function isSwitchTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.SwitchTransform;
	    }
	  }, {
	    key: "isBreakTransform",
	    value: function isBreakTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.BreakTransform;
	    }
	  }, {
	    key: "isContinueTransform",
	    value: function isContinueTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.ContinueTransform;
	    }
	  }, {
	    key: "isDoTransform",
	    value: function isDoTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.DoTransform;
	    }
	  }, {
	    key: "isDebuggerTransform",
	    value: function isDebuggerTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.DebuggerTransform;
	    }
	  }, {
	    key: "isWithTransform",
	    value: function isWithTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.WithTransform;
	    }
	  }, {
	    key: "isTryTransform",
	    value: function isTryTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.TryTransform;
	    }
	  }, {
	    key: "isThrowTransform",
	    value: function isThrowTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.ThrowTransform;
	    }
	  }, {
	    key: "isIfTransform",
	    value: function isIfTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.IfTransform;
	    }
	  }, {
	    key: "isNewTransform",
	    value: function isNewTransform(term) {
	      return term && term instanceof _syntax2.default && this.context.env.get(term.resolve()) === _transforms.NewTransform;
	    }
	  }, {
	    key: "isCompiletimeTransform",
	    value: function isCompiletimeTransform(term) {
	      return term && term instanceof _syntax2.default && (this.context.env.get(term.resolve()) instanceof _transforms.CompiletimeTransform || this.context.store.get(term.resolve()) instanceof _transforms.CompiletimeTransform);
	    }
	  }, {
	    key: "getCompiletimeTransform",
	    value: function getCompiletimeTransform(term) {
	      if (this.context.env.has(term.resolve())) {
	        return this.context.env.get(term.resolve());
	      }
	      return this.context.store.get(term.resolve());
	    }
	  }, {
	    key: "lineNumberEq",
	    value: function lineNumberEq(a, b) {
	      if (!(a && b)) {
	        return false;
	      }
	      (0, _errors.assert)(a instanceof _syntax2.default, "expecting a syntax object");
	      (0, _errors.assert)(b instanceof _syntax2.default, "expecting a syntax object");
	      return a.lineNumber() === b.lineNumber();
	    }
	  }, {
	    key: "matchIdentifier",
	    value: function matchIdentifier(val) {
	      var lookahead = this.advance();
	      if (this.isIdentifier(lookahead)) {
	        return lookahead;
	      }
	      throw this.createError(lookahead, "expecting an identifier");
	    }
	  }, {
	    key: "matchKeyword",
	    value: function matchKeyword(val) {
	      var lookahead = this.advance();
	      if (this.isKeyword(lookahead, val)) {
	        return lookahead;
	      }
	      throw this.createError(lookahead, 'expecting ' + val);
	    }
	  }, {
	    key: "matchLiteral",
	    value: function matchLiteral() {
	      var lookahead = this.advance();
	      if (this.isNumericLiteral(lookahead) || this.isStringLiteral(lookahead) || this.isBooleanLiteral(lookahead) || this.isNullLiteral(lookahead) || this.isTemplate(lookahead) || this.isRegularExpression(lookahead)) {
	        return lookahead;
	      }
	      throw this.createError(lookahead, "expecting a literal");
	    }
	  }, {
	    key: "matchStringLiteral",
	    value: function matchStringLiteral() {
	      var lookahead = this.advance();
	      if (this.isStringLiteral(lookahead)) {
	        return lookahead;
	      }
	      throw this.createError(lookahead, 'expecting a string literal');
	    }
	  }, {
	    key: "matchTemplate",
	    value: function matchTemplate() {
	      var lookahead = this.advance();
	      if (this.isTemplate(lookahead)) {
	        return lookahead;
	      }
	      throw this.createError(lookahead, 'expecting a template literal');
	    }
	  }, {
	    key: "matchParens",
	    value: function matchParens() {
	      var lookahead = this.advance();
	      if (this.isParens(lookahead)) {
	        return lookahead.inner();
	      }
	      throw this.createError(lookahead, "expecting parens");
	    }
	  }, {
	    key: "matchCurlies",
	    value: function matchCurlies() {
	      var lookahead = this.advance();
	      if (this.isBraces(lookahead)) {
	        return lookahead.inner();
	      }
	      throw this.createError(lookahead, "expecting curly braces");
	    }
	  }, {
	    key: "matchSquares",
	    value: function matchSquares() {
	      var lookahead = this.advance();
	      if (this.isBrackets(lookahead)) {
	        return lookahead.inner();
	      }
	      throw this.createError(lookahead, "expecting sqaure braces");
	    }
	  }, {
	    key: "matchUnaryOperator",
	    value: function matchUnaryOperator() {
	      var lookahead = this.advance();
	      if ((0, _operators.isUnaryOperator)(lookahead)) {
	        return lookahead;
	      }
	      throw this.createError(lookahead, "expecting a unary operator");
	    }
	  }, {
	    key: "matchPunctuator",
	    value: function matchPunctuator(val) {
	      var lookahead = this.advance();
	      if (this.isPunctuator(lookahead)) {
	        if (typeof val !== 'undefined') {
	          if (lookahead.val() === val) {
	            return lookahead;
	          } else {
	            throw this.createError(lookahead, "expecting a " + val + " punctuator");
	          }
	        }
	        return lookahead;
	      }
	      throw this.createError(lookahead, "expecting a punctuator");
	    }
	  }, {
	    key: "createError",
	    value: function createError(stx, message) {
	      var ctx = "";
	      var offending = stx;
	      if (this.rest.size > 0) {
	        ctx = this.rest.slice(0, 20).map(function (term) {
	          if (term.isDelimiter()) {
	            return term.inner();
	          }
	          return _immutable.List.of(term);
	        }).flatten().map(function (s) {
	          if (s === offending) {
	            return "__" + s.val() + "__";
	          }
	          return s.val();
	        }).join(" ");
	      } else {
	        ctx = offending.toString();
	      }
	      return new Error(message + "\n" + ctx);
	    }
	  }]);

	  return Enforester;
	}();
	//# sourceMappingURL=enforester.js.map


/***/ },
/* 45 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.operatorLt = operatorLt;
	exports.getOperatorPrec = getOperatorPrec;
	exports.getOperatorAssoc = getOperatorAssoc;
	exports.isUnaryOperator = isUnaryOperator;
	exports.isOperator = isOperator;
	var unaryOperators = {
	  '+': true,
	  '-': true,
	  '!': true,
	  '~': true,
	  '++': true,
	  '--': true,
	  'typeof': true,
	  'void': true,
	  'delete': true
	};
	var binaryOperatorPrecedence = {
	  "*": 13,
	  "/": 13,
	  "%": 13,
	  "+": 12,
	  "-": 12,
	  ">>": 11,
	  "<<": 11,
	  ">>>": 11,
	  "<": 10,
	  "<=": 10,
	  ">": 10,
	  ">=": 10,
	  "in": 10,
	  "instanceof": 10,
	  "==": 9,
	  "!=": 9,
	  "===": 9,
	  "!==": 9,
	  "&": 8,
	  "^": 7,
	  "|": 6,
	  "&&": 5,
	  "||": 4
	};

	var operatorAssoc = {
	  "*": "left",
	  "/": "left",
	  "%": "left",
	  "+": "left",
	  "-": "left",
	  ">>": "left",
	  "<<": "left",
	  ">>>": "left",
	  "<": "left",
	  "<=": "left",
	  ">": "left",
	  ">=": "left",
	  "in": "left",
	  "instanceof": "left",
	  "==": "left",
	  "!=": "left",
	  "===": "left",
	  "!==": "left",
	  "&": "left",
	  "^": "left",
	  "|": "left",
	  "&&": "left",
	  "||": "left"
	};

	function operatorLt(left, right, assoc) {
	  if (assoc === "left") {
	    return left < right;
	  } else {
	    return left <= right;
	  }
	}

	function getOperatorPrec(op) {
	  return binaryOperatorPrecedence[op];
	}
	function getOperatorAssoc(op) {
	  return operatorAssoc[op];
	}

	function isUnaryOperator(op) {
	  return (op.isPunctuator() || op.isIdentifier() || op.isKeyword()) && unaryOperators.hasOwnProperty(op.val());
	}

	function isOperator(op) {
	  if (op.isPunctuator() || op.isIdentifier() || op.isKeyword()) {
	    return binaryOperatorPrecedence.hasOwnProperty(op) || unaryOperators.hasOwnProperty(op.val());
	  }
	  return false;
	}
	//# sourceMappingURL=operators.js.map


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mapSyntaxReducer = __webpack_require__(47);

	var _mapSyntaxReducer2 = _interopRequireDefault(_mapSyntaxReducer);

	var _shiftReducer = __webpack_require__(34);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _immutable = __webpack_require__(9);

	var _enforester = __webpack_require__(44);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	ctx :: {
	  of: (Syntax) -> ctx
	  next: (String) -> Syntax or Term
	}
	*/

	var MacroContext = function () {
	  function MacroContext(enf, name, context, useScope, introducedScope) {
	    var _this = this;

	    _classCallCheck(this, MacroContext);

	    // todo: perhaps replace with a symbol to keep mostly private?
	    this._enf = enf;
	    this.name = name;
	    this.context = context;
	    if (useScope && introducedScope) {
	      this.noScopes = false;
	      this.useScope = useScope;
	      this.introducedScope = introducedScope;
	    } else {
	      this.noScopes = true;
	    }
	    this[Symbol.iterator] = function () {
	      return _this;
	    };
	  }

	  _createClass(MacroContext, [{
	    key: "next",
	    value: function next() {
	      var type = arguments.length <= 0 || arguments[0] === undefined ? 'Syntax' : arguments[0];

	      if (this._enf.rest.size === 0) {
	        return {
	          done: true,
	          value: null
	        };
	      }
	      var value = undefined;
	      switch (type) {
	        case 'AssignmentExpression':
	        case 'expr':
	          value = this._enf.enforestExpressionLoop();
	          break;
	        case 'Expression':
	          value = this._enf.enforestExpression();
	          break;
	        case 'Syntax':
	          value = this._enf.advance();
	          if (!this.noScopes) {
	            value = value.addScope(this.useScope).addScope(this.introducedScope, this.context.bindings, { flip: true });
	          }
	          break;
	        default:
	          throw new Error('Unknown term type: ' + type);
	      }
	      return {
	        done: false,
	        value: value
	      };
	    }
	  }, {
	    key: "of",
	    value: function of(syn) {
	      var enf = undefined;
	      if (_immutable.List.isList(syn)) {
	        enf = new _enforester.Enforester(syn, (0, _immutable.List)(), this.context);
	      } else if (syn && typeof syn.isDelimiter === 'function' && syn.isDelimiter()) {
	        enf = new _enforester.Enforester(syn.inner(), (0, _immutable.List)(), this.context);
	      } else {
	        throw new Error('Cannot create a subcontext for unknown syntax type: ' + stxl);
	      }
	      return new MacroContext(enf, this.name, this.context);
	    }
	  }]);

	  return MacroContext;
	}();

	exports.default = MacroContext;
	//# sourceMappingURL=macro-context.js.map


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _shiftReducer = __webpack_require__(34);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var MapSyntaxReducer = function (_CloneReducer) {
	  _inherits(MapSyntaxReducer, _CloneReducer);

	  function MapSyntaxReducer(fn) {
	    _classCallCheck(this, MapSyntaxReducer);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MapSyntaxReducer).call(this));

	    _this.fn = fn;
	    return _this;
	  }

	  _createClass(MapSyntaxReducer, [{
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node, state) {
	      var name = this.fn(node.name);

	      return new _terms2.default("BindingIdentifier", {
	        name: name
	      });
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node, state) {
	      var name = this.fn(node.name);

	      return new _terms2.default("IdentifierExpression", {
	        name: name
	      });
	    }
	  }]);

	  return MapSyntaxReducer;
	}(_shiftReducer.CloneReducer);

	exports.default = MapSyntaxReducer;
	//# sourceMappingURL=map-syntax-reducer.js.map


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.processTemplate = processTemplate;
	exports.replaceTemplate = replaceTemplate;

	var _immutable = __webpack_require__(9);

	var _ramdaFantasy = __webpack_require__(14);

	var _ramda = __webpack_require__(26);

	var _ramda2 = _interopRequireDefault(_ramda);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _errors = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	Given a syntax list like:

	  [foo, bar, $, { 42, +, 24 }, baz]

	convert it to:

	  [foo, bar, $, { 0 }, baz]

	and return another list with the interpolated values at the corresponding
	positions.

	Requires either lookahead/lookbehind of one (to see the $).
	*/

	var isDolar = function isDolar(s) {
	  return s && s instanceof _syntax2.default && s.isIdentifier() && s.val() === '$';
	};
	var isDelimiter = function isDelimiter(s) {
	  return s && typeof s.isDelimiter === 'function' && s.isDelimiter();
	};
	var isBraces = function isBraces(s) {
	  return s && typeof s.isBraces === 'function' && s.isBraces();
	};
	var isParens = function isParens(s) {
	  return s && typeof s.isParens === 'function' && s.isParens();
	};
	var isBrackets = function isBrackets(s) {
	  return s && typeof s.isBrackets === 'function' && s.isBrackets();
	};

	var insertIntoDelimiter = _ramda2.default.cond([[isBraces, function (s, r) {
	  return _syntax2.default.fromBraces(r, s);
	}], [isParens, function (s, r) {
	  return _syntax2.default.fromParens(r, s);
	}], [isBrackets, function (s, r) {
	  return _syntax2.default.fromBrackets(r, s);
	}]]);

	var process = function process(acc, s) {
	  if (isBraces(s) && isDolar(acc.template.last())) {
	    return {
	      template: acc.template.push(_syntax2.default.fromBraces(_immutable.List.of(_syntax2.default.fromNumber(acc.interp.size)), s)),
	      interp: acc.interp.push(s.inner())
	    };
	  } else if (isDelimiter(s)) {
	    var innerResult = processTemplate(s.inner(), acc.interp);
	    return {
	      template: acc.template.push(insertIntoDelimiter(s, innerResult.template)),
	      interp: innerResult.interp
	    };
	  } else {
	    return {
	      template: acc.template.push(s),
	      interp: acc.interp
	    };
	  }
	};

	var replace = function replace(acc, s) {
	  if (isBraces(s) && isDolar(acc.template.last())) {
	    var index = s.inner().first().val();
	    (0, _errors.assert)(acc.rep.size > index, "unknown replacement value");
	    return {
	      template: acc.template.pop().concat(acc.rep.get(index)),
	      rep: acc.rep
	    };
	  } else if (isDelimiter(s)) {
	    var innerResult = replaceTemplate(s.inner(), acc.rep);
	    return {
	      template: acc.template.push(insertIntoDelimiter(s, innerResult)),
	      rep: acc.rep
	    };
	  } else {
	    return {
	      template: acc.template.push(s),
	      rep: acc.rep
	    };
	  }
	};

	function processTemplate(temp) {
	  var interp = arguments.length <= 1 || arguments[1] === undefined ? (0, _immutable.List)() : arguments[1];

	  return temp.reduce(process, { template: (0, _immutable.List)(), interp: interp });
	}

	function replaceTemplate(temp, rep) {
	  return temp.reduce(replace, { template: (0, _immutable.List)(), rep: rep }).template;
	}
	//# sourceMappingURL=template-processor.js.map


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(9);

	var _enforester = __webpack_require__(44);

	var _termExpander = __webpack_require__(30);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _bindingMap = __webpack_require__(13);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _env = __webpack_require__(50);

	var _env2 = _interopRequireDefault(_env);

	var _shiftReader = __webpack_require__(1);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _ramda = __webpack_require__(26);

	var _ = _interopRequireWildcard(_ramda);

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _ramdaFantasy = __webpack_require__(14);

	var _symbol = __webpack_require__(11);

	var _transforms = __webpack_require__(33);

	var _errors = __webpack_require__(12);

	var _loadSyntax = __webpack_require__(51);

	var _loadSyntax2 = _interopRequireDefault(_loadSyntax);

	var _scope = __webpack_require__(31);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Just = _ramdaFantasy.Maybe.Just;
	var Nothing = _ramdaFantasy.Maybe.Nothing;

	var registerSyntax = function registerSyntax(stx, context) {
	  var newBinding = (0, _symbol.gensym)(stx.val());
	  context.env.set(newBinding.toString(), new _transforms.VarBindingTransform(stx));
	  context.bindings.add(stx, {
	    binding: newBinding,
	    phase: 0,
	    // skip dup because js allows variable redeclarations
	    // (technically only for `var` but we can let later stages of the pipeline
	    // handle incorrect redeclarations of `const` and `let`)
	    skipDup: true
	  });
	};

	var registerBindings = _.cond([[_terms.isBindingIdentifier, function (_ref, context) {
	  var name = _ref.name;

	  registerSyntax(name, context);
	}], [_terms.isBindingPropertyIdentifier, function (_ref2, context) {
	  var binding = _ref2.binding;

	  registerBindings(binding, context);
	}], [_terms.isBindingPropertyProperty, function (_ref3, context) {
	  var binding = _ref3.binding;

	  registerBindings(binding, context);
	}], [_terms.isArrayBinding, function (_ref4, context) {
	  var elements = _ref4.elements;
	  var restElement = _ref4.restElement;

	  if (restElement != null) {
	    registerBindings(restElement, context);
	  }
	  elements.forEach(function (el) {
	    if (el != null) {
	      registerBindings(el, context);
	    }
	  });
	}], [_terms.isObjectBinding, function (_ref5, context) {
	  var properties = _ref5.properties;

	  properties.forEach(function (prop) {
	    return registerBindings(prop, context);
	  });
	}], [_.T, function (binding) {
	  return (0, _errors.assert)(false, "not implemented yet for: " + binding.type);
	}]]);

	var removeScope = _.cond([[_terms.isBindingIdentifier, function (_ref6, scope) {
	  var name = _ref6.name;
	  return new _terms2.default('BindingIdentifier', {
	    name: name.removeScope(scope)
	  });
	}], [_terms.isArrayBinding, function (_ref7, scope) {
	  var elements = _ref7.elements;
	  var restElement = _ref7.restElement;

	  return new _terms2.default('ArrayBinding', {
	    elements: elements.map(function (el) {
	      return el == null ? null : removeScope(el, scope);
	    }),
	    restElement: restElement == null ? null : removeScope(restElement, scope)
	  });
	}], [_terms.isBindingPropertyIdentifier, function (_ref8, scope) {
	  var binding = _ref8.binding;
	  var init = _ref8.init;
	  return new _terms2.default('BindingPropertyIdentifier', {
	    binding: removeScope(binding, scope),
	    init: init
	  });
	}], [_terms.isBindingPropertyProperty, function (_ref9, scope) {
	  var binding = _ref9.binding;
	  var name = _ref9.name;
	  return new _terms2.default('BindingPropertyProperty', {
	    binding: removeScope(binding, scope), name: name
	  });
	}], [_terms.isObjectBinding, function (_ref10, scope) {
	  var properties = _ref10.properties;
	  return new _terms2.default('ObjectBinding', {
	    properties: properties.map(function (prop) {
	      return removeScope(prop, scope);
	    })
	  });
	}], [_.T, function (binding) {
	  return (0, _errors.assert)(false, "not implemented yet for: " + binding.type);
	}]]);

	function findNameInExports(name, exp) {
	  var foundNames = exp.reduce(function (acc, e) {
	    if (e.declaration) {
	      return acc.concat(e.declaration.declarators.reduce(function (acc, decl) {
	        if (decl.binding.name.val() === name.val()) {
	          return acc.concat(decl.binding.name);
	        }
	        return acc;
	      }, (0, _immutable.List)()));
	    }
	    return acc;
	  }, (0, _immutable.List)());
	  (0, _errors.assert)(foundNames.size <= 1, 'expecting no more than 1 matching name in exports');
	  return foundNames.get(0);
	}

	function bindImports(impTerm, exModule, context) {
	  var names = [];
	  impTerm.namedImports.forEach(function (specifier) {
	    var name = specifier.binding.name;
	    var exportName = findNameInExports(name, exModule.exportEntries);
	    if (exportName != null) {
	      var newBinding = (0, _symbol.gensym)(name.val());
	      context.bindings.addForward(name, exportName, newBinding);
	      if (context.store.has(exportName.resolve())) {
	        names.push(name);
	      }
	    }
	    // // TODO: better error
	    // throw 'imported binding ' + name.val() + ' not found in exports of module' + exModule.moduleSpecifier;
	  });
	  return (0, _immutable.List)(names);
	}

	var TokenExpander = function () {
	  function TokenExpander(context) {
	    _classCallCheck(this, TokenExpander);

	    this.context = context;
	  }

	  _createClass(TokenExpander, [{
	    key: "expand",
	    value: function expand(stxl) {
	      var result = (0, _immutable.List)();
	      if (stxl.size === 0) {
	        return result;
	      }
	      var prev = (0, _immutable.List)();
	      var enf = new _enforester.Enforester(stxl, prev, this.context);
	      var self = this;
	      while (!enf.done) {

	        var term = _.pipe(_.bind(enf.enforest, enf), _.cond([[_terms.isVariableDeclarationStatement, function (term) {
	          // first, remove the use scope from each binding
	          term.declaration.declarators = term.declaration.declarators.map(function (decl) {
	            return new _terms2.default('VariableDeclarator', {
	              binding: removeScope(decl.binding, self.context.useScope),
	              init: decl.init
	            });
	          });

	          // syntax id^{a, b} = <init>^{a, b}
	          // ->
	          // syntaxrec id^{a,b,c} = function() { return <<id^{a}>> }
	          // syntaxrec id^{a,b} = <init>^{a,b,c}
	          if ((0, _terms.isSyntaxDeclaration)(term.declaration)) {
	            (function () {
	              // TODO: do stuff
	              var scope = (0, _scope.freshScope)('nonrec');
	              term.declaration.declarators.forEach(function (decl) {
	                var name = decl.binding.name;
	                var nameAdded = name.addScope(scope);
	                var nameRemoved = name.removeScope(self.context.currentScope[self.context.currentScope.length - 1]);
	                var newBinding = (0, _symbol.gensym)(name.val());
	                self.context.bindings.addForward(nameAdded, nameRemoved, newBinding);
	                decl.init.body = decl.init.body.map(function (s) {
	                  return s.addScope(scope, self.context.bindings);
	                });
	              });
	            })();
	          }

	          // for syntax declarations we need to load the compiletime value
	          // into the environment
	          if ((0, _terms.isSyntaxDeclaration)(term.declaration) || (0, _terms.isSyntaxrecDeclaration)(term.declaration)) {
	            term.declaration.declarators.forEach(function (decl) {
	              registerBindings(decl.binding, self.context);
	              (0, _loadSyntax2.default)(decl, self.context, self.context.env);
	            });
	            // do not add syntax declarations to the result
	            return Nothing();
	          } else {
	            // add each binding to the environment
	            term.declaration.declarators.forEach(function (decl) {
	              return registerBindings(decl.binding, self.context);
	            });
	          }
	          return Just(term);
	        }], [_terms.isFunctionWithName, function (term) {
	          term.name = removeScope(term.name, self.context.useScope);
	          registerBindings(term.name, self.context);
	          return Just(term);
	        }], [_terms.isImport, function (term) {
	          if (self.context.followImports) {
	            var mod = self.context.modules.load(term.moduleSpecifier.val(), self.context);
	            // mutates the store
	            mod.visit(self.context);
	            var boundNames = bindImports(term, mod, self.context);
	            // NOTE: self is a hack for MVP modules
	            if (boundNames.size === 0) {
	              return Just(term);
	            }
	            return Nothing();
	          }
	          return Just(term);
	        }], [_terms.isEOF, Nothing], [_.T, Just]]), _ramdaFantasy.Maybe.maybe((0, _immutable.List)(), _.identity))();

	        result = result.concat(term);
	      }
	      return result;
	    }
	  }]);

	  return TokenExpander;
	}();

	exports.default = TokenExpander;
	//# sourceMappingURL=token-expander.js.map


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _transforms = __webpack_require__(33);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Env = function () {
	  function Env() {
	    _classCallCheck(this, Env);

	    this.map = new Map();
	    this.map.set("function", _transforms.FunctionDeclTransform);
	    this.map.set("var", _transforms.VariableDeclTransform);
	    this.map.set("let", _transforms.LetDeclTransform);
	    this.map.set("const", _transforms.ConstDeclTransform);
	    this.map.set("syntaxQuote", _transforms.SyntaxQuoteTransform);
	    this.map.set("syntaxrec", _transforms.SyntaxrecDeclTransform);
	    this.map.set("syntax", _transforms.SyntaxDeclTransform);
	    this.map.set("return", _transforms.ReturnStatementTransform);
	    this.map.set("while", _transforms.WhileTransform);
	    this.map.set("if", _transforms.IfTransform);
	    this.map.set("for", _transforms.ForTransform);
	    this.map.set("switch", _transforms.SwitchTransform);
	    this.map.set("break", _transforms.BreakTransform);
	    this.map.set("continue", _transforms.ContinueTransform);
	    this.map.set("do", _transforms.DoTransform);
	    this.map.set("debugger", _transforms.DebuggerTransform);
	    this.map.set("with", _transforms.WithTransform);
	    this.map.set("try", _transforms.TryTransform);
	    this.map.set("throw", _transforms.ThrowTransform);
	    this.map.set("new", _transforms.NewTransform);
	  }

	  _createClass(Env, [{
	    key: "has",
	    value: function has(key) {
	      return this.map.has(key);
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      return this.map.get(key);
	    }
	  }, {
	    key: "set",
	    value: function set(key, val) {
	      return this.map.set(key, val);
	    }
	  }]);

	  return Env;
	}();

	exports.default = Env;
	//# sourceMappingURL=env.js.map


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ramda = __webpack_require__(26);

	var _ = _interopRequireWildcard(_ramda);

	var _termExpander = __webpack_require__(30);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _immutable = __webpack_require__(9);

	var _parseReducer = __webpack_require__(52);

	var _parseReducer2 = _interopRequireDefault(_parseReducer);

	var _shiftReducer = __webpack_require__(34);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _serializer = __webpack_require__(38);

	var _syntax = __webpack_require__(10);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _shiftCodegen = __webpack_require__(53);

	var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

	var _transforms = __webpack_require__(33);

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _shiftReader = __webpack_require__(1);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _templateProcessor = __webpack_require__(48);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// indirect eval so in the global scope
	var geval = eval;

	function sanitizeReplacementValues(values) {
	  if (Array.isArray(values)) {
	    return sanitizeReplacementValues((0, _immutable.List)(values));
	  } else if (_immutable.List.isList(values)) {
	    return values.map(sanitizeReplacementValues);
	  } else if (values == null) {
	    throw new Error("replacement values for syntax template must not but null or undefined");
	  }
	  return values;
	}

	// (Expression, Context) -> [function]
	function loadForCompiletime(expr, context) {
	  var deserializer = (0, _serializer.makeDeserializer)(context.bindings);
	  var sandbox = {
	    syntaxQuote: function syntaxQuote(strings) {
	      for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        values[_key - 1] = arguments[_key];
	      }

	      var ctx = deserializer.read(_.last(values));
	      var reader = new _shiftReader2.default(strings, ctx.context, _.take(values.length - 1, values));
	      return reader.read();
	    },
	    syntaxTemplate: function syntaxTemplate(str) {
	      for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        values[_key2 - 1] = arguments[_key2];
	      }

	      return (0, _templateProcessor.replaceTemplate)(deserializer.read(str), sanitizeReplacementValues(values));
	    }
	  };

	  var sandboxKeys = (0, _immutable.List)(Object.keys(sandbox));
	  var sandboxVals = sandboxKeys.map(function (k) {
	    return sandbox[k];
	  }).toArray();

	  var parsed = (0, _shiftReducer2.default)(new _parseReducer2.default(), new _terms2.default("Module", {
	    directives: (0, _immutable.List)(),
	    items: _immutable.List.of(new _terms2.default("ExpressionStatement", {
	      expression: new _terms2.default("FunctionExpression", {
	        isGenerator: false,
	        name: null,
	        params: new _terms2.default("FormalParameters", {
	          items: sandboxKeys.map(function (param) {
	            return new _terms2.default("BindingIdentifier", {
	              name: _syntax2.default.fromIdentifier(param)
	            });
	          }),
	          rest: null
	        }),
	        body: new _terms2.default("FunctionBody", {
	          directives: _immutable.List.of(new _terms2.default('Directive', {
	            rawValue: 'use strict'
	          })),
	          statements: _immutable.List.of(new _terms2.default("ReturnStatement", {
	            expression: expr
	          }))
	        })
	      })
	    }))
	  }));

	  // TODO: should just pass an AST to babel but the estree converter still
	  // needs some work so until then just gen a string
	  // let estree = convert.toSpiderMonkey(parsed);
	  // let result = transform.fromAst(wrapForCompiletime(estree, sandboxKeys));

	  // let result = babel.transform(wrapForCompiletime(estree, sandboxKeys));
	  var gen = (0, _shiftCodegen2.default)(parsed, new _shiftCodegen.FormattedCodeGen());
	  var result = context.transform(gen);
	  return geval(result.code).apply(undefined, sandboxVals);
	}

	// function wrapForCompiletime(ast, keys) {
	//   // todo: hygiene
	//   let params = keys.map(k => new Identifier(k));
	//   let body = new ReturnStatement(ast);
	//   let fn = new FunctionExpression(null, params, new BlockStatement([body]));
	//   return new Program([new ExpressionStatement(fn)]);
	// }

	var loadSyntax = _.cond([[_.where({ binding: _terms.isBindingIdentifier }), _.curry(function (_ref, context, env) {
	  var binding = _ref.binding;
	  var init = _ref.init;

	  // finish the expansion early for the initialization
	  var termExpander = new _termExpander2.default(context);
	  var initValue = loadForCompiletime(termExpander.expand(init), context);

	  env.set(binding.name.resolve(), new _transforms.CompiletimeTransform(initValue));
	})], [_.T, function (_) {
	  return assert(false, "not implemented yet");
	}]]);

	exports.default = loadSyntax;
	//# sourceMappingURL=load-syntax.js.map


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _shiftReducer = __webpack_require__(34);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ParseReducer = function (_CloneReducer) {
	  _inherits(ParseReducer, _CloneReducer);

	  function ParseReducer() {
	    _classCallCheck(this, ParseReducer);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ParseReducer).apply(this, arguments));
	  }

	  _createClass(ParseReducer, [{
	    key: "reduceModule",
	    value: function reduceModule(node, state) {
	      return new _terms2.default("Module", {
	        directives: state.directives.toArray(),
	        items: state.items.toArray()
	      });
	    }
	  }, {
	    key: "reduceImport",
	    value: function reduceImport(node, state) {
	      var moduleSpecifier = state.moduleSpecifier ? state.moduleSpecifier.val() : null;
	      return new _terms2.default('Import', {
	        defaultBinding: state.defaultBinding,
	        namedImports: state.namedImports.toArray(),
	        moduleSpecifier: moduleSpecifier
	      });
	    }
	  }, {
	    key: "reduceImportNamespace",
	    value: function reduceImportNamespace(node, state) {
	      var moduleSpecifier = state.moduleSpecifier ? state.moduleSpecifier.val() : null;
	      return new _terms2.default('ImportNamespace', {
	        defaultBinding: state.defaultBinding,
	        namespaceBinding: state.namespaceBinding,
	        moduleSpecifier: moduleSpecifier
	      });
	    }
	  }, {
	    key: "reduceExport",
	    value: function reduceExport(node, state) {
	      return new _terms2.default('Export', {
	        declaration: state.declaration
	      });
	    }
	  }, {
	    key: "reduceExportAllFrom",
	    value: function reduceExportAllFrom(node, state) {
	      var moduleSpecifier = state.moduleSpecifier ? state.moduleSpecifier.val() : null;
	      return new _terms2.default('ExportAllFrom', { moduleSpecifier: moduleSpecifier });
	    }
	  }, {
	    key: "reduceExportFrom",
	    value: function reduceExportFrom(node, state) {
	      var moduleSpecifier = state.moduleSpecifier ? state.moduleSpecifier.val() : null;
	      return new _terms2.default('ExportFrom', {
	        moduleSpecifier: moduleSpecifier,
	        namedExports: state.namedExports.toArray()
	      });
	    }
	  }, {
	    key: "reduceExportSpecifier",
	    value: function reduceExportSpecifier(node, state) {
	      return new _terms2.default('ExportSpecifier', {
	        name: state.name ? state.name.resolve() : null,
	        exportedName: state.exportedName ? state.exportedName.resolve() : null
	      });
	    }
	  }, {
	    key: "reduceImportSpecifier",
	    value: function reduceImportSpecifier(node, state) {
	      var name = state.name ? state.name.resolve() : null;
	      return new _terms2.default('ImportSpecifier', {
	        name: name,
	        binding: state.binding
	      });
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node, state) {
	      return new _terms2.default("IdentifierExpression", {
	        name: node.name.resolve()
	      });
	    }
	  }, {
	    key: "reduceLiteralNumericExpression",
	    value: function reduceLiteralNumericExpression(node, state) {
	      return new _terms2.default("LiteralNumericExpression", {
	        value: node.value.val()
	      });
	    }
	  }, {
	    key: "reduceLiteralBooleanExpression",
	    value: function reduceLiteralBooleanExpression(node, state) {
	      return new _terms2.default("LiteralBooleanExpression", {
	        value: node.value.val() === 'true'
	      });
	    }
	  }, {
	    key: "reduceLiteralStringExpression",
	    value: function reduceLiteralStringExpression(node, state) {
	      return new _terms2.default("LiteralStringExpression", {
	        value: node.value.token.str
	      });
	    }
	  }, {
	    key: "reduceCallExpression",
	    value: function reduceCallExpression(node, state) {
	      return new _terms2.default("CallExpression", {
	        callee: state.callee,
	        arguments: state.arguments.toArray()
	      });
	    }
	  }, {
	    key: "reduceFunctionBody",
	    value: function reduceFunctionBody(node, state) {
	      return new _terms2.default("FunctionBody", {
	        directives: state.directives.toArray(),
	        statements: state.statements.toArray()
	      });
	    }
	  }, {
	    key: "reduceFormalParameters",
	    value: function reduceFormalParameters(node, state) {
	      return new _terms2.default("FormalParameters", {
	        items: state.items.toArray(),
	        rest: state.rest
	      });
	    }
	  }, {
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node, state) {
	      return new _terms2.default("BindingIdentifier", {
	        name: node.name.resolve()
	      });
	    }
	  }, {
	    key: "reduceBinaryExpression",
	    value: function reduceBinaryExpression(node, state) {
	      return new _terms2.default("BinaryExpression", {
	        left: state.left,
	        operator: node.operator.val(),
	        right: state.right
	      });
	    }
	  }, {
	    key: "reduceObjectExpression",
	    value: function reduceObjectExpression(node, state) {
	      return new _terms2.default("ObjectExpression", {
	        properties: state.properties.toArray()
	      });
	    }
	  }, {
	    key: "reduceVariableDeclaration",
	    value: function reduceVariableDeclaration(node, state) {
	      return new _terms2.default("VariableDeclaration", {
	        kind: state.kind,
	        declarators: state.declarators.toArray()
	      });
	    }
	  }, {
	    key: "reduceStaticPropertyName",
	    value: function reduceStaticPropertyName(node, state) {
	      return new _terms2.default("StaticPropertyName", {
	        value: node.value.val().toString()
	      });
	    }
	  }, {
	    key: "reduceArrayExpression",
	    value: function reduceArrayExpression(node, state) {
	      return new _terms2.default("ArrayExpression", {
	        elements: state.elements.toArray()
	      });
	    }
	  }, {
	    key: "reduceStaticMemberExpression",
	    value: function reduceStaticMemberExpression(node, state) {
	      return new _terms2.default("StaticMemberExpression", {
	        object: state.object,
	        property: state.property.val()
	      });
	    }
	  }]);

	  return ParseReducer;
	}(_shiftReducer.CloneReducer);

	exports.default = ParseReducer;
	//# sourceMappingURL=parse-reducer.js.map


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SemiOp = exports.CommaSep = exports.Semi = exports.Seq = exports.ContainsIn = exports.NoIn = exports.Brace = exports.Bracket = exports.Paren = exports.NumberCodeRep = exports.Token = exports.Empty = exports.CodeRep = exports.escapeStringLiteral = exports.getPrecedence = exports.Precedence = exports.Sep = exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.MinimalCodeGen = undefined;
	exports.default = codeGen;

	var _minimalCodegen = __webpack_require__(54);

	Object.defineProperty(exports, "MinimalCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _minimalCodegen.default;
	  }
	});

	var _formattedCodegen = __webpack_require__(57);

	Object.defineProperty(exports, "ExtensibleCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.ExtensibleCodeGen;
	  }
	});
	Object.defineProperty(exports, "FormattedCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.FormattedCodeGen;
	  }
	});
	Object.defineProperty(exports, "Sep", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.Sep;
	  }
	});

	var _coderep = __webpack_require__(56);

	Object.defineProperty(exports, "Precedence", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Precedence;
	  }
	});
	Object.defineProperty(exports, "getPrecedence", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.getPrecedence;
	  }
	});
	Object.defineProperty(exports, "escapeStringLiteral", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.escapeStringLiteral;
	  }
	});
	Object.defineProperty(exports, "CodeRep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.CodeRep;
	  }
	});
	Object.defineProperty(exports, "Empty", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Empty;
	  }
	});
	Object.defineProperty(exports, "Token", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Token;
	  }
	});
	Object.defineProperty(exports, "NumberCodeRep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.NumberCodeRep;
	  }
	});
	Object.defineProperty(exports, "Paren", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Paren;
	  }
	});
	Object.defineProperty(exports, "Bracket", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Bracket;
	  }
	});
	Object.defineProperty(exports, "Brace", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Brace;
	  }
	});
	Object.defineProperty(exports, "NoIn", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.NoIn;
	  }
	});
	Object.defineProperty(exports, "ContainsIn", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.ContainsIn;
	  }
	});
	Object.defineProperty(exports, "Seq", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Seq;
	  }
	});
	Object.defineProperty(exports, "Semi", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Semi;
	  }
	});
	Object.defineProperty(exports, "CommaSep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.CommaSep;
	  }
	});
	Object.defineProperty(exports, "SemiOp", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.SemiOp;
	  }
	});

	var _shiftReducer = __webpack_require__(34);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _token_stream = __webpack_require__(58);

	var _minimalCodegen2 = _interopRequireDefault(_minimalCodegen);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function codeGen(script) {
	  var generator = arguments.length <= 1 || arguments[1] === undefined ? new _minimalCodegen2.default() : arguments[1];

	  var ts = new _token_stream.TokenStream();
	  var rep = (0, _shiftReducer2.default)(generator, script);
	  rep.emit(ts);
	  return ts.result;
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _objectAssign = __webpack_require__(55);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _esutils = __webpack_require__(4);

	var _coderep = __webpack_require__(56);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function p(node, precedence, a) {
	  return (0, _coderep.getPrecedence)(node) < precedence ? paren(a) : a;
	}

	function t(token) {
	  return new _coderep.Token(token);
	}

	function paren(rep) {
	  return new _coderep.Paren(rep);
	}

	function brace(rep) {
	  return new _coderep.Brace(rep);
	}

	function bracket(rep) {
	  return new _coderep.Bracket(rep);
	}

	function noIn(rep) {
	  return new _coderep.NoIn(rep);
	}

	function markContainsIn(state) {
	  return state.containsIn ? new _coderep.ContainsIn(state) : state;
	}

	function seq() {
	  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
	    reps[_key] = arguments[_key];
	  }

	  return new _coderep.Seq(reps);
	}

	function semi() {
	  return new _coderep.Semi();
	}

	function semiOp() {
	  return new _coderep.SemiOp();
	}

	function empty() {
	  return new _coderep.Empty();
	}

	function commaSep(pieces) {
	  return new _coderep.CommaSep(pieces);
	}

	function getAssignmentExpr(state) {
	  return state ? state.containsGroup ? paren(state) : state : empty();
	}

	var MinimalCodeGen = function () {
	  function MinimalCodeGen() {
	    _classCallCheck(this, MinimalCodeGen);
	  }

	  _createClass(MinimalCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(paren(original.children[0]), semiOp());
	      }
	      return original;
	    }
	  }, {
	    key: "reduceArrayExpression",
	    value: function reduceArrayExpression(node, _ref) {
	      var elements = _ref.elements;

	      if (elements.length === 0) {
	        return bracket(empty());
	      }

	      var content = commaSep(elements.map(getAssignmentExpr));
	      if (elements.length > 0 && elements[elements.length - 1] == null) {
	        content = seq(content, t(","));
	      }
	      return bracket(content);
	    }
	  }, {
	    key: "reduceSpreadElement",
	    value: function reduceSpreadElement(node, _ref2) {
	      var expression = _ref2.expression;

	      return seq(t("..."), p(node.expression, _coderep.Precedence.Assignment, expression));
	    }
	  }, {
	    key: "reduceAssignmentExpression",
	    value: function reduceAssignmentExpression(node, _ref3) {
	      var binding = _ref3.binding;
	      var expression = _ref3.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t("="), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceCompoundAssignmentExpression",
	    value: function reduceCompoundAssignmentExpression(node, _ref4) {
	      var binding = _ref4.binding;
	      var expression = _ref4.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceBinaryExpression",
	    value: function reduceBinaryExpression(node, _ref5) {
	      var left = _ref5.left;
	      var right = _ref5.right;

	      var leftCode = left;
	      var startsWithCurly = left.startsWithCurly;
	      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
	      var leftContainsIn = left.containsIn;
	      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
	        leftCode = paren(leftCode);
	        startsWithCurly = false;
	        startsWithLetSquareBracket = false;
	        startsWithFunctionOrClass = false;
	        leftContainsIn = false;
	      }
	      var rightCode = right;
	      var rightContainsIn = right.containsIn;
	      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        rightContainsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), {
	        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
	        containsGroup: node.operator == ",",
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceBindingWithDefault",
	    value: function reduceBindingWithDefault(node, _ref6) {
	      var binding = _ref6.binding;
	      var init = _ref6.init;

	      return seq(binding, t("="), init);
	    }
	  }, {
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node) {
	      var a = t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceArrayBinding",
	    value: function reduceArrayBinding(node, _ref7) {
	      var elements = _ref7.elements;
	      var restElement = _ref7.restElement;

	      var content = undefined;
	      if (elements.length === 0) {
	        content = restElement == null ? empty() : seq(t("..."), restElement);
	      } else {
	        elements = elements.concat(restElement == null ? [] : [seq(t("..."), restElement)]);
	        content = commaSep(elements.map(getAssignmentExpr));
	        if (elements.length > 0 && elements[elements.length - 1] == null) {
	          content = seq(content, t(","));
	        }
	      }
	      return bracket(content);
	    }
	  }, {
	    key: "reduceObjectBinding",
	    value: function reduceObjectBinding(node, _ref8) {
	      var properties = _ref8.properties;

	      var state = brace(commaSep(properties));
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceBindingPropertyIdentifier",
	    value: function reduceBindingPropertyIdentifier(node, _ref9) {
	      var binding = _ref9.binding;
	      var init = _ref9.init;

	      if (node.init == null) return binding;
	      return seq(binding, t("="), init);
	    }
	  }, {
	    key: "reduceBindingPropertyProperty",
	    value: function reduceBindingPropertyProperty(node, _ref10) {
	      var name = _ref10.name;
	      var binding = _ref10.binding;

	      return seq(name, t(":"), binding);
	    }
	  }, {
	    key: "reduceBlock",
	    value: function reduceBlock(node, _ref11) {
	      var statements = _ref11.statements;

	      return brace(seq.apply(undefined, _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceBlockStatement",
	    value: function reduceBlockStatement(node, _ref12) {
	      var block = _ref12.block;

	      return block;
	    }
	  }, {
	    key: "reduceBreakStatement",
	    value: function reduceBreakStatement(node, _ref13) {
	      var label = _ref13.label;

	      return seq(t("break"), label ? t(label) : empty(), semiOp());
	    }
	  }, {
	    key: "reduceCallExpression",
	    value: function reduceCallExpression(node, _ref14) {
	      var callee = _ref14.callee;
	      var args = _ref14.arguments;

	      return (0, _objectAssign2.default)(seq(p(node.callee, (0, _coderep.getPrecedence)(node), callee), paren(commaSep(args))), {
	        startsWithCurly: callee.startsWithCurly,
	        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
	        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceCatchClause",
	    value: function reduceCatchClause(node, _ref15) {
	      var binding = _ref15.binding;
	      var body = _ref15.body;

	      return seq(t("catch"), paren(binding), body);
	    }
	  }, {
	    key: "reduceClassDeclaration",
	    value: function reduceClassDeclaration(node, _ref16) {
	      var name = _ref16.name;
	      var _super = _ref16.super;
	      var elements = _ref16.elements;

	      var state = seq(t("class"), name);
	      if (_super != null) {
	        state = seq(state, t("extends"), _super);
	      }
	      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
	      return state;
	    }
	  }, {
	    key: "reduceClassExpression",
	    value: function reduceClassExpression(node, _ref17) {
	      var name = _ref17.name;
	      var _super = _ref17.super;
	      var elements = _ref17.elements;

	      var state = t("class");
	      if (name != null) {
	        state = seq(state, name);
	      }
	      if (_super != null) {
	        state = seq(state, t("extends"), _super);
	      }
	      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceClassElement",
	    value: function reduceClassElement(node, _ref18) {
	      var method = _ref18.method;

	      if (!node.isStatic) return method;
	      return seq(t("static"), method);
	    }
	  }, {
	    key: "reduceComputedMemberExpression",
	    value: function reduceComputedMemberExpression(node, _ref19) {
	      var object = _ref19.object;
	      var expression = _ref19.expression;

	      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
	      return (0, _objectAssign2.default)(seq(p(node.object, (0, _coderep.getPrecedence)(node), object), bracket(expression)), {
	        startsWithLet: object.startsWithLet,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithCurly: object.startsWithCurly,
	        startsWithFunctionOrClass: object.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceComputedPropertyName",
	    value: function reduceComputedPropertyName(node, _ref20) {
	      var expression = _ref20.expression;

	      return bracket(expression);
	    }
	  }, {
	    key: "reduceConditionalExpression",
	    value: function reduceConditionalExpression(node, _ref21) {
	      var test = _ref21.test;
	      var consequent = _ref21.consequent;
	      var alternate = _ref21.alternate;

	      var containsIn = test.containsIn || alternate.containsIn;
	      var startsWithCurly = test.startsWithCurly;
	      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
	      return (0, _objectAssign2.default)(seq(p(node.test, _coderep.Precedence.LogicalOR, test), t("?"), p(node.consequent, _coderep.Precedence.Assignment, consequent), t(":"), p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
	        containsIn: containsIn,
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceContinueStatement",
	    value: function reduceContinueStatement(node, _ref22) {
	      var label = _ref22.label;

	      return seq(t("continue"), label ? t(label) : empty(), semiOp());
	    }
	  }, {
	    key: "reduceDataProperty",
	    value: function reduceDataProperty(node, _ref23) {
	      var name = _ref23.name;
	      var expression = _ref23.expression;

	      return seq(name, t(":"), getAssignmentExpr(expression));
	    }
	  }, {
	    key: "reduceDebuggerStatement",
	    value: function reduceDebuggerStatement(node) {
	      return seq(t("debugger"), semiOp());
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref24) {
	      var body = _ref24.body;
	      var test = _ref24.test;

	      return seq(t("do"), body, t("while"), paren(test), semiOp());
	    }
	  }, {
	    key: "reduceEmptyStatement",
	    value: function reduceEmptyStatement(node) {
	      return semi();
	    }
	  }, {
	    key: "reduceExpressionStatement",
	    value: function reduceExpressionStatement(node, _ref25) {
	      var expression = _ref25.expression;

	      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
	      return seq(needsParens ? paren(expression) : expression, semiOp());
	    }
	  }, {
	    key: "reduceForInStatement",
	    value: function reduceForInStatement(node, _ref26) {
	      var left = _ref26.left;
	      var right = _ref26.right;
	      var body = _ref26.body;

	      var leftP = left;
	      switch (node.left.type) {
	        case "VariableDeclaration":
	          leftP = noIn(markContainsIn(left));
	          break;
	        case "BindingIdentifier":
	          if (node.left.name === "let") {
	            leftP = paren(left);
	          }
	          break;
	      }
	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(leftP, t("in"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForOfStatement",
	    value: function reduceForOfStatement(node, _ref27) {
	      var left = _ref27.left;
	      var right = _ref27.right;
	      var body = _ref27.body;

	      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(left.startsWithLet ? paren(left) : left, t("of"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForStatement",
	    value: function reduceForStatement(node, _ref28) {
	      var init = _ref28.init;
	      var test = _ref28.test;
	      var update = _ref28.update;
	      var body = _ref28.body;

	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(init ? noIn(markContainsIn(init)) : empty(), semi(), test || empty(), semi(), update || empty())), body), {
	        endsWithMissingElse: body.endsWithMissingElse
	      });
	    }
	  }, {
	    key: "reduceFunctionBody",
	    value: function reduceFunctionBody(node, _ref29) {
	      var directives = _ref29.directives;
	      var statements = _ref29.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceFunctionDeclaration",
	    value: function reduceFunctionDeclaration(node, _ref30) {
	      var name = _ref30.name;
	      var params = _ref30.params;
	      var body = _ref30.body;

	      return seq(t("function"), node.isGenerator ? t("*") : empty(), node.name.name === "*default*" ? empty() : name, paren(params), brace(body));
	    }
	  }, {
	    key: "reduceFunctionExpression",
	    value: function reduceFunctionExpression(node, _ref31) {
	      var name = _ref31.name;
	      var params = _ref31.params;
	      var body = _ref31.body;

	      var state = seq(t("function"), node.isGenerator ? t("*") : empty(), name ? name : empty(), paren(params), brace(body));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceFormalParameters",
	    value: function reduceFormalParameters(node, _ref32) {
	      var items = _ref32.items;
	      var rest = _ref32.rest;

	      return commaSep(items.concat(rest == null ? [] : [seq(t("..."), rest)]));
	    }
	  }, {
	    key: "reduceArrowExpression",
	    value: function reduceArrowExpression(node, _ref33) {
	      var params = _ref33.params;
	      var body = _ref33.body;

	      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
	        params = paren(params);
	      }
	      if (node.body.type === "FunctionBody") {
	        body = brace(body);
	      } else if (body.startsWithCurly) {
	        body = paren(body);
	      }
	      return seq(params, t("=>"), p(node.body, _coderep.Precedence.Assignment, body));
	    }
	  }, {
	    key: "reduceGetter",
	    value: function reduceGetter(node, _ref34) {
	      var name = _ref34.name;
	      var body = _ref34.body;

	      return seq(t("get"), name, paren(empty()), brace(body));
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node) {
	      var a = t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref35) {
	      var test = _ref35.test;
	      var consequent = _ref35.consequent;
	      var alternate = _ref35.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = brace(consequent);
	      }
	      return (0, _objectAssign2.default)(seq(t("if"), paren(test), consequent, alternate ? seq(t("else"), alternate) : empty()), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceImport",
	    value: function reduceImport(node, _ref36) {
	      var defaultBinding = _ref36.defaultBinding;
	      var namedImports = _ref36.namedImports;

	      var bindings = [];
	      if (defaultBinding != null) {
	        bindings.push(defaultBinding);
	      }
	      if (namedImports.length > 0) {
	        bindings.push(brace(commaSep(namedImports)));
	      }
	      if (bindings.length === 0) {
	        return seq(t("import"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	      }
	      return seq(t("import"), commaSep(bindings), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceImportNamespace",
	    value: function reduceImportNamespace(node, _ref37) {
	      var defaultBinding = _ref37.defaultBinding;
	      var namespaceBinding = _ref37.namespaceBinding;

	      return seq(t("import"), defaultBinding == null ? empty() : seq(defaultBinding, t(",")), t("*"), t("as"), namespaceBinding, t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceImportSpecifier",
	    value: function reduceImportSpecifier(node, _ref38) {
	      var binding = _ref38.binding;

	      if (node.name == null) return binding;
	      return seq(t(node.name), t("as"), binding);
	    }
	  }, {
	    key: "reduceExportAllFrom",
	    value: function reduceExportAllFrom(node) {
	      return seq(t("export"), t("*"), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceExportFrom",
	    value: function reduceExportFrom(node, _ref39) {
	      var namedExports = _ref39.namedExports;

	      return seq(t("export"), brace(commaSep(namedExports)), node.moduleSpecifier == null ? empty() : seq(t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp()));
	    }
	  }, {
	    key: "reduceExport",
	    value: function reduceExport(node, _ref40) {
	      var declaration = _ref40.declaration;

	      switch (node.declaration.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          declaration = seq(declaration, semiOp());
	      }
	      return seq(t("export"), declaration);
	    }
	  }, {
	    key: "reduceExportDefault",
	    value: function reduceExportDefault(node, _ref41) {
	      var body = _ref41.body;

	      body = body.startsWithFunctionOrClass ? paren(body) : body;
	      switch (node.body.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          body = seq(body, semiOp());
	      }
	      return seq(t("export default"), body);
	    }
	  }, {
	    key: "reduceExportSpecifier",
	    value: function reduceExportSpecifier(node) {
	      if (node.name == null) return t(node.exportedName);
	      return seq(t(node.name), t("as"), t(node.exportedName));
	    }
	  }, {
	    key: "reduceLabeledStatement",
	    value: function reduceLabeledStatement(node, _ref42) {
	      var label = _ref42.label;
	      var body = _ref42.body;

	      return (0, _objectAssign2.default)(seq(t(label + ":"), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceLiteralBooleanExpression",
	    value: function reduceLiteralBooleanExpression(node) {
	      return t(node.value.toString());
	    }
	  }, {
	    key: "reduceLiteralNullExpression",
	    value: function reduceLiteralNullExpression(node) {
	      return t("null");
	    }
	  }, {
	    key: "reduceLiteralInfinityExpression",
	    value: function reduceLiteralInfinityExpression(node) {
	      return t("2e308");
	    }
	  }, {
	    key: "reduceLiteralNumericExpression",
	    value: function reduceLiteralNumericExpression(node) {
	      return new _coderep.NumberCodeRep(node.value);
	    }
	  }, {
	    key: "reduceLiteralRegExpExpression",
	    value: function reduceLiteralRegExpExpression(node) {
	      return t("/" + node.pattern + "/" + node.flags);
	    }
	  }, {
	    key: "reduceLiteralStringExpression",
	    value: function reduceLiteralStringExpression(node) {
	      return t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceMethod",
	    value: function reduceMethod(node, _ref43) {
	      var name = _ref43.name;
	      var params = _ref43.params;
	      var body = _ref43.body;

	      return seq(node.isGenerator ? t("*") : empty(), name, paren(params), brace(body));
	    }
	  }, {
	    key: "reduceModule",
	    value: function reduceModule(node, _ref44) {
	      var directives = _ref44.directives;
	      var items = _ref44.items;

	      if (items.length) {
	        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(items)));
	    }
	  }, {
	    key: "reduceNewExpression",
	    value: function reduceNewExpression(node, _ref45) {
	      var callee = _ref45.callee;
	      var args = _ref45.arguments;

	      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? paren(callee) : p(node.callee, (0, _coderep.getPrecedence)(node), callee);
	      return seq(t("new"), calleeRep, args.length === 0 ? empty() : paren(commaSep(args)));
	    }
	  }, {
	    key: "reduceNewTargetExpression",
	    value: function reduceNewTargetExpression() {
	      return t("new.target");
	    }
	  }, {
	    key: "reduceObjectExpression",
	    value: function reduceObjectExpression(node, _ref46) {
	      var properties = _ref46.properties;

	      var state = brace(commaSep(properties));
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceUpdateExpression",
	    value: function reduceUpdateExpression(node, _ref47) {
	      var operand = _ref47.operand;

	      if (node.isPrefix) {
	        return this.reduceUnaryExpression.apply(this, arguments);
	      } else {
	        return (0, _objectAssign2.default)(seq(p(node.operand, _coderep.Precedence.New, operand), t(node.operator)), {
	          startsWithCurly: operand.startsWithCurly,
	          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
	          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
	        });
	      }
	    }
	  }, {
	    key: "reduceUnaryExpression",
	    value: function reduceUnaryExpression(node, _ref48) {
	      var operand = _ref48.operand;

	      return seq(t(node.operator), p(node.operand, (0, _coderep.getPrecedence)(node), operand));
	    }
	  }, {
	    key: "reduceReturnStatement",
	    value: function reduceReturnStatement(node, _ref49) {
	      var expression = _ref49.expression;

	      return seq(t("return"), expression || empty(), semiOp());
	    }
	  }, {
	    key: "reduceScript",
	    value: function reduceScript(node, _ref50) {
	      var directives = _ref50.directives;
	      var statements = _ref50.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceSetter",
	    value: function reduceSetter(node, _ref51) {
	      var name = _ref51.name;
	      var param = _ref51.param;
	      var body = _ref51.body;

	      return seq(t("set"), name, paren(param), brace(body));
	    }
	  }, {
	    key: "reduceShorthandProperty",
	    value: function reduceShorthandProperty(node) {
	      return t(node.name);
	    }
	  }, {
	    key: "reduceStaticMemberExpression",
	    value: function reduceStaticMemberExpression(node, _ref52) {
	      var object = _ref52.object;
	      var property = _ref52.property;

	      var state = seq(p(node.object, (0, _coderep.getPrecedence)(node), object), t("."), t(property));
	      state.startsWithLet = object.startsWithLet;
	      state.startsWithCurly = object.startsWithCurly;
	      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
	      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
	      return state;
	    }
	  }, {
	    key: "reduceStaticPropertyName",
	    value: function reduceStaticPropertyName(node) {
	      var n;
	      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
	        return t(node.value);
	      } else if (n = parseFloat(node.value), n === n) {
	        return new _coderep.NumberCodeRep(n);
	      }
	      return t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceSuper",
	    value: function reduceSuper() {
	      return t("super");
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref53) {
	      var test = _ref53.test;
	      var consequent = _ref53.consequent;

	      return seq(t("case"), test, t(":"), seq.apply(undefined, _toConsumableArray(consequent)));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref54) {
	      var consequent = _ref54.consequent;

	      return seq(t("default:"), seq.apply(undefined, _toConsumableArray(consequent)));
	    }
	  }, {
	    key: "reduceSwitchStatement",
	    value: function reduceSwitchStatement(node, _ref55) {
	      var discriminant = _ref55.discriminant;
	      var cases = _ref55.cases;

	      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(cases))));
	    }
	  }, {
	    key: "reduceSwitchStatementWithDefault",
	    value: function reduceSwitchStatementWithDefault(node, _ref56) {
	      var discriminant = _ref56.discriminant;
	      var preDefaultCases = _ref56.preDefaultCases;
	      var defaultCase = _ref56.defaultCase;
	      var postDefaultCases = _ref56.postDefaultCases;

	      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases)))));
	    }
	  }, {
	    key: "reduceTemplateExpression",
	    value: function reduceTemplateExpression(node, _ref57) {
	      var tag = _ref57.tag;
	      var elements = _ref57.elements;

	      var state = node.tag == null ? empty() : p(node.tag, (0, _coderep.getPrecedence)(node), tag);
	      var templateData = "";
	      state = seq(state, t("`"));
	      for (var i = 0, l = node.elements.length; i < l; ++i) {
	        if (node.elements[i].type === "TemplateElement") {
	          var d = "";
	          if (i > 0) d += "}";
	          d += node.elements[i].rawValue;
	          if (i < l - 1) d += "${";
	          state = seq(state, t(d));
	        } else {
	          state = seq(state, elements[i]);
	        }
	      }
	      state = seq(state, t("`"));
	      if (node.tag != null) {
	        state.startsWithCurly = tag.startsWithCurly;
	        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
	        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
	      }
	      return state;
	    }
	  }, {
	    key: "reduceTemplateElement",
	    value: function reduceTemplateElement(node) {
	      return t(node.rawValue);
	    }
	  }, {
	    key: "reduceThisExpression",
	    value: function reduceThisExpression(node) {
	      return t("this");
	    }
	  }, {
	    key: "reduceThrowStatement",
	    value: function reduceThrowStatement(node, _ref58) {
	      var expression = _ref58.expression;

	      return seq(t("throw"), expression, semiOp());
	    }
	  }, {
	    key: "reduceTryCatchStatement",
	    value: function reduceTryCatchStatement(node, _ref59) {
	      var body = _ref59.body;
	      var catchClause = _ref59.catchClause;

	      return seq(t("try"), body, catchClause);
	    }
	  }, {
	    key: "reduceTryFinallyStatement",
	    value: function reduceTryFinallyStatement(node, _ref60) {
	      var body = _ref60.body;
	      var catchClause = _ref60.catchClause;
	      var finalizer = _ref60.finalizer;

	      return seq(t("try"), body, catchClause || empty(), t("finally"), finalizer);
	    }
	  }, {
	    key: "reduceYieldExpression",
	    value: function reduceYieldExpression(node, _ref61) {
	      var expression = _ref61.expression;

	      if (node.expression == null) return t("yield");
	      return seq(t("yield"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceYieldGeneratorExpression",
	    value: function reduceYieldGeneratorExpression(node, _ref62) {
	      var expression = _ref62.expression;

	      return seq(t("yield"), t("*"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceDirective",
	    value: function reduceDirective(node) {
	      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
	      return seq(t(delim + node.rawValue + delim), semiOp());
	    }
	  }, {
	    key: "reduceVariableDeclaration",
	    value: function reduceVariableDeclaration(node, _ref63) {
	      var declarators = _ref63.declarators;

	      return seq(t(node.kind), commaSep(declarators));
	    }
	  }, {
	    key: "reduceVariableDeclarationStatement",
	    value: function reduceVariableDeclarationStatement(node, _ref64) {
	      var declaration = _ref64.declaration;

	      return seq(declaration, semiOp());
	    }
	  }, {
	    key: "reduceVariableDeclarator",
	    value: function reduceVariableDeclarator(node, _ref65) {
	      var binding = _ref65.binding;
	      var init = _ref65.init;

	      var containsIn = init && init.containsIn && !init.containsGroup;
	      if (init) {
	        if (init.containsGroup) {
	          init = paren(init);
	        } else {
	          init = markContainsIn(init);
	        }
	      }
	      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, t("="), init), { containsIn: containsIn });
	    }
	  }, {
	    key: "reduceWhileStatement",
	    value: function reduceWhileStatement(node, _ref66) {
	      var test = _ref66.test;
	      var body = _ref66.body;

	      return (0, _objectAssign2.default)(seq(t("while"), paren(test), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceWithStatement",
	    value: function reduceWithStatement(node, _ref67) {
	      var object = _ref67.object;
	      var body = _ref67.body;

	      return (0, _objectAssign2.default)(seq(t("with"), paren(object), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }]);

	  return MinimalCodeGen;
	}();

	exports.default = MinimalCodeGen;

/***/ },
/* 55 */
/***/ function(module, exports) {

	'use strict';
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function ownEnumerableKeys(obj) {
		var keys = Object.getOwnPropertyNames(obj);

		if (Object.getOwnPropertySymbols) {
			keys = keys.concat(Object.getOwnPropertySymbols(obj));
		}

		return keys.filter(function (key) {
			return propIsEnumerable.call(obj, key);
		});
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var keys;
		var to = ToObject(target);

		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = ownEnumerableKeys(Object(from));

			for (var i = 0; i < keys.length; i++) {
				to[keys[i]] = from[keys[i]];
			}
		}

		return to;
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPrecedence = getPrecedence;
	exports.escapeStringLiteral = escapeStringLiteral;

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Precedence = {
	  Sequence: 0,
	  Yield: 1,
	  Assignment: 1,
	  Conditional: 2,
	  ArrowFunction: 2,
	  LogicalOR: 3,
	  LogicalAND: 4,
	  BitwiseOR: 5,
	  BitwiseXOR: 6,
	  BitwiseAND: 7,
	  Equality: 8,
	  Relational: 9,
	  BitwiseSHIFT: 10,
	  Additive: 11,
	  Multiplicative: 12,
	  Prefix: 13,
	  Postfix: 14,
	  New: 15,
	  Call: 16,
	  TaggedTemplate: 17,
	  Member: 18,
	  Primary: 19
	};

	exports.Precedence = Precedence;

	var BinaryPrecedence = {
	  ",": Precedence.Sequence,
	  "||": Precedence.LogicalOR,
	  "&&": Precedence.LogicalAND,
	  "|": Precedence.BitwiseOR,
	  "^": Precedence.BitwiseXOR,
	  "&": Precedence.BitwiseAND,
	  "==": Precedence.Equality,
	  "!=": Precedence.Equality,
	  "===": Precedence.Equality,
	  "!==": Precedence.Equality,
	  "<": Precedence.Relational,
	  ">": Precedence.Relational,
	  "<=": Precedence.Relational,
	  ">=": Precedence.Relational,
	  "in": Precedence.Relational,
	  "instanceof": Precedence.Relational,
	  "<<": Precedence.BitwiseSHIFT,
	  ">>": Precedence.BitwiseSHIFT,
	  ">>>": Precedence.BitwiseSHIFT,
	  "+": Precedence.Additive,
	  "-": Precedence.Additive,
	  "*": Precedence.Multiplicative,
	  "%": Precedence.Multiplicative,
	  "/": Precedence.Multiplicative
	};

	function getPrecedence(node) {
	  switch (node.type) {
	    case "ArrayExpression":
	    case "FunctionExpression":
	    case "IdentifierExpression":
	    case "LiteralBooleanExpression":
	    case "LiteralNullExpression":
	    case "LiteralNumericExpression":
	    case "LiteralInfinityExpression":
	    case "LiteralRegExpExpression":
	    case "LiteralStringExpression":
	    case "ObjectExpression":
	    case "ThisExpression":
	      return Precedence.Primary;

	    case "ArrowExpression":
	    case "AssignmentExpression":
	    case "CompoundAssignmentExpression":
	    case "YieldExpression":
	    case "YieldGeneratorExpression":
	      return Precedence.Assignment;

	    case "ConditionalExpression":
	      return Precedence.Conditional;

	    case "ComputedMemberExpression":
	    case "StaticMemberExpression":
	      switch (node.object.type) {
	        case "CallExpression":
	        case "ComputedMemberExpression":
	        case "StaticMemberExpression":
	        case "TemplateExpression":
	          return getPrecedence(node.object);
	        default:
	          return Precedence.Member;
	      }

	    case "TemplateExpression":
	      if (node.tag == null) return Precedence.Member;
	      switch (node.tag.type) {
	        case "CallExpression":
	        case "ComputedMemberExpression":
	        case "StaticMemberExpression":
	        case "TemplateExpression":
	          return getPrecedence(node.tag);
	        default:
	          return Precedence.Member;
	      }

	    case "BinaryExpression":
	      return BinaryPrecedence[node.operator];

	    case "CallExpression":
	      return Precedence.Call;
	    case "NewExpression":
	      return node.arguments.length === 0 ? Precedence.New : Precedence.Member;
	    case "UpdateExpression":
	      return node.isPrefix ? Precedence.Prefix : Precedence.Postfix;
	    case "UnaryExpression":
	      return Precedence.Prefix;
	  }
	}

	function escapeStringLiteral(stringValue) {
	  var result = "";
	  var nSingle = 0,
	      nDouble = 0;
	  for (var i = 0, l = stringValue.length; i < l; ++i) {
	    var ch = stringValue[i];
	    if (ch === "\"") {
	      ++nDouble;
	    } else if (ch === "'") {
	      ++nSingle;
	    }
	  }
	  var delim = nDouble > nSingle ? "'" : "\"";
	  result += delim;
	  for (var i = 0; i < stringValue.length; i++) {
	    var ch = stringValue.charAt(i);
	    switch (ch) {
	      case delim:
	        result += "\\" + delim;
	        break;
	      case "\b":
	        result += "\\b";
	        break;
	      case "\t":
	        result += "\\t";
	        break;
	      case "\n":
	        result += "\\n";
	        break;
	      case "\u000b":
	        result += "\\v";
	        break;
	      case "\f":
	        result += "\\f";
	        break;
	      case "\r":
	        result += "\\r";
	        break;
	      case "\\":
	        result += "\\\\";
	        break;
	      case "\u2028":
	        result += "\\u2028";
	        break;
	      case "\u2029":
	        result += "\\u2029";
	        break;
	      default:
	        result += ch;
	        break;
	    }
	  }
	  result += delim;
	  return result;
	}

	var CodeRep = exports.CodeRep = function () {
	  function CodeRep() {
	    _classCallCheck(this, CodeRep);

	    this.containsIn = false;
	    this.containsGroup = false;
	    // restricted lookaheads: {, function, class, let, let [
	    this.startsWithCurly = false;
	    this.startsWithFunctionOrClass = false;
	    this.startsWithLet = false;
	    this.startsWithLetSquareBracket = false;
	    this.endsWithMissingElse = false;
	  }

	  _createClass(CodeRep, [{
	    key: "forEach",
	    value: function forEach(f) {
	      // Call a function on every CodeRep represented by this node. Always calls f on a node and then its children, so if you're careful you can modify a node's children online.
	      f(this);
	    }
	  }]);

	  return CodeRep;
	}();

	var Empty = exports.Empty = function (_CodeRep) {
	  _inherits(Empty, _CodeRep);

	  function Empty() {
	    _classCallCheck(this, Empty);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Empty).call(this));
	  }

	  _createClass(Empty, [{
	    key: "emit",
	    value: function emit() {}
	  }]);

	  return Empty;
	}(CodeRep);

	var Token = exports.Token = function (_CodeRep2) {
	  _inherits(Token, _CodeRep2);

	  function Token(token) {
	    _classCallCheck(this, Token);

	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Token).call(this));

	    _this2.token = token;
	    return _this2;
	  }

	  _createClass(Token, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put(this.token);
	    }
	  }]);

	  return Token;
	}(CodeRep);

	var NumberCodeRep = exports.NumberCodeRep = function (_CodeRep3) {
	  _inherits(NumberCodeRep, _CodeRep3);

	  function NumberCodeRep(number) {
	    _classCallCheck(this, NumberCodeRep);

	    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(NumberCodeRep).call(this));

	    _this3.number = number;
	    return _this3;
	  }

	  _createClass(NumberCodeRep, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.putNumber(this.number);
	    }
	  }]);

	  return NumberCodeRep;
	}(CodeRep);

	var Paren = exports.Paren = function (_CodeRep4) {
	  _inherits(Paren, _CodeRep4);

	  function Paren(expr) {
	    _classCallCheck(this, Paren);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Paren).call(this));

	    _this4.expr = expr;
	    return _this4;
	  }

	  _createClass(Paren, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("(");
	      this.expr.emit(ts, false);
	      ts.put(")");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Paren;
	}(CodeRep);

	var Bracket = exports.Bracket = function (_CodeRep5) {
	  _inherits(Bracket, _CodeRep5);

	  function Bracket(expr) {
	    _classCallCheck(this, Bracket);

	    var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(Bracket).call(this));

	    _this5.expr = expr;
	    return _this5;
	  }

	  _createClass(Bracket, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("[");
	      this.expr.emit(ts, false);
	      ts.put("]");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Bracket;
	}(CodeRep);

	var Brace = exports.Brace = function (_CodeRep6) {
	  _inherits(Brace, _CodeRep6);

	  function Brace(expr) {
	    _classCallCheck(this, Brace);

	    var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(Brace).call(this));

	    _this6.expr = expr;
	    return _this6;
	  }

	  _createClass(Brace, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("{");
	      this.expr.emit(ts, false);
	      ts.put("}");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Brace;
	}(CodeRep);

	var NoIn = exports.NoIn = function (_CodeRep7) {
	  _inherits(NoIn, _CodeRep7);

	  function NoIn(expr) {
	    _classCallCheck(this, NoIn);

	    var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(NoIn).call(this));

	    _this7.expr = expr;
	    return _this7;
	  }

	  _createClass(NoIn, [{
	    key: "emit",
	    value: function emit(ts) {
	      this.expr.emit(ts, true);
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return NoIn;
	}(CodeRep);

	var ContainsIn = exports.ContainsIn = function (_CodeRep8) {
	  _inherits(ContainsIn, _CodeRep8);

	  function ContainsIn(expr) {
	    _classCallCheck(this, ContainsIn);

	    var _this8 = _possibleConstructorReturn(this, Object.getPrototypeOf(ContainsIn).call(this));

	    _this8.expr = expr;
	    return _this8;
	  }

	  _createClass(ContainsIn, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      if (noIn) {
	        ts.put("(");
	        this.expr.emit(ts, false);
	        ts.put(")");
	      } else {
	        this.expr.emit(ts, false);
	      }
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return ContainsIn;
	}(CodeRep);

	var Seq = exports.Seq = function (_CodeRep9) {
	  _inherits(Seq, _CodeRep9);

	  function Seq(children) {
	    _classCallCheck(this, Seq);

	    var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(Seq).call(this));

	    _this9.children = children;
	    return _this9;
	  }

	  _createClass(Seq, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      this.children.forEach(function (cr) {
	        return cr.emit(ts, noIn);
	      });
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.children.forEach(function (x) {
	        return x.forEach(f);
	      });
	    }
	  }]);

	  return Seq;
	}(CodeRep);

	var Semi = exports.Semi = function (_Token) {
	  _inherits(Semi, _Token);

	  function Semi() {
	    _classCallCheck(this, Semi);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Semi).call(this, ";"));
	  }

	  return Semi;
	}(Token);

	var CommaSep = exports.CommaSep = function (_CodeRep10) {
	  _inherits(CommaSep, _CodeRep10);

	  function CommaSep(children) {
	    _classCallCheck(this, CommaSep);

	    var _this11 = _possibleConstructorReturn(this, Object.getPrototypeOf(CommaSep).call(this));

	    _this11.children = children;
	    return _this11;
	  }

	  _createClass(CommaSep, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      var first = true;
	      this.children.forEach(function (cr) {
	        if (first) {
	          first = false;
	        } else {
	          ts.put(",");
	        }
	        cr.emit(ts, noIn);
	      });
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.children.forEach(function (x) {
	        return x.forEach(f);
	      });
	    }
	  }]);

	  return CommaSep;
	}(CodeRep);

	var SemiOp = exports.SemiOp = function (_CodeRep11) {
	  _inherits(SemiOp, _CodeRep11);

	  function SemiOp() {
	    _classCallCheck(this, SemiOp);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(SemiOp).call(this));
	  }

	  _createClass(SemiOp, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.putOptionalSemi();
	    }
	  }]);

	  return SemiOp;
	}(CodeRep);

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.Sep = undefined;

	var _objectAssign = __webpack_require__(55);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _esutils = __webpack_require__(4);

	var _coderep = __webpack_require__(56);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function empty() {
	  return new _coderep.Empty();
	}

	function noIn(rep) {
	  return new _coderep.NoIn(rep);
	}

	function markContainsIn(state) {
	  return state.containsIn ? new _coderep.ContainsIn(state) : state;
	}

	function seq() {
	  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
	    reps[_key] = arguments[_key];
	  }

	  return new _coderep.Seq(reps);
	}

	function isEmpty(codeRep) {
	  return codeRep instanceof _coderep.Empty || codeRep instanceof Linebreak || codeRep instanceof _coderep.Seq && codeRep.children.every(isEmpty);
	}

	var Sep = {};
	var separatorNames = ["ARRAY_EMPTY", "ARRAY_BEFORE_COMMA", "ARRAY_AFTER_COMMA", "SPREAD", "BEFORE_DEFAULT_EQUALS", "AFTER_DEFAULT_EQUALS", "REST", "OBJECT_BEFORE_COMMA", "OBJECT_AFTER_COMMA", "BEFORE_PROP", "AFTER_PROP", "BEFORE_JUMP_LABEL", "ARGS_BEFORE_COMMA", "ARGS_AFTER_COMMA", "CALL", "BEFORE_CATCH_BINDING", "AFTER_CATCH_BINDING", "BEFORE_CLASS_NAME", "BEFORE_EXTENDS", "AFTER_EXTENDS", "BEFORE_CLASS_DECLARATION_ELEMENTS", "BEFORE_CLASS_EXPRESSION_ELEMENTS", "AFTER_STATIC", "BEFORE_CLASS_ELEMENT", "AFTER_CLASS_ELEMENT", "BEFORE_TERNARY_QUESTION", "AFTER_TERNARY_QUESTION", "BEFORE_TERNARY_COLON", "AFTER_TERNARY_COLON", "COMPUTED_MEMBER_EXPRESSION", "AFTER_DO", "BEFORE_DOWHILE_WHILE", "AFTER_DOWHILE_WHILE", "AFTER_FORIN_FOR", "BEFORE_FORIN_IN", "AFTER_FORIN_FOR", "BEFORE_FORIN_BODY", "AFTER_FOROF_FOR", "BEFORE_FOROF_OF", "AFTER_FOROF_FOR", "BEFORE_FOROF_BODY", "AFTER_FOR_FOR", "BEFORE_FOR_INIT", "AFTER_FOR_INIT", "EMPTY_FOR_INIT", "BEFORE_FOR_TEST", "AFTER_FOR_TEST", "EMPTY_FOR_TEST", "BEFORE_FOR_UPDATE", "AFTER_FOR_UPDATE", "EMPTY_FOR_UPDATE", "BEFORE_FOR_BODY", "BEFORE_GENERATOR_STAR", "AFTER_GENERATOR_STAR", "BEFORE_FUNCTION_PARAMS", "BEFORE_FUNCTION_DECLARATION_BODY", "BEFORE_FUNCTION_EXPRESSION_BODY", "AFTER_FUNCTION_DIRECTIVES", "BEFORE_ARROW", "AFTER_ARROW", "AFTER_GET", "BEFORE_GET_PARAMS", "BEFORE_GET_BODY", "AFTER_IF", "AFTER_IF_TEST", "BEFORE_ELSE", "AFTER_ELSE", "PARAMETER_BEFORE_COMMA", "PARAMETER_AFTER_COMMA", "NAMED_IMPORT_BEFORE_COMMA", "NAMED_IMPORT_AFTER_COMMA", "IMPORT_BEFORE_COMMA", "IMPORT_AFTER_COMMA", "BEFORE_IMPORT_BINDINGS", "BEFORE_IMPORT_MODULE", "AFTER_IMPORT_BINDINGS", "AFTER_FROM", "BEFORE_IMPORT_NAMESPACE", "BEFORE_IMPORT_STAR", "AFTER_IMPORT_STAR", "AFTER_IMPORT_AS", "AFTER_NAMESPACE_BINDING", "BEFORE_IMPORT_AS", "AFTER_IMPORT_AS", "EXPORTS_BEFORE_COMMA", "EXPORTS_AFTER_COMMA", "BEFORE_EXPORT_STAR", "AFTER_EXPORT_STAR", "BEFORE_EXPORT_BINDINGS", "AFTER_EXPORT_BINDINGS", "AFTER_EXPORT", "EXPORT_DEFAULT", "AFTER_EXPORT_DEFAULT", "BEFORE_EXPORT_AS", "AFTER_EXPORT_AS", "BEFORE_LABEL_COLON", "AFTER_LABEL_COLON", "AFTER_METHOD_GENERATOR_STAR", "AFTER_METHOD_NAME", "BEFORE_METHOD_BODY", "AFTER_MODULE_DIRECTIVES", "AFTER_NEW", "BEFORE_NEW_ARGS", "EMPTY_NEW_CALL", "NEW_TARGET_BEFORE_DOT", "NEW_TARGET_AFTER_DOT", "RETURN", "AFTER_SET", "BEFORE_SET_PARAMS", "BEFORE_SET_BODY", "AFTER_SCRIPT_DIRECTIVES", "BEFORE_STATIC_MEMBER_DOT", "AFTER_STATIC_MEMBER_DOT", "BEFORE_CASE_TEST", "AFTER_CASE_TEST", "BEFORE_CASE_BODY", "AFTER_CASE_BODY", "DEFAULT", "AFTER_DEFAULT_BODY", "BEFORE_SWITCH_DISCRIM", "BEFORE_SWITCH_BODY", "TEMPLATE_TAG", "BEFORE_TEMPLATE_EXPRESSION", "AFTER_TEMPLATE_EXPRESSION", "THROW", "AFTER_TRY", "BEFORE_CATCH", "BEFORE_FINALLY", "AFTER_FINALLY", "VARIABLE_DECLARATION", "YIELD", "BEFORE_YIELD_STAR", "AFTER_YIELD_STAR", "DECLARATORS_BEFORE_COMMA", "DECLARATORS_AFTER_COMMA", "BEFORE_INIT_EQUALS", "AFTER_INIT_EQUALS", "AFTER_WHILE", "BEFORE_WHILE_BODY", "AFTER_WITH", "BEFORE_WITH_BODY", "PAREN_AVOIDING_DIRECTIVE_BEFORE", "PAREN_AVOIDING_DIRECTIVE_AFTER", "PRECEDENCE_BEFORE", "PRECEDENCE_AFTER", "EXPRESSION_PAREN_BEFORE", "EXPRESSION_PAREN_AFTER", "CALL_PAREN_BEFORE", "CALL_PAREN_AFTER", "CALL_PAREN_EMPTY", "CATCH_PAREN_BEFORE", "CATCH_PAREN_AFTER", "DO_WHILE_TEST_PAREN_BEFORE", "DO_WHILE_TEST_PAREN_AFTER", "EXPRESSION_STATEMENT_PAREN_BEFORE", "EXPRESSION_STATEMENT_PAREN_AFTER", "FOR_IN_LET_PAREN_BEFORE", "FOR_IN_LET_PAREN_AFTER", "FOR_IN_PAREN_BEFORE", "FOR_IN_PAREN_AFTER", "FOR_OF_LET_PAREN_BEFORE", "FOR_OF_LET_PAREN_AFTER", "FOR_OF_PAREN_BEFORE", "FOR_OF_PAREN_AFTER", "PARAMETERS_PAREN_BEFORE", "PARAMETERS_PAREN_AFTER", "PARAMETERS_PAREN_EMPTY", "ARROW_PARAMETERS_PAREN_BEFORE", "ARROW_PARAMETERS_PAREN_AFTER", "ARROW_PARAMETERS_PAREN_EMPTY", "ARROW_BODY_PAREN_BEFORE", "ARROW_BODY_PAREN_AFTER", "GETTER_PARAMS", "IF_PAREN_BEFORE", "IF_PAREN_AFTER", "EXPORT_PAREN_BEFORE", "EXPORT_PAREN_AFTER", "NEW_CALLEE_PAREN_BEFORE", "NEW_CALLEE_PAREN_AFTER", "NEW_PAREN_BEFORE", "NEW_PAREN_AFTER", "NEW_PAREN_EMPTY", "SETTER_PARAM_BEFORE", "SETTER_PARAM_AFTER", "SWITCH_DISCRIM_PAREN_BEFORE", "SWITCH_DISCRIM_PAREN_AFTER", "WHILE_TEST_PAREN_BEFORE", "WHILE_TEST_PAREN_AFTER", "WITH_PAREN_BEFORE", "WITH_PAREN_AFTER", "OBJECT_BRACE_INITIAL", "OBJECT_BRACE_FINAL", "OBJECT_EMPTY", "BLOCK_BRACE_INITIAL", "BLOCK_BRACE_FINAL", "BLOCK_EMPTY", "CLASS_BRACE_INITIAL", "CLASS_BRACE_FINAL", "CLASS_EMPTY", "CLASS_EXPRESSION_BRACE_INITIAL", "CLASS_EXPRESSION_BRACE_FINAL", "CLASS_EXPRESSION_BRACE_EMPTY", "FUNCTION_BRACE_INITIAL", "FUNCTION_BRACE_FINAL", "FUNCTION_EMPTY", "FUNCTION_EXPRESSION_BRACE_INITIAL", "FUNCTION_EXPRESSION_BRACE_FINAL", "FUNCTION_EXPRESSION_EMPTY", "ARROW_BRACE_INITIAL", "ARROW_BRACE_FINAL", "ARROW_BRACE_EMPTY", "GET_BRACE_INTIAL", "GET_BRACE_FINAL", "GET_BRACE_EMPTY", "MISSING_ELSE_INTIIAL", "MISSING_ELSE_FINAL", "MISSING_ELSE_EMPTY", "IMPORT_BRACE_INTIAL", "IMPORT_BRACE_FINAL", "IMPORT_BRACE_EMPTY", "EXPORT_BRACE_INITIAL", "EXPORT_BRACE_FINAL", "EXPORT_BRACE_EMPTY", "METHOD_BRACE_INTIAL", "METHOD_BRACE_FINAL", "METHOD_BRACE_EMPTY", "SET_BRACE_INTIIAL", "SET_BRACE_FINAL", "SET_BRACE_EMPTY", "SWITCH_BRACE_INTIAL", "SWITCH_BRACE_FINAL", "SWITCH_BRACE_EMPTY", "ARRAY_INITIAL", "ARRAY_FINAL", "COMPUTED_MEMBER_BRACKET_INTIAL", "COMPUTED_MEMBER_BRACKET_FINAL", "COMPUTED_PROPERTY_BRACKET_INTIAL", "COMPUTED_PROPERTY_BRACKET_FINAL"];
	for (var i = 0; i < separatorNames.length; ++i) {
	  Sep[separatorNames[i]] = { type: separatorNames[i] };
	}

	Sep.BEFORE_ASSIGN_OP = function (op) {
	  return {
	    type: "BEFORE_ASSIGN_OP",
	    op: op
	  };
	};

	Sep.AFTER_ASSIGN_OP = function (op) {
	  return {
	    type: "AFTER_ASSIGN_OP",
	    op: op
	  };
	};

	Sep.BEFORE_BINOP = function (op) {
	  return {
	    type: "BEFORE_BINOP",
	    op: op
	  };
	};

	Sep.AFTER_BINOP = function (op) {
	  return {
	    type: "AFTER_BINOP",
	    op: op
	  };
	};

	Sep.BEFORE_POSTFIX = function (op) {
	  return {
	    type: "BEFORE_POSTFIX",
	    op: op
	  };
	};

	Sep.UNARY = function (op) {
	  return {
	    type: "UNARY",
	    op: op
	  };
	};

	Sep.AFTER_STATEMENT = function (node) {
	  return {
	    type: "AFTER_STATEMENT",
	    node: node
	  };
	};

	Sep.BEFORE_FUNCTION_NAME = function (node) {
	  return {
	    type: "BEFORE_FUNCTION_NAME",
	    node: node
	  };
	};
	exports.Sep = Sep;

	var ExtensibleCodeGen = exports.ExtensibleCodeGen = function () {
	  function ExtensibleCodeGen() {
	    _classCallCheck(this, ExtensibleCodeGen);
	  }

	  _createClass(ExtensibleCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp());
	      }
	      return original;
	    }
	  }, {
	    key: "t",
	    value: function t(token) {
	      return new _coderep.Token(token);
	    }
	  }, {
	    key: "p",
	    value: function p(node, precedence, a) {
	      return (0, _coderep.getPrecedence)(node) < precedence ? this.paren(a, Sep.PRECEDENCE_BEFORE, Sep.PRECEDENCE_AFTER) : a;
	    }
	  }, {
	    key: "getAssignmentExpr",
	    value: function getAssignmentExpr(state) {
	      return state ? state.containsGroup ? this.paren(state, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER) : state : empty();
	    }
	  }, {
	    key: "paren",
	    value: function paren(rep, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Paren(this.sep(empty));
	      }
	      return new _coderep.Paren(seq(first ? this.sep(first) : new _coderep.Empty(), rep, last ? this.sep(last) : new _coderep.Empty()));
	    }
	  }, {
	    key: "brace",
	    value: function brace(rep, node, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Brace(this.sep(empty));
	      }
	      return new _coderep.Brace(seq(this.sep(first), rep, this.sep(last)));
	    }
	  }, {
	    key: "bracket",
	    value: function bracket(rep, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Bracket(this.sep(empty));
	      }
	      return new _coderep.Bracket(seq(this.sep(first), rep, this.sep(last)));
	    }
	  }, {
	    key: "commaSep",
	    value: function commaSep(pieces, before, after) {
	      var _this = this;

	      var first = true;
	      pieces = pieces.map(function (p) {
	        if (first) {
	          first = false;
	          return p;
	        } else {
	          return seq(_this.sep(before), _this.t(","), _this.sep(after), p);
	        }
	      });
	      return seq.apply(undefined, _toConsumableArray(pieces));
	    }
	  }, {
	    key: "semiOp",
	    value: function semiOp() {
	      return new _coderep.SemiOp();
	    }
	  }, {
	    key: "sep",
	    value: function sep(kind) {
	      return new _coderep.Empty();
	    }
	  }, {
	    key: "reduceArrayExpression",
	    value: function reduceArrayExpression(node, _ref) {
	      var _this2 = this;

	      var elements = _ref.elements;

	      if (elements.length === 0) {
	        return this.bracket(empty(), null, null, Sep.ARRAY_EMPTY);
	      }

	      var content = this.commaSep(elements.map(function (e) {
	        return _this2.getAssignmentExpr(e);
	      }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
	      if (elements.length > 0 && elements[elements.length - 1] == null) {
	        content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
	      }
	      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL);
	    }
	  }, {
	    key: "reduceSpreadElement",
	    value: function reduceSpreadElement(node, _ref2) {
	      var expression = _ref2.expression;

	      return seq(this.t("..."), this.sep(Sep.SPREAD), this.p(node.expression, _coderep.Precedence.Assignment, expression));
	    }
	  }, {
	    key: "reduceAssignmentExpression",
	    value: function reduceAssignmentExpression(node, _ref3) {
	      var binding = _ref3.binding;
	      var expression = _ref3.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP("=")), this.t("="), this.sep(Sep.AFTER_ASSIGN_OP("=")), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceCompoundAssignmentExpression",
	    value: function reduceCompoundAssignmentExpression(node, _ref4) {
	      var binding = _ref4.binding;
	      var expression = _ref4.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_ASSIGN_OP(node.operator)), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceBinaryExpression",
	    value: function reduceBinaryExpression(node, _ref5) {
	      var left = _ref5.left;
	      var right = _ref5.right;

	      var leftCode = left;
	      var startsWithCurly = left.startsWithCurly;
	      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
	      var leftContainsIn = left.containsIn;
	      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
	        leftCode = this.paren(leftCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        startsWithCurly = false;
	        startsWithLetSquareBracket = false;
	        startsWithFunctionOrClass = false;
	        leftContainsIn = false;
	      }
	      var rightCode = right;
	      var rightContainsIn = right.containsIn;
	      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        rightContainsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_BINOP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_BINOP(node.operator)), rightCode), {
	        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
	        containsGroup: node.operator == ",",
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceBindingWithDefault",
	    value: function reduceBindingWithDefault(node, _ref6) {
	      var binding = _ref6.binding;
	      var init = _ref6.init;

	      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
	    }
	  }, {
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node) {
	      var a = this.t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceArrayBinding",
	    value: function reduceArrayBinding(node, _ref7) {
	      var _this3 = this;

	      var elements = _ref7.elements;
	      var restElement = _ref7.restElement;

	      var content = undefined;
	      if (elements.length === 0) {
	        content = restElement == null ? empty() : seq(this.t("..."), this.sep(Sep.REST), restElement);
	      } else {
	        elements = elements.concat(restElement == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), restElement)]);
	        content = this.commaSep(elements.map(function (e) {
	          return _this3.getAssignmentExpr(e);
	        }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
	        if (elements.length > 0 && elements[elements.length - 1] == null) {
	          content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
	        }
	      }
	      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL, Sep.ARRAY_EMPTY);
	    }
	  }, {
	    key: "reduceObjectBinding",
	    value: function reduceObjectBinding(node, _ref8) {
	      var properties = _ref8.properties;

	      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceBindingPropertyIdentifier",
	    value: function reduceBindingPropertyIdentifier(node, _ref9) {
	      var binding = _ref9.binding;
	      var init = _ref9.init;

	      if (node.init == null) return binding;
	      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
	    }
	  }, {
	    key: "reduceBindingPropertyProperty",
	    value: function reduceBindingPropertyProperty(node, _ref10) {
	      var name = _ref10.name;
	      var binding = _ref10.binding;

	      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), binding);
	    }
	  }, {
	    key: "reduceBlock",
	    value: function reduceBlock(node, _ref11) {
	      var statements = _ref11.statements;

	      return this.brace(seq.apply(undefined, _toConsumableArray(statements)), node, Sep.BLOCK_BRACE_INITIAL, Sep.BLOCK_BRACE_FINAL, Sep.BLOCK_EMPTY);
	    }
	  }, {
	    key: "reduceBlockStatement",
	    value: function reduceBlockStatement(node, _ref12) {
	      var block = _ref12.block;

	      return seq(block, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceBreakStatement",
	    value: function reduceBreakStatement(node, _ref13) {
	      var label = _ref13.label;

	      return seq(this.t("break"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceCallExpression",
	    value: function reduceCallExpression(node, _ref14) {
	      var callee = _ref14.callee;
	      var args = _ref14.arguments;

	      return (0, _objectAssign2.default)(seq(this.p(node.callee, (0, _coderep.getPrecedence)(node), callee), this.sep(Sep.CALL), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.CALL_PAREN_BEFORE, Sep.CALL_PAREN_AFTER, Sep.CALL_PAREN_EMPTY)), {
	        startsWithCurly: callee.startsWithCurly,
	        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
	        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceCatchClause",
	    value: function reduceCatchClause(node, _ref15) {
	      var binding = _ref15.binding;
	      var body = _ref15.body;

	      return seq(this.t("catch"), this.sep(Sep.BEFORE_CATCH_BINDING), this.paren(binding, Sep.CATCH_PAREN_BEFORE, Sep.CATCH_PAREN_AFTER), this.sep(Sep.AFTER_CATCH_BINDING), body);
	    }
	  }, {
	    key: "reduceClassDeclaration",
	    value: function reduceClassDeclaration(node, _ref16) {
	      var name = _ref16.name;
	      var _super = _ref16.super;
	      var elements = _ref16.elements;

	      var state = seq(this.t("class"), this.sep(Sep.BEFORE_CLASS_NAME), name);
	      if (_super != null) {
	        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
	      }
	      state = seq(state, this.sep(Sep.BEFORE_CLASS_DECLARATION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_BRACE_INITIAL, Sep.CLASS_BRACE_FINAL, Sep.CLASS_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	      return state;
	    }
	  }, {
	    key: "reduceClassExpression",
	    value: function reduceClassExpression(node, _ref17) {
	      var name = _ref17.name;
	      var _super = _ref17.super;
	      var elements = _ref17.elements;

	      var state = this.t("class");
	      if (name != null) {
	        state = seq(state, this.sep(Sep.BEFORE_CLASS_NAME), name);
	      }
	      if (_super != null) {
	        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
	      }
	      state = seq(state, this.sep(Sep.BEFORE_CLASS_EXPRESSION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_EXPRESSION_BRACE_INITIAL, Sep.CLASS_EXPRESSION_BRACE_FINAL, Sep.CLASS_EXPRESSION_BRACE_EMPTY));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceClassElement",
	    value: function reduceClassElement(node, _ref18) {
	      var method = _ref18.method;

	      method = seq(this.sep(Sep.BEFORE_CLASS_ELEMENT), method, this.sep(Sep.AFTER_CLASS_ELEMENT));
	      if (!node.isStatic) return method;
	      return seq(this.t("static"), this.sep(Sep.AFTER_STATIC), method);
	    }
	  }, {
	    key: "reduceComputedMemberExpression",
	    value: function reduceComputedMemberExpression(node, _ref19) {
	      var object = _ref19.object;
	      var expression = _ref19.expression;

	      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
	      return (0, _objectAssign2.default)(seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.COMPUTED_MEMBER_EXPRESSION), this.bracket(expression, Sep.COMPUTED_MEMBER_BRACKET_INTIAL, Sep.COMPUTED_MEMBER_BRACKET_FINAL)), {
	        startsWithLet: object.startsWithLet,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithCurly: object.startsWithCurly,
	        startsWithFunctionOrClass: object.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceComputedPropertyName",
	    value: function reduceComputedPropertyName(node, _ref20) {
	      var expression = _ref20.expression;

	      return this.bracket(expression, Sep.COMPUTED_PROPERTY_BRACKET_INTIAL, Sep.COMPUTED_PROPERTY_BRACKET_FINAL);
	    }
	  }, {
	    key: "reduceConditionalExpression",
	    value: function reduceConditionalExpression(node, _ref21) {
	      var test = _ref21.test;
	      var consequent = _ref21.consequent;
	      var alternate = _ref21.alternate;

	      var containsIn = test.containsIn || alternate.containsIn;
	      var startsWithCurly = test.startsWithCurly;
	      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
	      return (0, _objectAssign2.default)(seq(this.p(node.test, _coderep.Precedence.LogicalOR, test), this.sep(Sep.BEFORE_TERNARY_QUESTION), this.t("?"), this.sep(Sep.AFTER_TERNARY_QUESTION), this.p(node.consequent, _coderep.Precedence.Assignment, consequent), this.sep(Sep.BEFORE_TERNARY_COLON), this.t(":"), this.sep(Sep.AFTER_TERNARY_COLON), this.p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
	        containsIn: containsIn,
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceContinueStatement",
	    value: function reduceContinueStatement(node, _ref22) {
	      var label = _ref22.label;

	      return seq(this.t("continue"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceDataProperty",
	    value: function reduceDataProperty(node, _ref23) {
	      var name = _ref23.name;
	      var expression = _ref23.expression;

	      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), this.getAssignmentExpr(expression));
	    }
	  }, {
	    key: "reduceDebuggerStatement",
	    value: function reduceDebuggerStatement(node) {
	      return seq(this.t("debugger"), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref24) {
	      var body = _ref24.body;
	      var test = _ref24.test;

	      return seq(this.t("do"), this.sep(Sep.AFTER_DO), body, this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceEmptyStatement",
	    value: function reduceEmptyStatement(node) {
	      return seq(this.t(";"), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceExpressionStatement",
	    value: function reduceExpressionStatement(node, _ref25) {
	      var expression = _ref25.expression;

	      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
	      return seq(needsParens ? this.paren(expression, Sep.EXPRESSION_STATEMENT_PAREN_BEFORE, Sep.EXPRESSION_STATEMENT_PAREN_AFTER) : expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceForInStatement",
	    value: function reduceForInStatement(node, _ref26) {
	      var left = _ref26.left;
	      var right = _ref26.right;
	      var body = _ref26.body;

	      var leftP = left;
	      switch (node.left.type) {
	        case "VariableDeclaration":
	          leftP = noIn(markContainsIn(left));
	          break;
	        case "BindingIdentifier":
	          if (node.left.name === "let") {
	            leftP = this.paren(left, Sep.FOR_IN_LET_PAREN_BEFORE, Sep.FOR_IN_LET_PAREN_BEFORE);
	          }
	          break;
	      }
	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FORIN_FOR), this.paren(seq(leftP, this.sep(Sep.BEFORE_FORIN_IN), this.t("in"), this.sep(Sep.AFTER_FORIN_FOR), right), Sep.FOR_IN_PAREN_BEFORE, Sep.FOR_IN_PAREN_AFTER), this.sep(Sep.BEFORE_FORIN_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForOfStatement",
	    value: function reduceForOfStatement(node, _ref27) {
	      var left = _ref27.left;
	      var right = _ref27.right;
	      var body = _ref27.body;

	      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOROF_FOR), this.paren(seq(left.startsWithLet ? this.paren(left, Sep.FOR_OF_LET_PAREN_BEFORE, Sep.FOR_OF_LET_PAREN_AFTER) : left, this.sep(Sep.BEFORE_FOROF_OF), this.t("of"), this.sep(Sep.AFTER_FOROF_FOR), right), Sep.FOR_OF_PAREN_BEFORE, Sep.FOR_OF_PAREN_AFTER), this.sep(Sep.BEFORE_FOROF_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForStatement",
	    value: function reduceForStatement(node, _ref28) {
	      var init = _ref28.init;
	      var test = _ref28.test;
	      var update = _ref28.update;
	      var body = _ref28.body;

	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOR_FOR), this.paren(seq(init ? seq(this.sep(Sep.BEFORE_FOR_INIT), noIn(markContainsIn(init)), this.sep(Sep.AFTER_FOR_INIT)) : this.sep(Sep.EMPTY_FOR_INIT), this.t(";"), test ? seq(this.sep(Sep.BEFORE_FOR_TEST), test, this.sep(Sep.AFTER_FOR_TEST)) : this.sep(Sep.EMPTY_FOR_TEST), this.t(";"), update ? seq(this.sep(Sep.BEFORE_FOR_UPDATE), update, this.sep(Sep.AFTER_FOR_UPDATE)) : this.sep(Sep.EMPTY_FOR_UPDATE))), this.sep(Sep.BEFORE_FOR_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), {
	        endsWithMissingElse: body.endsWithMissingElse
	      });
	    }
	  }, {
	    key: "reduceFunctionBody",
	    value: function reduceFunctionBody(node, _ref29) {
	      var directives = _ref29.directives;
	      var statements = _ref29.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_FUNCTION_DIRECTIVES) : empty()], _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceFunctionDeclaration",
	    value: function reduceFunctionDeclaration(node, _ref30) {
	      var name = _ref30.name;
	      var params = _ref30.params;
	      var body = _ref30.body;

	      return seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), node.name.name === "*default*" ? empty() : name, this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_DECLARATION_BODY), this.brace(body, node, Sep.FUNCTION_BRACE_INITIAL, Sep.FUNCTION_BRACE_FINAL, Sep.FUNCTION_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceFunctionExpression",
	    value: function reduceFunctionExpression(node, _ref31) {
	      var name = _ref31.name;
	      var params = _ref31.params;
	      var body = _ref31.body;

	      var state = seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), name ? name : empty(), this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_EXPRESSION_BODY), this.brace(body, node, Sep.FUNCTION_EXPRESSION_BRACE_INITIAL, Sep.FUNCTION_EXPRESSION_BRACE_FINAL, Sep.FUNCTION_EXPRESSION_EMPTY));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceFormalParameters",
	    value: function reduceFormalParameters(node, _ref32) {
	      var items = _ref32.items;
	      var rest = _ref32.rest;

	      return this.commaSep(items.concat(rest == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), rest)]), Sep.PARAMETER_BEFORE_COMMA, Sep.PARAMETER_AFTER_COMMA);
	    }
	  }, {
	    key: "reduceArrowExpression",
	    value: function reduceArrowExpression(node, _ref33) {
	      var params = _ref33.params;
	      var body = _ref33.body;

	      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
	        params = this.paren(params, Sep.ARROW_PARAMETERS_PAREN_BEFORE, Sep.ARROW_PARAMETERS_PAREN_AFTER, Sep.ARROW_PARAMETERS_PAREN_EMPTY);
	      }
	      if (node.body.type === "FunctionBody") {
	        body = this.brace(body, node, Sep.ARROW_BRACE_INITIAL, Sep.ARROW_BRACE_FINAL, Sep.ARROW_BRACE_EMPTY);
	      } else if (body.startsWithCurly) {
	        body = this.paren(body, Sep.ARROW_BODY_PAREN_BEFORE, Sep.ARROW_BODY_PAREN_AFTER);
	      }
	      return seq(params, this.sep(Sep.BEFORE_ARROW), this.t("=>"), this.sep(Sep.AFTER_ARROW), this.p(node.body, _coderep.Precedence.Assignment, body));
	    }
	  }, {
	    key: "reduceGetter",
	    value: function reduceGetter(node, _ref34) {
	      var name = _ref34.name;
	      var body = _ref34.body;

	      return seq(this.t("get"), this.sep(Sep.AFTER_GET), name, this.sep(Sep.BEFORE_GET_PARAMS), this.paren(empty(), null, null, Sep.GETTER_PARAMS), this.sep(Sep.BEFORE_GET_BODY), this.brace(body, node, Sep.GET_BRACE_INTIAL, Sep.GET_BRACE_FINAL, Sep.GET_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node) {
	      var a = this.t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref35) {
	      var test = _ref35.test;
	      var consequent = _ref35.consequent;
	      var alternate = _ref35.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = this.brace(consequent, node, Sep.MISSING_ELSE_INTIIAL, Sep.MISSING_ELSE_FINAL, Sep.MISSING_ELSE_EMPTY);
	      }
	      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), consequent, alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), alternate) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceImport",
	    value: function reduceImport(node, _ref36) {
	      var defaultBinding = _ref36.defaultBinding;
	      var namedImports = _ref36.namedImports;

	      var bindings = [];
	      if (defaultBinding != null) {
	        bindings.push(defaultBinding);
	      }
	      if (namedImports.length > 0) {
	        bindings.push(this.brace(this.commaSep(namedImports, Sep.NAMED_IMPORT_BEFORE_COMMA, Sep.NAMED_IMPORT_AFTER_COMMA), node, Sep.IMPORT_BRACE_INTIAL, Sep.IMPORT_BRACE_FINAL, Sep.IMPORT_BRACE_EMPTY));
	      }
	      if (bindings.length === 0) {
	        return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_MODULE), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_BINDINGS), this.commaSep(bindings, Sep.IMPORT_BEFORE_COMMA, Sep.IMPORT_AFTER_COMMA), this.sep(Sep.AFTER_IMPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceImportNamespace",
	    value: function reduceImportNamespace(node, _ref37) {
	      var defaultBinding = _ref37.defaultBinding;
	      var namespaceBinding = _ref37.namespaceBinding;

	      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_NAMESPACE), defaultBinding == null ? empty() : seq(defaultBinding, this.sep(Sep.IMPORT_BEFORE_COMMA), this.t(","), this.sep(Sep.IMPORT_AFTER_COMMA)), this.sep(Sep.BEFORE_IMPORT_STAR), this.t("*"), this.sep(Sep.AFTER_IMPORT_STAR), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), namespaceBinding, this.sep(Sep.AFTER_NAMESPACE_BINDING), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceImportSpecifier",
	    value: function reduceImportSpecifier(node, _ref38) {
	      var binding = _ref38.binding;

	      if (node.name == null) return binding;
	      return seq(this.t(node.name), this.sep(Sep.BEFORE_IMPORT_AS), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), binding);
	    }
	  }, {
	    key: "reduceExportAllFrom",
	    value: function reduceExportAllFrom(node) {
	      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_STAR), this.t("*"), this.sep(Sep.AFTER_EXPORT_STAR), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceExportFrom",
	    value: function reduceExportFrom(node, _ref39) {
	      var namedExports = _ref39.namedExports;

	      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_BINDINGS), this.brace(this.commaSep(namedExports, Sep.EXPORTS_BEFORE_COMMA, Sep.EXPORTS_AFTER_COMMA), node, Sep.EXPORT_BRACE_INITIAL, Sep.EXPORT_BRACE_FINAL, Sep.EXPORT_BRACE_EMPTY), node.moduleSpecifier == null ? empty() : seq(this.sep(Sep.AFTER_EXPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node))));
	    }
	  }, {
	    key: "reduceExport",
	    value: function reduceExport(node, _ref40) {
	      var declaration = _ref40.declaration;

	      switch (node.declaration.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          declaration = seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("export"), this.sep(Sep.AFTER_EXPORT), declaration);
	    }
	  }, {
	    key: "reduceExportDefault",
	    value: function reduceExportDefault(node, _ref41) {
	      var body = _ref41.body;

	      body = body.startsWithFunctionOrClass ? this.paren(body, Sep.EXPORT_PAREN_BEFORE, Sep.EXPORT_PAREN_AFTER) : body;
	      switch (node.body.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          body = seq(body, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("export"), this.sep(Sep.EXPORT_DEFAULT), this.t("default"), this.sep(Sep.AFTER_EXPORT_DEFAULT), body);
	    }
	  }, {
	    key: "reduceExportSpecifier",
	    value: function reduceExportSpecifier(node) {
	      if (node.name == null) return this.t(node.exportedName);
	      return seq(this.t(node.name), this.sep(Sep.BEFORE_EXPORT_AS), this.t("as"), this.sep(Sep.AFTER_EXPORT_AS), this.t(node.exportedName));
	    }
	  }, {
	    key: "reduceLabeledStatement",
	    value: function reduceLabeledStatement(node, _ref42) {
	      var label = _ref42.label;
	      var body = _ref42.body;

	      return (0, _objectAssign2.default)(seq(this.t(label), this.sep(Sep.BEFORE_LABEL_COLON), this.t(":"), this.sep(Sep.AFTER_LABEL_COLON), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceLiteralBooleanExpression",
	    value: function reduceLiteralBooleanExpression(node) {
	      return this.t(node.value.toString());
	    }
	  }, {
	    key: "reduceLiteralNullExpression",
	    value: function reduceLiteralNullExpression(node) {
	      return this.t("null");
	    }
	  }, {
	    key: "reduceLiteralInfinityExpression",
	    value: function reduceLiteralInfinityExpression(node) {
	      return this.t("2e308");
	    }
	  }, {
	    key: "reduceLiteralNumericExpression",
	    value: function reduceLiteralNumericExpression(node) {
	      return new _coderep.NumberCodeRep(node.value);
	    }
	  }, {
	    key: "reduceLiteralRegExpExpression",
	    value: function reduceLiteralRegExpExpression(node) {
	      return this.t("/" + node.pattern + "/" + node.flags);
	    }
	  }, {
	    key: "reduceLiteralStringExpression",
	    value: function reduceLiteralStringExpression(node) {
	      return this.t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceMethod",
	    value: function reduceMethod(node, _ref43) {
	      var name = _ref43.name;
	      var params = _ref43.params;
	      var body = _ref43.body;

	      return seq(node.isGenerator ? seq(this.t("*"), this.sep(Sep.AFTER_METHOD_GENERATOR_STAR)) : empty(), name, this.sep(Sep.AFTER_METHOD_NAME), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_METHOD_BODY), this.brace(body, node, Sep.METHOD_BRACE_INTIAL, Sep.METHOD_BRACE_FINAL, Sep.METHOD_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceModule",
	    value: function reduceModule(node, _ref44) {
	      var directives = _ref44.directives;
	      var items = _ref44.items;

	      if (items.length) {
	        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_MODULE_DIRECTIVES) : empty()], _toConsumableArray(items)));
	    }
	  }, {
	    key: "reduceNewExpression",
	    value: function reduceNewExpression(node, _ref45) {
	      var callee = _ref45.callee;
	      var args = _ref45.arguments;

	      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? this.paren(callee, Sep.NEW_CALLEE_PAREN_BEFORE, Sep.NEW_CALLEE_PAREN_AFTER) : this.p(node.callee, (0, _coderep.getPrecedence)(node), callee);
	      return seq(this.t("new"), this.sep(Sep.AFTER_NEW), calleeRep, args.length === 0 ? this.sep(Sep.EMPTY_NEW_CALL) : seq(this.sep(Sep.BEFORE_NEW_ARGS), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.NEW_PAREN_BEFORE, Sep.NEW_PAREN_AFTER, Sep.NEW_PAREN_EMPTY)));
	    }
	  }, {
	    key: "reduceNewTargetExpression",
	    value: function reduceNewTargetExpression() {
	      return seq(this.t("new"), this.sep(Sep.NEW_TARGET_BEFORE_DOT), this.t("."), this.sep(Sep.NEW_TARGET_AFTER_DOT), this.t("target"));
	    }
	  }, {
	    key: "reduceObjectExpression",
	    value: function reduceObjectExpression(node, _ref46) {
	      var properties = _ref46.properties;

	      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceUpdateExpression",
	    value: function reduceUpdateExpression(node, _ref47) {
	      var operand = _ref47.operand;

	      if (node.isPrefix) {
	        return this.reduceUnaryExpression.apply(this, arguments);
	      } else {
	        return (0, _objectAssign2.default)(seq(this.p(node.operand, _coderep.Precedence.New, operand), this.sep(Sep.BEFORE_POSTFIX(node.operator)), this.t(node.operator)), {
	          startsWithCurly: operand.startsWithCurly,
	          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
	          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
	        });
	      }
	    }
	  }, {
	    key: "reduceUnaryExpression",
	    value: function reduceUnaryExpression(node, _ref48) {
	      var operand = _ref48.operand;

	      return seq(this.t(node.operator), this.sep(Sep.UNARY(node.operator)), this.p(node.operand, (0, _coderep.getPrecedence)(node), operand));
	    }
	  }, {
	    key: "reduceReturnStatement",
	    value: function reduceReturnStatement(node, _ref49) {
	      var expression = _ref49.expression;

	      return seq(this.t("return"), expression ? seq(this.sep(Sep.RETURN), expression) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceScript",
	    value: function reduceScript(node, _ref50) {
	      var directives = _ref50.directives;
	      var statements = _ref50.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_SCRIPT_DIRECTIVES) : empty()], _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceSetter",
	    value: function reduceSetter(node, _ref51) {
	      var name = _ref51.name;
	      var param = _ref51.param;
	      var body = _ref51.body;

	      return seq(this.t("set"), this.sep(Sep.AFTER_SET), name, this.sep(Sep.BEFORE_SET_PARAMS), this.paren(param, Sep.SETTER_PARAM_BEFORE, Sep.SETTER_PARAM_AFTER), this.sep(Sep.BEFORE_SET_BODY), this.brace(body, node, Sep.SET_BRACE_INTIIAL, Sep.SET_BRACE_FINAL, Sep.SET_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceShorthandProperty",
	    value: function reduceShorthandProperty(node) {
	      return this.t(node.name);
	    }
	  }, {
	    key: "reduceStaticMemberExpression",
	    value: function reduceStaticMemberExpression(node, _ref52) {
	      var object = _ref52.object;
	      var property = _ref52.property;

	      var state = seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.BEFORE_STATIC_MEMBER_DOT), this.t("."), this.sep(Sep.AFTER_STATIC_MEMBER_DOT), this.t(property));
	      state.startsWithLet = object.startsWithLet;
	      state.startsWithCurly = object.startsWithCurly;
	      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
	      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
	      return state;
	    }
	  }, {
	    key: "reduceStaticPropertyName",
	    value: function reduceStaticPropertyName(node) {
	      var n;
	      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
	        return this.t(node.value);
	      } else if (n = parseFloat(node.value), n === n) {
	        return new _coderep.NumberCodeRep(n);
	      }
	      return this.t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceSuper",
	    value: function reduceSuper() {
	      return this.t("super");
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref53) {
	      var test = _ref53.test;
	      var consequent = _ref53.consequent;

	      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_CASE_BODY));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref54) {
	      var consequent = _ref54.consequent;

	      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_DEFAULT_BODY));
	    }
	  }, {
	    key: "reduceSwitchStatement",
	    value: function reduceSwitchStatement(node, _ref55) {
	      var discriminant = _ref55.discriminant;
	      var cases = _ref55.cases;

	      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(cases)), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceSwitchStatementWithDefault",
	    value: function reduceSwitchStatementWithDefault(node, _ref56) {
	      var discriminant = _ref56.discriminant;
	      var preDefaultCases = _ref56.preDefaultCases;
	      var defaultCase = _ref56.defaultCase;
	      var postDefaultCases = _ref56.postDefaultCases;

	      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases))), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTemplateExpression",
	    value: function reduceTemplateExpression(node, _ref57) {
	      var tag = _ref57.tag;
	      var elements = _ref57.elements;

	      var state = node.tag == null ? empty() : seq(this.p(node.tag, (0, _coderep.getPrecedence)(node), tag), this.sep(Sep.TEMPLATE_TAG));
	      var templateData = "";
	      state = seq(state, this.t("`"));
	      for (var i = 0, l = node.elements.length; i < l; ++i) {
	        if (node.elements[i].type === "TemplateElement") {
	          var d = "";
	          if (i > 0) d += "}";
	          d += node.elements[i].rawValue;
	          if (i < l - 1) d += "${";
	          state = seq(state, this.t(d));
	        } else {
	          state = seq(state, this.sep(Sep.BEFORE_TEMPLATE_EXPRESSION), elements[i], this.sep(Sep.AFTER_TEMPLATE_EXPRESSION));
	        }
	      }
	      state = seq(state, this.t("`"));
	      if (node.tag != null) {
	        state.startsWithCurly = tag.startsWithCurly;
	        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
	        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
	      }
	      return state;
	    }
	  }, {
	    key: "reduceTemplateElement",
	    value: function reduceTemplateElement(node) {
	      return this.t(node.rawValue);
	    }
	  }, {
	    key: "reduceThisExpression",
	    value: function reduceThisExpression(node) {
	      return this.t("this");
	    }
	  }, {
	    key: "reduceThrowStatement",
	    value: function reduceThrowStatement(node, _ref58) {
	      var expression = _ref58.expression;

	      return seq(this.t("throw"), this.sep(Sep.THROW), expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTryCatchStatement",
	    value: function reduceTryCatchStatement(node, _ref59) {
	      var body = _ref59.body;
	      var catchClause = _ref59.catchClause;

	      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, this.sep(Sep.BEFORE_CATCH), catchClause, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTryFinallyStatement",
	    value: function reduceTryFinallyStatement(node, _ref60) {
	      var body = _ref60.body;
	      var catchClause = _ref60.catchClause;
	      var finalizer = _ref60.finalizer;

	      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, catchClause ? seq(this.sep(Sep.BEFORE_CATCH), catchClause) : empty(), this.sep(Sep.BEFORE_FINALLY), this.t("finally"), this.sep(Sep.AFTER_FINALLY), finalizer, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceYieldExpression",
	    value: function reduceYieldExpression(node, _ref61) {
	      var expression = _ref61.expression;

	      if (node.expression == null) return this.t("yield");
	      return seq(this.t("yield"), this.sep(Sep.YIELD), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceYieldGeneratorExpression",
	    value: function reduceYieldGeneratorExpression(node, _ref62) {
	      var expression = _ref62.expression;

	      return seq(this.t("yield"), this.sep(Sep.BEFORE_YIELD_STAR), this.t("*"), this.sep(Sep.AFTER_YIELD_STAR), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceDirective",
	    value: function reduceDirective(node) {
	      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
	      return seq(this.t(delim + node.rawValue + delim), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceVariableDeclaration",
	    value: function reduceVariableDeclaration(node, _ref63) {
	      var declarators = _ref63.declarators;

	      return seq(this.t(node.kind), this.sep(Sep.VARIABLE_DECLARATION), this.commaSep(declarators, Sep.DECLARATORS_BEFORE_COMMA, Sep.DECLARATORS_AFTER_COMMA));
	    }
	  }, {
	    key: "reduceVariableDeclarationStatement",
	    value: function reduceVariableDeclarationStatement(node, _ref64) {
	      var declaration = _ref64.declaration;

	      return seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceVariableDeclarator",
	    value: function reduceVariableDeclarator(node, _ref65) {
	      var binding = _ref65.binding;
	      var init = _ref65.init;

	      var containsIn = init && init.containsIn && !init.containsGroup;
	      if (init) {
	        if (init.containsGroup) {
	          init = this.paren(init, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        } else {
	          init = markContainsIn(init);
	        }
	      }
	      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, this.sep(Sep.BEFORE_INIT_EQUALS), this.t("="), this.sep(Sep.AFTER_INIT_EQUALS), init), { containsIn: containsIn });
	    }
	  }, {
	    key: "reduceWhileStatement",
	    value: function reduceWhileStatement(node, _ref66) {
	      var test = _ref66.test;
	      var body = _ref66.body;

	      return (0, _objectAssign2.default)(seq(this.t("while"), this.sep(Sep.AFTER_WHILE), this.paren(test, Sep.WHILE_TEST_PAREN_BEFORE, Sep.WHILE_TEST_PAREN_AFTER), this.sep(Sep.BEFORE_WHILE_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceWithStatement",
	    value: function reduceWithStatement(node, _ref67) {
	      var object = _ref67.object;
	      var body = _ref67.body;

	      return (0, _objectAssign2.default)(seq(this.t("with"), this.sep(Sep.AFTER_WITH), this.paren(object, Sep.WITH_PAREN_BEFORE, Sep.WITH_PAREN_AFTER), this.sep(Sep.BEFORE_WITH_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }]);

	  return ExtensibleCodeGen;
	}();

	var INDENT = "  ";

	var Linebreak = function (_CodeRep) {
	  _inherits(Linebreak, _CodeRep);

	  function Linebreak() {
	    _classCallCheck(this, Linebreak);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Linebreak).call(this));

	    _this4.indentation = 0;
	    return _this4;
	  }

	  _createClass(Linebreak, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("\n");
	      for (var i = 0; i < this.indentation; ++i) {
	        ts.put(INDENT);
	      }
	    }
	  }]);

	  return Linebreak;
	}(_coderep.CodeRep);

	function withoutTrailingLinebreak(state) {
	  if (state && state instanceof _coderep.Seq) {
	    var lastChild = state.children[state.children.length - 1];
	    /* istanbul ignore next */
	    while (lastChild instanceof _coderep.Empty) {
	      state.children.pop();
	      lastChild = state.children[state.children.length - 1];
	    }
	    /* istanbul ignore else */
	    if (lastChild instanceof _coderep.Seq) {
	      withoutTrailingLinebreak(lastChild);
	    } else if (lastChild instanceof Linebreak) {
	      state.children.pop();
	    }
	  }
	  return state;
	}

	function indent(rep, includingFinal) {
	  var finalLinebreak = undefined;
	  function indentNode(node) {
	    if (node instanceof Linebreak) {
	      finalLinebreak = node;
	      ++node.indentation;
	    }
	  }
	  rep.forEach(indentNode);
	  if (!includingFinal) {
	    --finalLinebreak.indentation;
	  }
	  return rep;
	}

	var FormattedCodeGen = exports.FormattedCodeGen = function (_ExtensibleCodeGen) {
	  _inherits(FormattedCodeGen, _ExtensibleCodeGen);

	  function FormattedCodeGen() {
	    _classCallCheck(this, FormattedCodeGen);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(FormattedCodeGen).apply(this, arguments));
	  }

	  _createClass(FormattedCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(element)));
	      }
	      return original;
	    }
	  }, {
	    key: "brace",
	    value: function brace(rep, node) {
	      if (isEmpty(rep)) {
	        return this.t("{}");
	      }

	      switch (node.type) {
	        case "ObjectBinding":
	        case "Import":
	        case "ExportFrom":
	        case "ObjectExpression":
	          return new _coderep.Brace(rep);
	      }

	      rep = seq(new Linebreak(), rep);
	      indent(rep, false);
	      return new _coderep.Brace(rep);
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref68) {
	      var body = _ref68.body;
	      var test = _ref68.test;

	      return seq(this.t("do"), this.sep(Sep.AFTER_DO), withoutTrailingLinebreak(body), this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref69) {
	      var test = _ref69.test;
	      var consequent = _ref69.consequent;
	      var alternate = _ref69.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = this.brace(consequent, node);
	      }
	      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), withoutTrailingLinebreak(consequent), alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), withoutTrailingLinebreak(alternate)) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref70) {
	      var test = _ref70.test;
	      var consequent = _ref70.consequent;

	      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
	      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), consequent, this.sep(Sep.AFTER_CASE_BODY));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref71) {
	      var consequent = _ref71.consequent;

	      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
	      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), consequent, this.sep(Sep.AFTER_DEFAULT_BODY));
	    }
	  }, {
	    key: "sep",
	    value: function sep(separator) {
	      switch (separator.type) {
	        case "ARRAY_AFTER_COMMA":
	        case "OBJECT_AFTER_COMMA":
	        case "ARGS_AFTER_COMMA":
	        case "PARAMETER_AFTER_COMMA":
	        case "DECLARATORS_AFTER_COMMA":
	        case "NAMED_IMPORT_AFTER_COMMA":
	        case "IMPORT_AFTER_COMMA":
	        case "BEFORE_DEFAULT_EQUALS":
	        case "AFTER_DEFAULT_EQUALS":
	        case "AFTER_PROP":
	        case "BEFORE_JUMP_LABEL":
	        case "BEFORE_CATCH":
	        case "BEFORE_CATCH_BINDING":
	        case "AFTER_CATCH_BINDING":
	        case "BEFORE_CLASS_NAME":
	        case "BEFORE_EXTENDS":
	        case "AFTER_EXTENDS":
	        case "BEFORE_CLASS_DECLARATION_ELEMENTS":
	        case "BEFORE_CLASS_EXPRESSION_ELEMENTS":
	        case "AFTER_STATIC":
	        case "BEFORE_TERNARY_QUESTION":
	        case "AFTER_TERNARY_QUESTION":
	        case "BEFORE_TERNARY_COLON":
	        case "AFTER_TERNARY_COLON":
	        case "AFTER_DO":
	        case "BEFORE_DOWHILE_WHILE":
	        case "AFTER_DOWHILE_WHILE":
	        case "AFTER_FORIN_FOR":
	        case "BEFORE_FORIN_IN":
	        case "AFTER_FORIN_FOR":
	        case "BEFORE_FORIN_BODY":
	        case "AFTER_FOROF_FOR":
	        case "BEFORE_FOROF_OF":
	        case "AFTER_FOROF_FOR":
	        case "BEFORE_FOROF_BODY":
	        case "AFTER_FOR_FOR":
	        case "BEFORE_FOR_TEST":
	        case "BEFORE_FOR_UPDATE":
	        case "BEFORE_FOR_BODY":
	        case "BEFORE_FUNCTION_DECLARATION_BODY":
	        case "BEFORE_FUNCTION_EXPRESSION_BODY":
	        case "BEFORE_ARROW":
	        case "AFTER_ARROW":
	        case "AFTER_GET":
	        case "BEFORE_GET_BODY":
	        case "AFTER_IF":
	        case "AFTER_IF_TEST":
	        case "BEFORE_ELSE":
	        case "AFTER_ELSE":
	        case "BEFORE_IMPORT_BINDINGS":
	        case "BEFORE_IMPORT_MODULE":
	        case "AFTER_IMPORT_BINDINGS":
	        case "AFTER_FROM":
	        case "BEFORE_IMPORT_NAMESPACE":
	        case "BEFORE_IMPORT_STAR":
	        case "AFTER_IMPORT_STAR":
	        case "AFTER_IMPORT_AS":
	        case "AFTER_NAMESPACE_BINDING":
	        case "BEFORE_IMPORT_AS":
	        case "AFTER_IMPORT_AS":
	        case "EXPORTS_AFTER_COMMA":
	        case "BEFORE_EXPORT_STAR":
	        case "AFTER_EXPORT_STAR":
	        case "BEFORE_EXPORT_BINDINGS":
	        case "AFTER_EXPORT_BINDINGS":
	        case "AFTER_EXPORT":
	        case "AFTER_EXPORT_DEFAULT":
	        case "BEFORE_EXPORT_AS":
	        case "AFTER_EXPORT_AS":
	        case "AFTER_LABEL_COLON":
	        case "BEFORE_METHOD_BODY":
	        case "AFTER_NEW":
	        case "RETURN":
	        case "AFTER_SET":
	        case "BEFORE_SET_BODY":
	        case "BEFORE_SET_PARAMS":
	        case "BEFORE_CASE_TEST":
	        case "BEFORE_SWITCH_DISCRIM":
	        case "BEFORE_SWITCH_BODY":
	        case "THROW":
	        case "AFTER_TRY":
	        case "BEFORE_CATCH":
	        case "BEFORE_FINALLY":
	        case "AFTER_FINALLY":
	        case "VARIABLE_DECLARATION":
	        case "YIELD":
	        case "AFTER_YIELD_STAR":
	        case "DECLARATORS_AFTER_COMMA":
	        case "BEFORE_INIT_EQUALS":
	        case "AFTER_INIT_EQUALS":
	        case "AFTER_WHILE":
	        case "BEFORE_WHILE_BODY":
	        case "AFTER_WITH":
	        case "BEFORE_WITH_BODY":
	        case "BEFORE_FUNCTION_NAME":
	        case "AFTER_BINOP":
	        case "BEFORE_ASSIGN_OP":
	        case "AFTER_ASSIGN_OP":
	          return this.t(" ");
	        case "AFTER_STATEMENT":
	          switch (separator.node.type) {
	            case "ForInStatement":
	            case "ForOfStatement":
	            case "ForStatement":
	            case "WhileStatement":
	            case "WithStatement":
	              return empty(); // because those already end with an AFTER_STATEMENT
	            default:
	              return new Linebreak();
	          }
	        case "AFTER_CLASS_ELEMENT":
	        case "BEFORE_CASE_BODY":
	        case "AFTER_CASE_BODY":
	        case "AFTER_DEFAULT_BODY":
	          return new Linebreak();
	        case "BEFORE_BINOP":
	          return separator.op === "," ? empty() : this.t(" ");
	        case "UNARY":
	          return separator.op === "delete" || separator.op === "void" || separator.op === "typeof" ? this.t(" ") : empty();
	        default:
	          return empty();
	      }
	    }
	  }]);

	  return FormattedCodeGen;
	}(ExtensibleCodeGen);

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TokenStream = undefined;

	var _esutils = __webpack_require__(4);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function numberDot(fragment) {
	  if (fragment.indexOf(".") < 0 && fragment.indexOf("e") < 0) {
	    return "..";
	  }
	  return ".";
	}

	function renderNumber(n) {
	  var s;
	  if (n >= 1e3 && n % 10 === 0) {
	    s = n.toString(10);
	    if (/[eE]/.test(s)) {
	      return s.replace(/[eE]\+/, "e");
	    }
	    return n.toString(10).replace(/0+$/, function (match) {
	      return "e" + match.length;
	    });
	  } else if (n % 1 === 0) {
	    if (n > 1e15 && n < 1e20) {
	      return "0x" + n.toString(16).toUpperCase();
	    }
	    return n.toString(10).replace(/[eE]\+/, "e");
	  } else {
	    return n.toString(10).replace(/^0\./, ".").replace(/[eE]\+/, "e");
	  }
	}

	var TokenStream = exports.TokenStream = function () {
	  function TokenStream() {
	    _classCallCheck(this, TokenStream);

	    this.result = "";
	    this.lastNumber = null;
	    this.lastChar = null;
	    this.optionalSemi = false;
	  }

	  _createClass(TokenStream, [{
	    key: "putNumber",
	    value: function putNumber(number) {
	      var tokenStr = renderNumber(number);
	      this.put(tokenStr);
	      this.lastNumber = tokenStr;
	    }
	  }, {
	    key: "putOptionalSemi",
	    value: function putOptionalSemi() {
	      this.optionalSemi = true;
	    }
	  }, {
	    key: "put",
	    value: function put(tokenStr) {
	      if (this.optionalSemi) {
	        this.optionalSemi = false;
	        if (tokenStr !== "}") {
	          this.put(";");
	        }
	      }
	      if (this.lastNumber !== null && tokenStr.length == 1) {
	        if (tokenStr === ".") {
	          this.result += numberDot(this.lastNumber);
	          this.lastNumber = null;
	          this.lastChar = ".";
	          return;
	        }
	      }
	      this.lastNumber = null;
	      var rightChar = tokenStr.charAt(0);
	      var lastChar = this.lastChar;
	      this.lastChar = tokenStr.charAt(tokenStr.length - 1);
	      if (lastChar && ((lastChar == "+" || lastChar == "-") && lastChar == rightChar || _esutils.code.isIdentifierPartES6(lastChar.charCodeAt(0)) && _esutils.code.isIdentifierPartES6(rightChar.charCodeAt(0)) || lastChar == "/" && rightChar == "i")) {
	        this.result += " ";
	      }

	      this.result += tokenStr;
	    }
	  }]);

	  return TokenStream;
	}();

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Modules = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(9);

	var _env = __webpack_require__(50);

	var _env2 = _interopRequireDefault(_env);

	var _shiftReader = __webpack_require__(1);

	var _shiftReader2 = _interopRequireDefault(_shiftReader);

	var _ramda = __webpack_require__(26);

	var _ = _interopRequireWildcard(_ramda);

	var _tokenExpander = __webpack_require__(49);

	var _tokenExpander2 = _interopRequireDefault(_tokenExpander);

	var _bindingMap = __webpack_require__(13);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _terms = __webpack_require__(27);

	var _terms2 = _interopRequireDefault(_terms);

	var _loadSyntax = __webpack_require__(51);

	var _loadSyntax2 = _interopRequireDefault(_loadSyntax);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Module = function () {
	  function Module(moduleSpecifier, importEntries, exportEntries, body) {
	    _classCallCheck(this, Module);

	    this.moduleSpecifier = moduleSpecifier;
	    this.importEntries = importEntries;
	    this.exportEntries = exportEntries;
	    this.body = body;
	  }

	  // put all compiltime transforms in the returned store


	  _createClass(Module, [{
	    key: "visit",
	    value: function visit(context) {

	      this.exportEntries.forEach(function (ex) {
	        if ((0, _terms.isSyntaxDeclaration)(ex.declaration) || (0, _terms.isSyntaxrecDeclaration)(ex.declaration)) {
	          ex.declaration.declarators.forEach((0, _loadSyntax2.default)(_.__, context, context.store));
	        }
	      });

	      return context.store;
	    }
	  }]);

	  return Module;
	}();

	var Modules = exports.Modules = function () {
	  function Modules() {
	    _classCallCheck(this, Modules);

	    this.loadedModules = new Map();
	  }

	  // ... -> { body: [Term], importEntries: [Import], exportEntries: [Export] }


	  _createClass(Modules, [{
	    key: "load",
	    value: function load(modulePath, context) {
	      var _this = this;

	      var path = context.moduleResolver(modulePath, context.cwd);
	      if (!this.loadedModules.has(path)) {
	        (function () {
	          var modStr = context.moduleLoader(path);
	          var reader = new _shiftReader2.default(modStr);
	          var stxl = reader.read();
	          var tokenExpander = new _tokenExpander2.default(_.merge(context, {
	            // expand with a fresh environment
	            env: new _env2.default(),
	            store: new _env2.default(),
	            bindings: new _bindingMap2.default()
	          }));
	          var terms = tokenExpander.expand(stxl);
	          var importEntries = [];
	          var exportEntries = [];
	          terms.forEach(function (t) {
	            _.cond([[_terms.isImport, function (t) {
	              return importEntries.push(t);
	            }], [_terms.isExport, function (t) {
	              return exportEntries.push(t);
	            }]])(t);
	          });
	          _this.loadedModules.set(path, new Module(path, (0, _immutable.List)(importEntries), (0, _immutable.List)(exportEntries), terms));
	        })();
	      }
	      return this.loadedModules.get(path);
	    }
	  }]);

	  return Modules;
	}();
	//# sourceMappingURL=modules.js.map


/***/ }
/******/ ])});;