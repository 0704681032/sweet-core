<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Sweet.js Documentation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link href='http://fonts.googleapis.com/css?family=Lato:100' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="style/sweetprism.css">
  <script type='text/javascript'>
  window.onload = function() {
  	document.body.className = "language-javascript";
  	Prism.highlightAll();
  }
  </script>
  <link href='style/prism.css' rel='stylesheet' />
  <script src="style/prism.js"></script>
  <style>
  body {
    margin: 0;
    padding: 0;
  }
  
  body {
    width: 600px;
    margin: 0 auto;
    position: relative;
    top: 75px;
  }
  
  #logo {
    float: left;
    width: 275px;
  }
  
  #content {
    float: left;
    width: 650px;
    padding-bottom:50px;
  }
  
  h1,h2,h3 {
    font-family: Helvetica Neue;
    font-weight: 100;
    color: #222;
    position: relative;
    text-transform: uppercase;
    color: #444;
    font-family: 'Lato', Helvetica Neue, Helvetica, Arial, sans-serif;
    font-weight: 100;
    border-bottom: solid 1px #eee;
  }
  h1 {
    font-size: 200%;
  }
  h2 {
    font-size: 150%;
  }
  h3 {
    font-size: 120%;
  }
  
  p, li {
    font-family: 'Source Sans Pro', sans-serif;
    /*font-weight: 400;*/
    font-size: large;
  }
  
  
  p code {
    font-size: 14px;
  }
  li code {
    font-size: 14px;
  }
  
  a {
  	text-decoration: none;
  }
  a:hover, a:focus {
      text-decoration: underline;
  }
  
  .editor { display : none }
  
  /* to display output of macro expansions */
  .console {
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    padding: 1em;
    margin-top:1em;
    white-space: pre;
    background: #f5f2f0;
    resize: vertical;
    max-height: 700px;
    overflow: auto;
    font-family: Consolas, Monaco, "Andale Mono", monospace;
    text-shadow:0 1px white;
    display:none;
  }
  
  </style>
</head>
<body>
<header>
<h1 class="title">Sweet.js Documentation</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#rule-macros"><span class="toc-section-number">2</span> Rule Macros</a><ul>
<li><a href="#patterns"><span class="toc-section-number">2.1</span> Patterns</a><ul>
<li><a href="#repetition"><span class="toc-section-number">2.1.1</span> Repetition</a></li>
<li><a href="#pattern-classes"><span class="toc-section-number">2.1.2</span> Pattern Classes</a></li>
<li><a href="#literal-patterns"><span class="toc-section-number">2.1.3</span> Literal patterns</a></li>
</ul></li>
</ul></li>
<li><a href="#hygiene"><span class="toc-section-number">3</span> Hygiene</a></li>
<li><a href="#case-macros"><span class="toc-section-number">4</span> Case Macros</a></li>
<li><a href="#let-macros"><span class="toc-section-number">5</span> Let macros</a></li>
<li><a href="#infix-macros"><span class="toc-section-number">6</span> Infix Macros</a></li>
<li><a href="#custom-operators"><span class="toc-section-number">7</span> Custom Operators</a><ul>
<li><a href="#operator-precedence"><span class="toc-section-number">7.1</span> Operator Precedence</a></li>
</ul></li>
<li><a href="#modules"><span class="toc-section-number">8</span> Modules</a><ul>
<li><a href="#using-modules"><span class="toc-section-number">8.1</span> Using modules</a></li>
<li><a href="#node-loader"><span class="toc-section-number">8.2</span> Node loader</a></li>
</ul></li>
<li><a href="#faq"><span class="toc-section-number">9</span> FAQ</a><ul>
<li><a href="#how-do-i-break-hygiene"><span class="toc-section-number">9.1</span> How do I break hygiene?</a></li>
<li><a href="#how-do-i-output-comments"><span class="toc-section-number">9.2</span> How do I output comments?</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Install the sweet.js compiler via npm:</p>
<pre class="language-bash"><code>npm install -g sweet.js</code></pre>
<p>This installs the <code>sjs</code> binary which is used to compile sweet.js code:</p>
<pre class="language-bash"><code>sjs --output out.js my_sweet_code.js</code></pre>
<h1 id="rule-macros"><span class="header-section-number">2</span> Rule Macros</h1>
<p>You can think of macros as functions that work on syntax. Much like a normal function you write a macro <em>definition</em> and then later <em>invoke</em> the macro with a syntax argument to produce new syntax. Running sweet.js code through the compiler will <em>expand</em> all macros and produce pure JavaScript that can be run in any JS environment.</p>
<p>Sweet.js provides two ways to define a macro: the simpler pattern-based <em>rule</em> macros and the more powerful procedural <em>case</em> macros (if you are familiar with Scheme or Racket these correspond to <code>syntax-rules</code> and <code>syntax-case</code>).</p>
<p>Rule macros work by matching a syntax <em>pattern</em> and generating new syntax based on a <em>template</em>.</p>
<p>To define a macro sweet.js provides a new <code>macro</code> keyword that looks something like this:</p>
<pre class="js"><code>macro &lt;name&gt; {
  rule { &lt;pattern&gt; } =&gt; { &lt;template&gt; }
}</code></pre>
<p>For example, here's a really simple identity macro that just expands to its syntax argument:</p>
<pre class="js"><code>macro id {
  rule {
    // after the macro name, match:
    // (1) a open paren 
    // (2) a single token and bind it to `$x`
    // (3) a close paren
    ($x)
  } =&gt; {
    // just return the token that is bound to `$x`
    $x
  }
}</code></pre>
<p>We can then invoke <code>id</code> with:</p>
<pre class="js"><code>id (42)
// expands to:
// 42</code></pre>
<p>A pattern that begins with <code>$</code> matches any token and binds it to that name in the template while everything else matches literally.</p>
<p>Note that a single token includes matched delimiters not just numbers and identifiers. For example, an array with all of its elements counts as one token:</p>
<pre class="js"><code>id ([1, 2, 3])
// expands to:
// [1, 2, 3]</code></pre>
<p>Macros can have multiple rules.</p>
<pre class="js"><code>macro m {
  rule { ($x) } =&gt; { $x }
  rule { ($x, $y) } =&gt; { [$x, $y] }
}

m (1);
m (1, 2);</code></pre>
<p>Rules are matched in-order and the first one to match the pattern will be used.</p>
<p>And macros can be recursively defined:</p>
<pre class="js"><code>macro m {
  rule { ($base) } =&gt; { [$base] }
  rule { ($head $tail ...) } =&gt; { [$head, m ($tail ...)] }
}
m (1 2 3 4 5)  // --&gt; [1, [2, [3, [4, [5]]]]]</code></pre>
<h2 id="patterns"><span class="header-section-number">2.1</span> Patterns</h2>
<h3 id="repetition"><span class="header-section-number">2.1.1</span> Repetition</h3>
<p>Repeated tokens can be matched with ellipses <code>...</code>.</p>
<pre class="js"><code>macro m {
  rule { ($x ...) } =&gt; {
    // ...
  }
}
m (1 2 3 4)</code></pre>
<p>A repeated pattern with a separator between each item can be matched by adding <code>(,)</code> between <code>...</code> and the pattern being repeated.</p>
<pre class="js"><code>macro m {
  rule { ($x (,) ...) } =&gt; {
    [$x (,) ...]
  }
}
m (1, 2, 3, 4)</code></pre>
<p>Repeated groups of patterns can be matched using <code>$()</code>.</p>
<pre class="js"><code>macro m {
  rule { ( $($id = $val) (,) ...) } =&gt; {
    $(var $id = $val;) ...
  }
}
m (x = 10, y = 2)</code></pre>
<h3 id="pattern-classes"><span class="header-section-number">2.1.2</span> Pattern Classes</h3>
<p>A pattern name can be restricted to a particular parse class by using <code>$name:class</code> in which case rather than matching a token the pattern matches all the tokens matched by the class.</p>
<pre class="js"><code>macro m {
  rule { ($x:expr) } =&gt; {
    $x
  }
}
m (2 + 5 * 10)
// --&gt; expands to
2 + 5 * 10</code></pre>
<p>The parse classes are:</p>
<ul>
<li><code>:ident</code> -- matches an identifier (eg. <code>foo</code>)</li>
<li><code>:lit</code> -- matches a literal (eg. <code>100</code> or <code>&quot;a string&quot;</code>)</li>
<li><code>:expr</code> -- matches an expression (eg. <code>foo(&quot;a string&quot;) + 100</code>)</li>
</ul>
<h3 id="literal-patterns"><span class="header-section-number">2.1.3</span> Literal patterns</h3>
<p>The syntax <code>$[]</code> will match what is inside the brackets literally. For example, if you need to match <code>...</code> in a pattern (rather than have <code>...</code> mean repetition) you can escape it with <code>$[...]</code>.</p>
<h1 id="hygiene"><span class="header-section-number">3</span> Hygiene</h1>
<p>To make things slightly more interesting, let's say we want to write a macro that swaps the values stored in two variables.</p>
<pre class="js"><code>macro swap {
  rule { {$a &lt;=&gt; $b} } =&gt; {
    var tmp = $a;
    $a = $b;
    $b = tmp;
  }
}

var a = 10;
var b = 20;

swap {a &lt;=&gt; b}</code></pre>
<p>After running this through sweet.js we get the expanded code:</p>
<pre class="js"><code>var a$1 = 10;
var b$2 = 20;

var tmp$3 = a$1;
a$1 = b$2;
b$2 = tmp$3;</code></pre>
<p>As you can see, the variables names have been changed with a <code>$n</code> postfix. This is hygiene at work. One of the critical features of sweet.js is protecting macros from unintentionally binding or capturing variables they weren't supposed to. This is called hygiene and to enforce hygiene sweet.js must carefully rename all variables.</p>
<p>If sweet.js did not protect hygiene a naive expansion would do the wrong thing:</p>
<pre class="js"><code>var tmp = 10;
var b = 20;

swap {tmp &lt;=&gt; b}

// --&gt; naive expansion
var tmp = 10;
var b = 20;

var tmp = tmp;
tmp = b;
b = tmp;</code></pre>
<p>But since sweet.js protects hygiene, all variable names are correctly renamed:</p>
<pre class="js"><code>var tmp = 10;
var b = 20;

swap {tmp &lt;=&gt; b}

// --&gt; hygienic expansion
var tmp$1 = 10;
var b$2 = 20;

var tmp$3 = tmp$1;
tmp$3 = b$2;
b$2 = tmp$1;</code></pre>
<p>In the cases where you want to intentionally break hygiene you can use the procedural case macros described in the next section.</p>
<h1 id="case-macros"><span class="header-section-number">4</span> Case Macros</h1>
<p>Sweet.js also provides a more powerful way to define macros: case macros. Case macros allow you to manipulate syntax using the full power of JavaScript. Case macros look like this:</p>
<pre class="js"><code>macro &lt;name&gt; {
  case { &lt;pattern&gt; } =&gt; { &lt;body&gt; }
}</code></pre>
<p>Case macros look similar to rule macros with a few important differences. First, the patterns also match the macro name instead of just the syntax that comes after it:</p>
<pre class="js"><code>macro m {
  case { $name $x } =&gt; { ... }
}
m 42  // `$name` will be bound to the `m` token
      // in the macro body</code></pre>
<p>Most of the time you won't need to match the name and can use the wildcard <code>_</code> pattern (which matches any token but doesn't bind it to a name) to ignore it:</p>
<pre class="js"><code>macro m {
  case { _ $x } =&gt; { ... }
}</code></pre>
<p>The other difference from rule macros is that the body of a macro contains a mixture of templates and normal JavaScript that can create and manipulate syntax. For example, here's the identity macro defined with a case macro:</p>
<pre class="js"><code>macro id {
  case {_ $x } =&gt; {
    return #{ $x }
  }
}</code></pre>
<p>Templates are now created with the <code>#{...}</code> form (which is technically shorthand for <code>syntax {...}</code>). The <code>#{...}</code> form creates an array of <em>syntax objects</em> using any pattern bindings that are in scope (i.e. were matched by the pattern).</p>
<p><em>Syntax objects</em> are the representation of tokens that sweet.js uses to keep track of lexical context (which is used to maintain hygiene). They can be created with templates (<code>#{}</code>) but you can also create individual syntax objects using the lexical context of an existing syntax object:</p>
<pre class="js"><code>macro m {
  case {_ $x } =&gt; {
    var y = makeValue(42, #{$x});
    return [y]
  }
}
m foo
// --&gt; expands to
42</code></pre>
<p>Sweet.js provides the following functions to create syntax objects:</p>
<ul>
<li><code>makeValue(val, stx)</code> -- <code>val</code> can be a <code>boolean</code>, <code>number</code>, <code>string</code>, or <code>null</code>/<code>undefined</code></li>
<li><code>makeRegex(pattern, flags, stx)</code> -- <code>pattern</code> is the string representation of the regex pattern and <code>flags</code> is the string representation of the regex flags</li>
<li><code>makeIdent(val, stx)</code> -- <code>val</code> is a string representing an identifier</li>
<li><code>makePunc(val, stx)</code> -- <code>val</code> is a string representing a punctuation (e.g. <code>=</code>, <code>,</code>, <code>&gt;</code>, etc.)</li>
<li><code>makeDelim(val, inner, stx)</code> -- <code>val</code> represents which delimiter to make and can be either <code>&quot;()&quot;</code>, <code>&quot;[]&quot;</code>, or <code>&quot;{}&quot;</code> and <code>inner</code> is an array of syntax objects for all of the tokens inside the delimiter.</li>
</ul>
<p>If you want strip a syntax object of its lexical context and get directly at the token you can use <code>unwrapSyntax(stx)</code>.</p>
<p>When using these functions to create new syntax objects it is convenient to refer to them in <code>#{}</code> templates. To do this sweet.js provides the <code>letstx</code> macro that binds syntax objects to pattern variables:</p>
<pre class="js"><code>macro m {
  case {_ $x } =&gt; {
    var y = makeValue(42, #{$x});
    letstx $y = [y], $z = [makeValue(2, #{$x})];
    return #{$x + $y - $z}
  }
}
m 1
// --&gt; expands to
1 + 42 - 2</code></pre>
<h1 id="let-macros"><span class="header-section-number">5</span> Let macros</h1>
<p>Sometimes you don't want a macro to recursively call itself. For example, say you want to override <code>function</code> to add some logging information before the rest of the function executes:</p>
<pre class="js"><code>macro function {
  case {_ $name ($params ...) { $body ...} } =&gt; {
    return #{
      function $name ($params ...) {
        console.log(&quot;Imma let you finish...&quot;);
        $body ...
      }
    }
  }
}</code></pre>
<p>If you tried to run this through the compiler it will loop forever since the <code>function</code> identifier in the macro expansion is bound to the <code>function</code> macro. To prevent this you can use the <code>let</code> macro binding form:</p>
<pre class="js"><code>let function = macro {
  case {_ $name ($params ...) { $body ...} } =&gt; {
    return #{
      function $name ($params ...) {
        console.log(&quot;Imma let you finish...&quot;);
        $body ...
      }
    }
  }
}</code></pre>
<p>This binds <code>function</code> to the macro in the rest of the code but not in the body of the <code>function</code> macro.</p>
<h1 id="infix-macros"><span class="header-section-number">6</span> Infix Macros</h1>
<p>Sweet.js also lets you match on previous syntax using <code>infix</code> rules. Use a vertical bar (<code>|</code>) to separate your left-hand-side from your right-hand-side.</p>
<pre class="js"><code>macro unless {
  rule infix { return $value:expr | $guard:expr } =&gt; {
    if (!($guard)) {
      return $value;
    }
  }
}

function foo(x) {
  return true unless x &gt; 42;
  return false;
}</code></pre>
<p>You can use the <code>infix</code> keyword with procedural macros, too. The macro name is just the first token on the right-hand-side.</p>
<pre class="js"><code>macro m {
  case infix { $lhs | $name $rhs } =&gt; { ... }
}</code></pre>
<p>Infix rules can be mixed and matched with normal rules:</p>
<pre class="js"><code>macro m {
  rule infix { $lhs | $rhs } =&gt; { ... }
  rule { $rhs } =&gt; { ... }
}</code></pre>
<p>You can even leave off the right-hand-side for a postfix macro:</p>
<pre class="js"><code>macro m {
  rule infix { $lhs | } =&gt; { ... }
}</code></pre>
<p>Sweet.js does its best to keep you from clobbering previous syntax.</p>
<pre class="js"><code>macro m {
  rule infix { ($args ...) | $call:expr } =&gt; {
    $call($args ...)
  }
}

(42) m foo; // This works
bar(42) m foo; // This is a match error</code></pre>
<p>The second example fails to match because you'd be splitting the good function call on the left-hand-side in half. The result would have been nonsense, giving you a nasty parse error.</p>
<h1 id="custom-operators"><span class="header-section-number">7</span> Custom Operators</h1>
<pre class="js"><code>macro (=&gt;) {
    rule infix { ($params ...) | { $body ... } } =&gt; {
        function ($params ...) { $body ... }
    }
}
operator (&gt;&gt;=) 12 left { $l, $r } =&gt; #{$l.then($r) }

get(&#39;story.json&#39;)  &gt;&gt;= (response) =&gt; {
  return JSON.parse(response);
} &gt;&gt;= (response) =&gt; {
  console.log(&quot;Yey JSON!&quot;, response);
} &gt;&gt;= JSON.parse</code></pre>
<h2 id="operator-precedence"><span class="header-section-number">7.1</span> Operator Precedence</h2>
<p>Unary Operators:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Precedence</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>new</code></td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>++</code></td>
<td style="text-align: left;">15</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--</code></td>
<td style="text-align: left;">15</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>~</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>typeof</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>delete</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>yield</code></td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<p>Binary Operators:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Precedence</th>
<th style="text-align: left;">Associativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%</code></td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;">12</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;">12</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;&gt;</code></td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&lt;</code></td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;&gt;&gt;</code></td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;=</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;=</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>in</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>instanceof</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>==</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!=</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>===</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!==</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&amp;</code></td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>^</code></td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>|</code></td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&amp;&amp;</code></td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>||</code></td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">left</td>
</tr>
</tbody>
</table>
<h1 id="modules"><span class="header-section-number">8</span> Modules</h1>
<h2 id="using-modules"><span class="header-section-number">8.1</span> Using modules</h2>
<p>At the moment sweet.js supports a primitive form of module support with the <code>--module</code> flag.</p>
<p>For example, if you have a file <code>macros.js</code> that defines the <code>m</code> macro:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// macros.js</span>

macro m { <span class="co">/* ... */</span> }
<span class="kw">export</span> m;</code></pre>
<p>and <code>my_sweet_code.js</code> uses <code>m</code>:</p>
<pre class="js"><code>// my_sweet_code.js

m 42</code></pre>
<p>You would compile this with:</p>
<pre><code>$ sjs --module ./macros.js  my_sweet_code.js </code></pre>
<p>Note that modules must use the <code>export</code> keyword. This allows modules to define &quot;private&quot; macros that are not visible to the main code.</p>
<p>The <code>--module</code> flag uses the node path to look up the module file so you can publish and use macro modules on npm. Checkout <a href="https://github.com/natefaubion/lambda-chop">lambda-chop</a> for an example of this.</p>
<p>The biggest limitation with the current approach is that you can't arbitrarily interleave importing compile-time values (macros) and run-time values (functions). This will eventually be handled with support for &quot;proper&quot; modules (issue #43).</p>
<h2 id="node-loader"><span class="header-section-number">8.2</span> Node loader</h2>
<p>If you'd like to skip using the <code>sjs</code> binary to compile your sweet.js code, you can use the node loader. This allows you to <code>require</code> sweet.js files that have the <code>.sjs</code> extension:</p>
<pre class="js"><code>var sjs = require(&#39;sweet.js&#39;),
    example = require(&#39;./example.sjs&#39;);

example.one;</code></pre>
<p>Where ./example.sjs contains:</p>
<pre class="js"><code>//  example.sjs
macro id {
    rule { ($x) } =&gt; {
        $x
    }
}

exports.one = id (1);</code></pre>
<p>Note that <code>require('sweet.js')</code> must come before any requires of <code>.sjs</code> code. Also note that this does not import any macros, it just uses sweet.js to compile files that contain macros before requiring them.</p>
<h1 id="faq"><span class="header-section-number">9</span> FAQ</h1>
<h2 id="how-do-i-break-hygiene"><span class="header-section-number">9.1</span> How do I break hygiene?</h2>
<p>Sometimes you really do need to break the wonderful protections provided by hygiene. Breaking hygiene is usually a bad idea but sweet.js won't judge.</p>
<p>Breaking hygiene is done by stealing the lexical context from syntax objects in the &quot;right place&quot;. To clarify, consider <code>aif</code> the <a href="http://en.wikipedia.org/wiki/Anaphoric_macro">anaphoric</a> if macro that binds its condition to the identifier <code>it</code> in the body.</p>
<pre class="js"><code>var it = &quot;foo&quot;;
long.obj.path = [1, 2, 3];
aif (long.obj.path) {
  console.log(it);
}
// logs: [1, 2, 3]</code></pre>
<p>This is a violation of hygiene because normally <code>it</code> should be bound to the surrounding environment (<code>&quot;foo&quot;</code> in the example above) but <code>aif</code> wants to capture <code>it</code>. To do this we can create an <code>it</code> binding in the macro that has the lexical context associated with the surrounding environment. The lexical context we want is actually found on the <code>aif</code> macro name itself. So we just need to create a new <code>it</code> binding using the lexical context of <code>aif</code>:</p>
<pre class="js"><code>macro aif {
  case {
    // bind the macro name to `$aif_name`
    $aif_name 
    ($cond ...) {$body ...}
  } =&gt; {
    // make a new `it` identifier using the lexical context
    // from `$aif_name`
    var it = makeIdent(&quot;it&quot;, #{$aif_name});
    letstx $it = [it];
  return #{ 
      // create an IIFE that binds `$cond` to `$it`
      (function ($it) {
          if ($cond ...) {
          // all `it` identifiers in `$body` will now
          // be bound to `$it` 
          $body ...
        }
      })($cond ...);
      }
  }
}</code></pre>
<h2 id="how-do-i-output-comments"><span class="header-section-number">9.2</span> How do I output comments?</h2>
<p>Comments in a rule macro or inside a <code>#{...}</code> template should &quot;just work&quot;. If you want to create comment strings programmatically you can use a token's <code>leadingComments</code> property.</p>
<pre class="js"><code>macro m {
    case {_ () } =&gt; {
        var x = makeValue(42, #{here});
        x.token.leadingComments = [{
            type: &quot;Line&quot;,
            value: &quot;hello, world&quot;
        }];
        return withSyntax ($x = [x]) #{
            $x
        }
    }
}
m()</code></pre>
<p>will expand to</p>
<pre class="js"><code>//hello, world
42;</code></pre>
</body>
</html>
