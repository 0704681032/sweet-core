\documentclass[preprint,10pt]{sigplanconf}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{gastex}
\usepackage{graphics}
\usepackage{listings}
\usepackage{microtype}
\input{brackets}
\input{definitions}
\authorinfo{Tim Disney}{UC Santa Cruz}{}
\authorinfo{Nate Faubion}{}{}
\authorinfo{David Herman}{Mozilla}{}
\renewcommand{\author}[1]{}
\author{Tim Disney}
\date{\today}
\title{Sweet.js - Hygienic Macros for JavaScript}
\hypersetup{
  pdfkeywords={},
  pdfsubject={Sweet.js - Macros for JavaScript}}
\begin{document}

\maketitle

\section{Introduction}
\label{sec-1}

Sweet.js is a new hygienic macro system for JavaScript.

Macros systems have a long history in the design of extensible
programming languages going back at least to lisp as a tool to provide
programmers syntactic flexibility.

While powerful macro systems have been used extensively in lisp
derived languages there has been considerable less movement for macros
systems for languages with an expression based syntax such as
JavaScript. This is due to a variety of technical reasons that have
held back macro systems in expression based languages which we address
in this paper.

Recently the Honu project has shown how to overcome some of the
existing challenges in developing a macro system for expression based
language. The Honu technique was designed for an idealized JavaScript
like language. In this paper we show how to extend the ideas of Honu
for full JavaScript and present additional techniques that target
expression based languages.

The design of sweet.js attempts to overcome the following technical
challenges: 

\begin{itemize}
\item a correct implementation of \texttt{read} that structures the
  token stream before expansion begins
\item parser class annotation (e.g. \texttt{:expr}) in patterns to
  allow macro authors easier declaration of a macro shape
\item operator overloading
\item infix macros
\item the \texttt{invoke} primitive to allow custom parser classes and
  more powerful matching
\end{itemize}

\section{Overview}
\label{sec-2}
TODO: syntax, main features etc\ldots

\section{Read}
\label{sec-3}

The syntax of JavaScript presents a challenge to correctly implement
the critical \texttt{read} function. This challenge is not present in Honu
because their language is an idealized syntax that misses the
problematic interaction of delimiters and regular expression literals.

TODO: motivate \texttt{read} with examples etc.

\[
\begin{array}{rcl}
  e &::=& \var ~|~ \rett \\
  &|& \call{e}{e} \\
  &|& \ifstate{e}{e}
\end{array}
\]

\subsection{Proof of \texttt{read}}
\label{sec-3-1}

We first define a simplified grammar that captures just the essential
complexity we want to address, namely the interaction between
the division symbol \texttt{/} and the regular expression literal
\texttt{/x/}.

\[
\begin{array}{rrl}
  \Tok &::=& x ~|~ /
  \\
  \TT &::=& x ~|~ / ~|~ /x/
  \\
\end{array}
\]

We also define \( \textit{Expr}' \) with the same productions as \(
\textit{Expr} \) but defined over \( \TT^{*} \) instead of \( \Tok^{*}
\). So the terminal \( /x/ \) in the second production of \(
\textit{Expr} \) is three distinct tokens (\( /, x, \) and \( /
\)) while it is a single token in \( \textit{Expr}' \).

We define the grammar of a \( \gprod{Program}{e} \) as a function from
\( \Tok \) to \( \textit{Expr} \).

\[
\gprod{Program}{e} :: \Tok \rightarrow \textit{Expr}
\]

\begin{theorem}[\label{thrm:read}Read is correct]\mbox{}

  \( \forall s \in \Tok. s \in \gprod{Expr}{e} \) iff
  \( t = \readfn{s}{p}{0}, t \in \gprod{Expr'}{e} \).
  
\end{theorem}
\begin{proof}\mbox{}
  
By showing set inclusion. Details in the appendix.
\end{proof}

The grammar we present is a simplified version of the grammar
specified in the ES5 specification. The simplification we are making
do not affect the read algorithm, and only serve to shorten its
presentation. In particular, functions can only have a single
parameter, function bodies are not allowed to be empty and a few other
minor changes. We only address the = assignment operator and only the
/ and + binary operators.

\begin{displayfigure*}{\label{fig:grammar}Simplified ES Grammar}
\[
\begin{array}{lcl}
  \gprod{PrimaryExpression}{\var} &::=& \var 
  \\
  \gprod{PrimaryExpression}{\rett} &::=& \re 
  \\
  \gprod{PrimaryExpression}{\curlies{\var \texttt{:} e}} &::=& 
  \curlies{\var \texttt{:} \gprod{AssignmentExpression}{e}}
  \\
  \gprod{PrimaryExpression}{e} &::=& 
  \parens{\gprod{Expression}{e}}
  \\ \\
  \gprod{MemberExpression}{e} &::=&
  \gprod{PrimaryExpression}{e}
  \\
  \gprod{MemberExpression}{e} &::=&
  \gprod{FunctionExpression}{e}
  \\
  \gprod{MemberExpression}{e\texttt{.\var}} &::=&
  \gprod{MemberExpression}{e}~\texttt{.}~\var
  \\ \\
  \gprod{CallExpression}{e~\parens{e'}} &::=& 
  \gprod{MemberExpression}{e}~
  \parens{\gprod{AssignmentExpression}{e'}}
  \\
  \gprod{CallExpression}{e~\parens{e'}} &::=& 
  \gprod{CallExpression}{e}~
  \parens{\gprod{AssignmentExpression}{e'}}
  \\
  \gprod{CallExpression}{e\texttt{.\var}} &::=& 
  \gprod{CallExpression}{e}~\texttt{.}~
  \var
  \\ \\
  \gprod{BinaryExpression}{e} &::=& \gprod{CallExpression}{e} \\
  \gprod{BinaryExpression}{e ~\div~ e'}
  &::=&
  \gprod{BinaryExpression}{e} ~\div~ \gprod{BinaryExpression}{e'} \\
  \gprod{BinaryExpression}{e ~\plus~ e'}
  &::=&
  \gprod{BinaryExpression}{e} ~\plus~ \gprod{BinaryExpression}{e'}
  \\ \\
  \gprod{AssignmentExpression}{e} &::=&
  \gprod{BinaryExpression}{e}
  \\
  \gprod{AssignmentExpression}{e~\texttt{=}~e'} &::=&
  \gprod{CallExpression}{e}~\texttt{=}~
  \gprod{AssignmentExpression}{e'}
  \\ \\
  \gprod{ExpressionStatement}{e} &::=&
  \gprod{AssignmentExpression}{e} \texttt{;}
  \\ 
  &&  \textit{where lookahead \( \not =
    \texttt{\{} \) or \( \texttt{function} \)}
  \\ \\
  \gprod{ReturnStatement}{\texttt{return}~\texttt{;}} &::=&
  \texttt{return}~\texttt{;}
  \\
  \gprod{ReturnStatement}{\texttt{return}~e} &::=&
  \texttt{return}~\textrm{[no line terminator here]}~\gprod{AssignmentExpression}{e}
  \\ \\
  \gprod{Block}{\curlies{e}} &::=&
  \curlies{ \gprod{StatementList}{e} } 
  \\
  \gprod{StatementList}{e} &::=&
  \gprod{Statement}{e}
  \\
  \gprod{StatementList}{e~e'} &::=&
  \gprod{StatementList}{e}~
  \gprod{Statement}{e'}
  \\ \\
  \gprod{LabelledStatement}{\var\texttt{:}~e} &::=&
  \var~\texttt{:}~\gprod{Statement}{e}
  \\ \\
  \gprod{IfStatement}{\texttt{if}~\parens{e}~e'~\texttt{else}~e''} &::=&
  \texttt{if}~\parens{\gprod{AssignmentExpression}{e}}~\gprod{Statement}{e'}~
  \texttt{else}~\gprod{Statement}{e''}
  \\ \\
  \gprod{Statement}{e} &::=& \gprod{Block}{e}
  \\
  \gprod{Statement}{e} &::=& \gprod{ExpressionStatement}{e}
  \\
  \gprod{Statement}{e} &::=& \gprod{IfStatement}{e}
  \\
  \gprod{Statement}{e} &::=& \gprod{ReturnStatement}{e}
  \\
  \gprod{Statement}{e} &::=& \gprod{LabelledStatement}{e}
  \\ \\
  \gprod{FunctionDeclaration}{\texttt{function}~\var~\parens{\var}~\curlies{e}} 
  &::=&
  \texttt{function}~\var~\parens{\var}~
  \curlies{\gprod{SourceElements}{e}}
  \\
  \gprod{FunctionExpression}{\texttt{function}~\var~\parens{\var}~\curlies{e}} 
  &::=&
  \texttt{function}~\var~\parens{\var}~
  \curlies{\gprod{SourceElements}{e}}
  \\ \\
  \gprod{SourceElement}{e} &::=& \gprod{Statement}{e} 
  \\
  \gprod{SourceElement}{e} &::=& \gprod{FunctionDeclaration}{e}
  \\ \\

  \gprod{SourceElements}{e} &::=& \gprod{SourceElement}{e}
  \\
  \gprod{SourceElements}{e~e'} &::=& \gprod{SourceElements}{e}~\gprod{SourceElement}{e'}
  \\ \\
  \gprod{Program}{e} &::=& \gprod{SourceElements}{e}
  \\
  \gprod{Program}{} &::=& \epsilon
\end{array}
\]  
\end{displayfigure*}



\begin{displayfigure*}{\label{fig:simpleread}Simplified Read Algorithm}
\[
\begin{array}{lcl}
  \textit{Punctuator} &::=& \div ~|~ \texttt{+} ~|~ \texttt{:} ~|~
  \texttt{;} ~|~ \texttt{=} ~|~ \texttt{.}
  \\
  \textit{Keyword} &::=& \texttt{return} ~|~ \texttt{function}~|~
  \texttt{if} ~|~ \texttt{else}
  \\
  \textit{ExpressionPrefix} &::=& \texttt{=} ~|~ \div ~|~ \texttt{+}
  ~|~ \texttt{return}
  \\
  \textit{DeclarationPrefix} &::=& 
   \var ~|~ \rett ~|~ \texttt{else} ~|~ \texttt{;}
\end{array}
\]
  
\[
  \begin{array}{lcll}
    % regex
    \readfn{/\cdot x \cdot /\cdot \vtok}{\epsilon}{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{/x/}{b}
    }
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{p \cdot p'}{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{
        p \cdot p' \cdot /x/
      }{b}
    }
    \\
    && \quad\textit{if}~p' \in \textit{Punctuator or Keyword}
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{
      p \cdot \texttt{if} \cdot \parens{p'}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{p \cdot \texttt{if} \cdot \parens{p'} \cdot /x/}{b}
    }
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{
      p \cdot p' \cdot \texttt{function} \cdot \var 
      \cdot \parens{q} \cdot \curlies{q'}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{
      p \cdot p' 
      \cdot \texttt{function} \cdot \var \cdot 
      \parens{q} \cdot \curlies{q'}\cdot /x/
      }{b}
    } \\
    && \quad \textit{if}~p' \in \textit{DeclarationPrefix}
    \\
    \readfn{/\cdot x \cdot / \cdot \vtok}{
      p \cdot \curlies{q}^{l}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{
        p \cdot \curlies{q}^{l}\cdot /x/
      }{b}
    }
    \\
    && \quad \textit{where true} = \isblock(p,~b,~l)

    \\ \\

    % divide
    \readfn{/\cdot \vtok}{p\cdot x}{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p\cdot x\cdot /
      }{b}
    }
    \\
    \readfn{/\cdot \vtok}{p \cdot /x/}{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot /x/ \cdot /
      }{b}
    }
    \\
    \readfn{/\cdot \vtok}{p \cdot \parens{p'}}{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot \parens{p'} \cdot /
      }{b}
    }
    \\
    \readfn{/\cdot \vtok}{
      p \cdot p' \cdot \texttt{function}\cdot \var 
      \cdot \parens{q} \cdot \curlies{q'}
    }{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot p' \cdot \texttt{function}\cdot \var \cdot \parens{q}
        \cdot \curlies{q'} \cdot /
      }{b}
    }
    \\
    && \quad \textit{if}~p' \in \textit{ExpressionPrefix}
    \\
    \readfn{/\cdot \vtok}{
      p \cdot \curlies{q'}^{l}
    }{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot \curlies{q'}^{l} \cdot /
      }{b}
    }
    \\
    && \quad \textit{where false} = \isblock(p,~b,~l)

    \\ \\
    

    % other
    \readfn{\texttt{(} \cdot \vtok \cdot \texttt{)} \cdot \vtok'}{p}{b}
    &=&
    \cons{\parens{t}}{
      \readfn{\vtok'}{p \cdot \parens{t}}{b}
    } 
    \\
    \quad \textit{where}~s~\textit{contains no unmatched}~\texttt{)} 
    &&\quad \textit{where}~t = \readfn{s}{\epsilon}{\textit{false}} 
    \\
    \readfn{
      \texttt{\{}^l \cdot \vtok \cdot \texttt{\}} \cdot \vtok'
    }{p}{b}
    &=&
    \cons{\curlies{t}^l}{
      \readfn{\vtok'}{
        p \cdot \curlies{t}^l
      }{b}
    } 
    \\
    \quad \textit{where}~s~\textit{contains no unmatched}~\texttt{\}} 
    && \textit{where}~t = \readfn{s}{\epsilon}{\isblock(p,~b,~l)}
    % \\
    % \readfn{\texttt{function}~\var~\parens{\var}~\curlies{s}\cdot s'}{p}{b}
    % &=&
    % \texttt{function}~\var~\parens{\var}~\curlies{t}
    % \cdot
    % \readfn{s'}{p \cdot
    %   \texttt{function}~\var~\parens{\var}~\curlies{t}
    % } {b}
    % \\
    % &&\quad \textit{where}~t = \readfn{s}{\epsilon}{\textit{true}}
    \\
    \readfn{x \cdot \vtok}{p}{b}
    &=&
    \cons{x}{
      \readfn{\vtok}{p \cdot x}{b}
    }
    \\
    \readfn{\epsilon}{p}{b}
    &=&
    \epsilon \\
  \end{array}
\]
\[
  \begin{array}{lcll}
    \isblock(\epsilon,~\textit{false},~l) &=& \textit{false}
    \\
    \isblock(p \cdot \div,~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{+},~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{:},~b,~l) &=& b
    \\
    \isblock(p \cdot \texttt{return}^{l},~b,~l') &=& \textit{true} 
    & \textit{if}~l \not = l'
    \\
    \isblock(p \cdot \texttt{return}^{l},~b,~l') &=& \textit{false} 
    & \textit{if}~l = l'
    \\
    \isblock(p ,~b,~l) &=& \textit{true}
    \\
  \end{array}
\]
\end{displayfigure*}


\section{Enforestation}
\label{sec-4}

The core algorithm introduced by Honu is called \emph{enforestation} which
is basically responsible for expanding macros and building a partial
syntax tree with enough structure to match on parse classes. Sweet.js
implements this algorithm mostly as described with some additions to
provide infix macros and invoke pattern classes described below.

\subsection{Infix Macros}
\label{sec-4-1}
The macros we have described so far must all be prefixed by the macro
identifier and syntax after the macro name is matched. This is
sufficient for many kinds of macros but some syntax forms require the
macro identifier to sit between patterns.

Honu addresses this need in a limited way by providing a way to define
new binary and unary operators which during expansion can manipulate
their operators. However, those operators must be fully expanded and
must match as an expression.

Sweet.js provides \emph{infix macros} which allows a macro identifier to
match syntax before it. For example, the following implements
ES6-style arrow functions via infix macros:

\begin{verbatim}
macro (=>) {
    rule infix {
        ($params ...) | { $body ... }
    } => {
        function ($params ...) {
            $body ...
        }
    }
}

var id = (x) => { return x; }
\end{verbatim}

The macros we have described so far must all be prefixed by the macro
identifier and syntax after the macro name is matched. This is
sufficient for many kinds of macros but some syntax forms require the
macro identifier to sit between patterns.

Honu addresses this need in a limited way by providing a way to define
new binary and unary operators which during expansion can manipulate
their operators. However, those operators must be fully expanded and
must match as an expression.

Sweet.js provides \emph{infix macros} which allows a macro identifier to
match syntax before it. For example, the following implements
ES6-style arrow functions via infix macros:

\begin{verbatim}
macro (=>) {
    rule infix {
        ($params ...) | { $body ... }
    } => {
        function ($params ...) {
            $body ...
        }
    }
}
var id = (x) => { return x; }
\end{verbatim}

This is accomplished by simply providing the state of previously
expanded syntax to macro transformers. Macros may then consume from
either ends as needed, yielding new previous and subsequent syntax. At
first glance, this can appear brittle:

\begin{verbatim}
var foo = bar(x) => { return x; }
\end{verbatim}

We've juxtaposed the \verb!=>! macro next to a function call, which we did
not intend to be valid syntax. A naive expansion results in unparsable
code:

\begin{verbatim}
var foo = bar function(x) { return x; }
\end{verbatim}

In more subtle cases, a naive expansion can result in parsable code
with incorrect semantics. [Example needed?] To preserve the integrity
of previously expanded syntax, we verify that an infix macro only
matches previous syntax on boundaries delimited by the partial syntax
tree we've built. The syntax tree would show \verb!bar(x)! as a complete
function call term. Consuming the parentheses would result in a split
term and is disallowed, failing the rule. In practice, this has proven
to be an intuitive restriction. [Elaborate?]

The primary limitation of infix macros is they do not obey precedence
and associativity. They stand as a complement to Honu operators, not
as a replacement, for when an infix form does not adhere to operator
semantics, much like the \verb!=>! macro. Its left-hand-side and
right-hand-side are not arbitrary expressions but must match a
specific form. Additionally, it would need a precedence of infinity so
as to always bind tighter than other operators.

\subsection{Invoke and Pattern Classes}
\label{sec-4-2}

[Something about default pattern classes and `:expr`...]

Pattern classes are extensible via the \verb!invoke! class which is
parameterized by a macro name.

\begin{verbatim}
macro color {
  rule { red } => { red }
  rule { green } => { green }
  rule { blue } => { blue }
}
macro colors_options {
  rule { ($opt:invoke(color) ...) } => { ... }
}
\end{verbatim}

The macro is essentially inserted into the token stream. If the
expansion succeeds, the result will be loaded into the pattern
variable, otherwise the rule will fail. We've added sugar so that any
non-primitive pattern classes are interpretted as \verb!invoke!
parameterized by the custom class. We've also added identity rules to
shorten definitions of simple custom classes.

\begin{verbatim}
macro color {
  rule { red }
  rule { green }
  rule { blue }
}
macro colors_options {
  rule { ($opt:color (,) ...) } => { ... }
}
\end{verbatim}

These macros may return an optional pattern environment which will be
scoped and loaded into the invoking macro's pattern environment. This
lets us define Honu-style pattern classes as simple macro-generating
macros.

\begin{verbatim}
macro color {
  ...
}
macro number {
  ...
}
// `pattern` is just a macro-generating macro
pattern color_value { $color:color $num:number }

macro color_options {
  rule { ($opt:color_value (,) ...) } => {
    var cols = [$opt$color (,) ...];
    var nums = [$opt$num (,) ...];
  }
}

\end{verbatim}

...?

\section{Hygiene}
\label{sec-5}

Mostly straightforward implementation from scheme with some details to
handle \texttt{var}.
\section{Implementation}
\label{sec-6}
Sweet.js is written in JavaScript and runs in the major JS
environments (\ie the brower and node.js). This is in contrast to Honu
which translates its code to Racket code and reuses the hygienic
expansion machinery already built in Racket. While this simplifies
the implementation of Honu it also requires an installation of Racket
which in some cases is not feasible (\eg sweet.js is able to run in
mobile device browsers).
\section{Related Work}
\label{sec-7}

\begin{itemize}
\item Scheme/Racket
\item Honu
\item Template Haskell
\item Nemerle
\item Scala
\item Closure
\end{itemize}
\section{Conclusion}
\label{sec-8}
% Emacs 24.3.1 (Org mode 8.2.5h)

\appendix

\clearpage

\section{Read Proof}


\begin{displayfigure*}{\label{fig:read}Read Algorithm}
  
\[
  \begin{array}{lcll}
    % divide
    \readfn{/\cdot \vtok}{p\cdot x}{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p\cdot x\cdot /
      }{b}
    }
    \\
    \readfn{/\cdot \vtok}{p \cdot /x/}{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot /x/ \cdot /
      }{b}
    }
    \\
    \readfn{/\cdot \vtok}{p \cdot \texttt{function}\cdot \parens{q}
      \cdot \curlies{q'}}{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot \texttt{function}\cdot \parens{q}
        \cdot \curlies{q'} \cdot /
      }{b}
    }
    \\
    \readfn{/\cdot \vtok}{
      p \cdot p' \cdot \texttt{function}\cdot \var 
      \cdot \parens{q} \cdot \curlies{q'}
    }{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot p' \cdot \texttt{function}\cdot \var \cdot \parens{q}
        \cdot \curlies{q'} \cdot /
      }{b}
    }
    \\
    && \quad \textit{if}~p' \in \textit{ExpressionPrefix}
    \\
    \readfn{/\cdot \vtok}{
      p \cdot \curlies{q'}^{l}
    }{b}
    &=&
    \cons{/}{
      \readfn{\vtok}{
        p \cdot \curlies{q'}^{l} \cdot /
      }{b}
    }
    \\
    && \quad \textit{where false} = \isblock(p,~b,~l)

    \\ \\
    % regex
    \readfn{/\cdot x \cdot /\cdot \vtok}{\epsilon}{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{/x/}{b}
    }
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{p \cdot p'}{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{
        p \cdot p' \cdot /x/
      }{b}
    }
    \quad \textit{if}~p' \in \textit{Punctuator or Keyword}
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{
      p \cdot \texttt{if} \cdot \parens{p'}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{p \cdot \texttt{if} \cdot \parens{p'} \cdot /x/}{b}
    }
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{
      p \cdot \texttt{for} \cdot \parens{p'}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{p \cdot \texttt{for} \cdot \parens{p'} \cdot /x/}{b}
    }
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{
      p \cdot \texttt{while} \cdot \parens{p'}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{p \cdot \texttt{while} \cdot \parens{p'} \cdot /x/}{b}
    }
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{
      p \cdot \texttt{with} \cdot \parens{p'}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{p \cdot \texttt{with} \cdot \parens{p'} \cdot /x/}{b}
    }
    \\
    \readfn{/\cdot x \cdot /\cdot \vtok}{
      p \cdot p' \cdot \texttt{function} \cdot \var 
      \cdot \parens{q} \cdot \curlies{q'}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{
      p \cdot p' 
      \cdot \texttt{function} \cdot \var \cdot 
      \parens{q} \cdot \curlies{q'}\cdot /x/
      }{b}
    } \\
    && \quad \textit{if}~p' \in \textit{DeclarationPrefix}
    \\
    \readfn{/\cdot x \cdot / \cdot \vtok}{
      p \cdot \curlies{q}^{l}
    }{b}
    &=&
    \cons{/x/}{
      \readfn{\vtok}{
        p \cdot \curlies{q}^{l}\cdot /x/
      }{b}
    }
    \\
    && \quad \textit{where true} = \isblock(p,~b,~l) \\
    

    \\ \\
    
    % other
    \readfn{\texttt{(} \cdot \vtok \cdot \texttt{)} \cdot \vtok'}{p}{b}
    &=&
    \cons{\parens{t}}{
      \readfn{\vtok'}{p \cdot \parens{t}}{b}
    } 
    \\
    \quad \textit{where}~s~\textit{contains no unmatched}~\texttt{)} 
    &&\quad \textit{where}~t = \readfn{s}{\epsilon}{\textit{false}} 
    \\
    \readfn{
      \texttt{\{}^l \cdot \vtok \cdot \texttt{\}} \cdot \vtok'
    }{p}{b}
    &=&
    \cons{\curlies{t}^l}{
      \readfn{\vtok'}{
        p \cdot \curlies{t}^l
      }{b}
    } 
    \\
    \quad \textit{where}~s~\textit{contains no unmatched}~\texttt{\}} 
    && \textit{where}~t = \readfn{s}{\epsilon}{\isblock(p,~b,~l)}
    \\
    \readfn{x \cdot \vtok}{p}{b}
    &=&
    \cons{x}{
      \readfn{\vtok}{p \cdot x}{b}
    }
    \\
    \readfn{\epsilon}{p}{b}
    &=&
    \epsilon \\
  \end{array}
\]
\[
  \begin{array}{lcll}
    \isblock(\epsilon,~\textit{false},~l) &=& \textit{false}
    \\
    \isblock(p \cdot \div,~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{+},~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{:},~b,~l) &=& b
    \\
    \isblock(p \cdot \texttt{return}^{l},~b,~l') &=& \textit{true} 
    & \textit{if}~l \not = l'
    \\
    \isblock(p \cdot \texttt{return}^{l},~b,~l') &=& \textit{false} 
    & \textit{if}~l = l'
    \\
    \isblock(p \cdot \texttt{void},~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{typeof},~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{in},~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{case},~b,~l) &=& \textit{false}
    \\
    \isblock(p \cdot \texttt{delete},~b,~l) &=& \textit{false}
    \\
    \isblock(p ,~b,~l) &=& \textit{true}
    \\
  \end{array}
\]
\end{displayfigure*}



\begin{theorem}[\label{thrm:readProgram}Read Program]\mbox{}

  \( \forall s. s \in \gprod{Program}{e} \Leftrightarrow 
  \readfn{s}{\epsilon}{b} \in \gprod{Program'}{e} \)

\end{theorem}
\begin{proof}

  For the if direction, there are two cases:
  \begin{itemize}
  \item \( s \in \gprod{Program}{e} ::= \epsilon \). The result is immediate.

  \item \( s \in \gprod{Program}{e} ::= \gprod{SourceElements}{e} \)
    this holds by Lemma~\ref{lem:readSourceElements}.
  \end{itemize}

  A similar argument holds for the only if direction.
\end{proof}

\begin{lemma}[\label{lem:readSourceElements}Read SourceElements]\mbox{}

  \( \forall s. s \in \gprod{SourceElements}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{SourceElements'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction, there are two cases:
  \begin{itemize}
  \item \( s \in \gprod{SourceElements}{e} ::=
    \gprod{SourceElement}{e} \). This holds by Lemma
    \ref{lem:readSourceElement}.
    
  \item \( s \in \gprod{SourceElements}{e~e'} ::=
    \gprod{SourceElements}{e}~\gprod{SourceElement}{e'} \). We have
    \( s = s' \cdot s'' \) where \( s' \in \gprod{SourceElements}{e}
    \) and \( s'' \in \gprod{SourceElement}{e'} \).
    \[
    \begin{array}{rcl}
      t &=& \readfn{s'\cdot s''}{p}{b}
      \\
      &=& \readfn{s'}{p}{b}\cdot \readfn{s''}{p \cdot \readfn{s'}{p}{b}}{b}
    \end{array}
    \]
    \textbf{(TODO: need to say something about reading the prefix)}
    By induction \( \readfn{s'}{p}{b} \in \gprod{SourceElements'}{e} \)
    and by Lemma \ref{lem:readSourceElement}, \( \readfn{s''}{p \cdot
      \readfn{s'}{p}{b}}{b} \in \gprod{SourceElement'}{e'} \). Thus
    \( t \in \gprod{SourceElements'}{e~e'} \).
  \end{itemize}
  
  The argument is similar for the only if direction.
\end{proof}

\begin{lemma}[\label{lem:readSourceElement}Read SourceElement]\mbox{}
  
  \( \forall s. s \in \gprod{SourceElement}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{SourceElement'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction there are two cases:
  \begin{itemize}
  \item \( s \in \gprod{SourceElement}{e} ::= \gprod{Statement}{e} \).
    This holds by Lemma \ref{lem:readStatement}.
    
  \item \( s \in \gprod{SourceElement}{e} ::=
    \gprod{FunctionDeclaration}{e} \). This holds by Lemma
    \ref{lem:readFunctionDeclaration}.
  \end{itemize}
\end{proof}

\begin{lemma}[\label{lem:readFunctionDeclaration}Read FunctionDeclaration]\mbox{}
  
  \( \forall s. s \in \gprod{FunctionDeclaration}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{FunctionDeclaration'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we only have a single case: 
  \[ 
  \begin{array}{lcl}
  s \in
  \gprod{FunctionDeclaration}{\texttt{function}~\var~\parens{\var}~\curlies{e}}
  ::= 
  \\
  \texttt{function}~\var~\parens{\var}~\curlies{\gprod{SourceElements}{e}}
  \end{array}
  \]

 We have \( s = \texttt{function}~\var~\parens{\var}~\curlies{s'}
 \) where \( s' \in \gprod{SourceElements}{e} \) so:
 \[
 \begin{array}{rcl}
   t &=& \readfn{\texttt{function}~\var~\parens{\var}~\curlies{s'}}{p}{b}
   \\
   &=& \texttt{function}~\var~\parens{\var}~\curlies{t'}
 \end{array}
 \]
 where \( t' = \readfn{s'}{\epsilon}{\textit{true}} \). \textbf{TODO:
   explain why b = true}. Since by Lemma \ref{lem:readSourceElements},
 \( t' \in \gprod{SourceElements'}{e} \) we have \( t \in \gprod{FunctionDeclaration'}{\texttt{function}~\var~\parens{\var}~\curlies{e}} \).
\end{proof}

\begin{lemma}[\label{lem:readStatement}Read Statement]\mbox{}
  
  \( \forall s. s \in \gprod{Statement}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{Statement'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have several cases:
  \begin{itemize}
  \item \( s \in \gprod{Statement}{e} ::= \gprod{Block}{e} \). This
    holds by Lemma \ref{lem:readBlock}.

  \item \( s \in \gprod{Statement}{e} ::= \gprod{ExpressionStatement}{e} \). This
    holds by Lemma \ref{lem:readExpressionStatement}.

  \item \( s \in \gprod{Statement}{e} ::= \gprod{IfStatement}{e} \). This
    holds by Lemma \ref{lem:readIfStatement}.

  \item \( s \in \gprod{Statement}{e} ::= \gprod{ReturnStatement}{e} \). This
    holds by Lemma \ref{lem:readReturnStatement}.

  \item \( s \in \gprod{Statement}{e} ::= \gprod{LabelledStatement}{e} \). This
    holds by Lemma \ref{lem:readLabelledStatement}.
  \end{itemize}
\end{proof}

\begin{lemma}[\label{lem:readIfStatement}Read IfStatement]\mbox{}
  
  \( \forall s. s \in \gprod{IfStatement}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{IfStatement'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have:
  \[
  \begin{array}{lcl}
    s \in
    \gprod{IfStatement}{\texttt{if}~\parens{e}~e'~\texttt{else}~ e''} 
    ::= 
    \\
    \texttt{if}~ \parens{\gprod{AssignmentExpression}{e}}~
    \gprod{Statement}{e'}~\texttt{else}~ \gprod{Statement}{e''} 
  \end{array}
  \]
  We have \( s = \texttt{if}\cdot \parens{s'}\cdot s''\cdot
  \texttt{else}\cdot s''' \) where \( s' \in
  \gprod{AssignmentExpression}{e} \), \( s'' \in \gprod{Statement}{e'}
  \), and \( s''' \in \gprod{Statement}{e''} \).
  \[
  \begin{array}{rcl}
    t &=& \readfn{
      \texttt{if}\cdot \parens{s'}\cdot s'' \cdot \texttt{else}
      \cdot s'''
    }{p}{b}
    \\
    &=& \texttt{if} \cdot \parens{t'} \cdot t'' \cdot \texttt{else}
    \cdot t'''
  \end{array}
  \]
  where 
  \[ 
  \begin{array}{lcl}
    t' &=& \readfn{s'}{\epsilon}{b}
    \\
    t'' &=& \readfn{s''}{
      p \cdot \texttt{if} \cdot \parens{t'}
    }{b}
    \\
    t''' &=& \readfn{s'''}{
      p \cdot \texttt{if} \cdot \parens{t'}
      \cdot t'' \cdot \texttt{else}
    }{b}
  \end{array}
  \]
  By Lemma \ref{lem:readAssignmentExpression} \( t' \in
  \gprod{AssignmentExpression'}{e} \). By Lemma
  \ref{lem:readStatement}, \( t'' \in \gprod{Statement'}{e'} \) and \(
  t''' \in \gprod{Statement'}{e''} \). Thus \( t \in \gprod{IfStatement'}{\texttt{if}~\parens{e}~e'~\texttt{else}~e''} \).
\end{proof}

\begin{lemma}[\label{lem:readLabelledStatement}Read LabelledStatement]\mbox{}
  
  \( \forall s. s \in \gprod{LabelledStatement}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{LabelledStatement'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have a single case: \( s \in
  \gprod{LabelledStatement}{\var \texttt{:}~e} ::=
  \var~\texttt{:}~\gprod{Statement}{e} \). We have \( s = \var \cdot
  \texttt{:} \cdot s' \) where \( s' \in \gprod{Statement}{e} \).
  Then:
  \[
  \begin{array}{rcl}
    t &=& \readfn{\var \cdot \texttt{:} \cdot s'}{p}{b}
    \\
    &=& \var \cdot \texttt{:} \cdot 
    \readfn{s'}{
      p \cdot \var \cdot \texttt{:}
    }{b}
  \end{array}
  \]
  By Lemma \ref{lem:readStatement}, \( \readfn{s'}{p \cdot \var \cdot
    \texttt{:}}{b} \in \gprod{Statement'}{e} \) so \( t \in
  \gprod{LabelledStatement'}{\var~\texttt{:}~e} \).
  \textbf{TODO: need to take into account b and the prefix}.
\end{proof}

\begin{lemma}[\label{lem:readReturnStatement}Read ReturnStatement]\mbox{}
  
  \( \forall s. s \in \gprod{ReturnStatement}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{ReturnStatement'}{e} \)
\end{lemma}
\begin{proof}
  To show the if direction there are two cases:
  \begin{itemize}
  \item \( s \in \gprod{ReturnStatement}{\texttt{return ;}} ::=
    \texttt{return ;} \). Since \( s = \texttt{return ;} \) and \(
    \readfn{s}{p}{q} = \texttt{return}\cdot\texttt{;} \in
    \gprod{ReturnStatement'}{\texttt{return ;}} \) we have our result
    directly.

  \item \( s \in \gprod{ReturnStatement}{\texttt{return}~e} ::=
    \texttt{return}~ \gprod{AssignmentExpression}{e} \). We have \( s
    = \texttt{return}\cdot s' \) where \( s' \in
    \gprod{AssignmentExpression}{e} \). Then:
    \[
    \begin{array}{rcl}
      t &=& \readfn{\texttt{return} \cdot s'}{p}{b}
      \\
      &=& \texttt{return}\cdot \readfn{s'}{p \cdot \texttt{return}}{b}
    \end{array}
    \]
    By Lemma \ref{lem:readAssignmentExpression}, \( \readfn{s'}{p
      \cdot \texttt{return}}{b} \in \gprod{AssignmentExpression'}{e}
    \) thus \( t \in \gprod{ReturnStatement'}{\texttt{return}~e} \).
  \end{itemize}
\end{proof}

\begin{lemma}[\label{lem:readBlock}Read Block]\mbox{}
  
  \( \forall s. s \in \gprod{Block}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{Block'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have:
  \[ 
  s \in \gprod{Block}{\curlies{e}} ::= \curlies{\gprod{StatementList}{e}}
  \]
  so \( s = \curlies{s'} \) where \( s' \in \gprod{StatementList}{e} \).
  \[
  \begin{array}{rcl}
    t &=& \readfn{\curlies{s'}}{p}{b}
    \\
    &=& \curlies{t'}
  \end{array}
  \]
  where \( t' = \readfn{s'}{\epsilon}{\textit{true}} \). By Lemma
  \ref{lem:readStatementList}, \( t' \in \gprod{StatementList'}{e} \)
  so \( t \in \gprod{Block'}{\curlies{e}} \).
\end{proof}

\begin{lemma}[\label{lem:readStatementList}Read StatementList]\mbox{}

  \( \forall s. s \in \gprod{StatementList}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{StatementList'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have two cases:
  \begin{itemize}
  \item \( s \in \gprod{StatementList}{e} ::= \gprod{Statement}{e} \).
    This follows by Lemma \ref{lem:readStatement}.

  \item \( s \in \gprod{StatementList}{e~e'} ::=
    \gprod{StatementList}{e}~ \gprod{Statement}{e'} \). So 
    \( s = s' \cdot s'' \) where \( s' \in \gprod{StatementList}{e} \)
    and \( s'' \in \gprod{Statement}{e'} \). Then,
    \[
    \begin{array}{rcl}
      t &=& \readfn{s' \cdot s''}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot \readfn{s''}{p \cdot \readfn{s'}{p}{b}}{b}
    \end{array}
    \]
    By induction \( \readfn{s'}{p}{b} \in \gprod{StatementList'}{e} \)
    and by Lemma \ref{lem:readStatement}, \( \readfn{s''}{p \cdot
      \readfn{s'}{p}{b}}{b} \in \gprod{Statement'}{e'} \).
    Thus, \( t \in \gprod{StatementList'}{e~e'} \).
  \end{itemize}
\end{proof}

\begin{lemma}[\label{lem:readExpressionStatement}Read ExpressionStatement]\mbox{}
  
  \( \forall s. s \in \gprod{ExpressionStatement}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{ExpressionStatement'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have 
  \( s \in \gprod{ExpressionStatement}{e} ::=
  \gprod{AssignmentExpression}{e}~\texttt{;} \) so \( s = s' \cdot
  \texttt{;} \) where \( s' \in \gprod{AssignmentExpression}{e} \).
  Then:
  \[
  \begin{array}{rcl}
    t &=& \readfn{s'\cdot \texttt{;}}{p}{b}
    \\
    &=& \readfn{s'}{p}{b} \cdot \texttt{;}
  \end{array}
  \]
  Since by Lemma \ref{lem:readAssignmentExpression}, \(
  \readfn{s'}{p}{b} \in \gprod{AssignmentExpression'}{e} \) we have
  \( t \in \gprod{ExpressionStatement'}{e} \).
\end{proof}

\begin{lemma}[\label{lem:readAssignmentExpression}Read AssignmentExpression]\mbox{}
  
  \( \forall s. s \in \gprod{AssignmentExpression}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{AssignmentExpression'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have two cases:
  \begin{itemize}
  \item \( s \in \gprod{AssignmentExpression}{e} ::=
    \gprod{BinaryExpression}{e} \). This holds by Lemma
    \ref{lem:readBinaryExpression}.
    
  \item \( s \in \gprod{AssignmentExpression}{e~\texttt{=}~e'} \) by
    \[ 
    \gprod{CallExpression}{e} ~\texttt{=}~
    \gprod{AssignmentExpression}{e'} 
    \]
    Then \( s = s' \cdot \texttt{=} \cdot s'' \) where \( s' \in
    \gprod{CallExpression}{e} \) and \( s'' \in
    \gprod{AssignmentExpression}{e'} \). Then:
    \[
    \begin{array}{rcl}
      t &=& \readfn{s' \cdot \texttt{=} \cdot s''}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot \texttt{=} \cdot
      \readfn{s''}{p \cdot \readfn{s'}{p}{b} \cdot \texttt{=}}{b}
    \end{array}
    \]
    By Lemma \ref{lem:readCallExpression}, \( \readfn{s'}{p}{b} \in
    \gprod{CallExpression'}{e} \) and by induction \( \readfn{s''}{p
      \cdot \readfn{s'}{p}{b} \cdot \texttt{=}}{b} \in
    \gprod{AssignmentExpression'}{e'} \) so \( t \in
    \gprod{AssignmentExpression'}{e~\texttt{=}~e'} \).
  \end{itemize}
\end{proof}

\begin{lemma}[\label{lem:readBinaryExpression}Read BinaryExpression]\mbox{}
  
  \( \forall s. s \in \gprod{BinaryExpression}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{BinaryExpression'}{e} \)
\end{lemma}
\begin{proof}
  To show the if direction we have three cases:
  \begin{itemize}
  \item \( s \in \gprod{BinaryExpression}{e} ::=
    \gprod{CallExpression}{e} \). This holds by Lemma
    \ref{lem:readCallExpression}.

  \item \( s \in \gprod{BinaryExpression}{e~\div~e'} \) by 
    \[
    \gprod{BinaryExpression}{e} ~\div~ \gprod{BinaryExpression}{e'} 
    \]
    We have \( s = s' \cdot \div \cdot s'' \) where \( s' \in
    \gprod{BinaryExpression}{e} \) and \( s'' \in
    \gprod{BinaryExpression}{e'} \). Then:
    \[
    \begin{array}{rcl}
      t &=& \readfn{s'\cdot \div \cdot s''}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot \div \cdot 
      \readfn{s''}{
        p \cdot \readfn{s'}{p}{b} \cdot \div
      }{b}
    \end{array}
    \]
    \textbf{TODO: since reasons}.
    By induction \( \readfn{s'}{p}{b} \in \gprod{BinaryExpression'}{e} \)
    and \( 
      \readfn{s''}{
        p \cdot \readfn{s'}{p}{b} \cdot \div
      }{b} \in \gprod{BinaryExpression'}{e'}
      \) thus \( t \in \gprod{BinaryExpression'}{e~\div~e'} \).

  \item \( s \in \gprod{BinaryExpression}{e~\texttt{+}~e'} \) by 
    \[
    \gprod{BinaryExpression}{e} ~\texttt{+}~ \gprod{BinaryExpression}{e'} 
    \]
    We have \( s = s' \cdot \texttt{+} \cdot s'' \) where \( s' \in
    \gprod{BinaryExpression}{e} \) and \( s'' \in
    \gprod{BinaryExpression}{e'} \). Then:
    \[
    \begin{array}{rcl}
      t &=& \readfn{s'\cdot \texttt{+} \cdot s''}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot \texttt{+} \cdot 
      \readfn{s''}{
        p \cdot \readfn{s'}{p}{b} \cdot \texttt{+}
      }{b}
    \end{array}
    \]
    \textbf{TODO: since reasons}.
    By induction \( \readfn{s'}{p}{b} \in \gprod{BinaryExpression'}{e} \)
    and \( 
      \readfn{s''}{
        p \cdot \readfn{s'}{p}{b} \cdot \texttt{+}
      }{b} \in \gprod{BinaryExpression'}{e'}
      \) thus \( t \in \gprod{BinaryExpression'}{e~\texttt{+}~e'} \).
  \end{itemize}
\end{proof}

\begin{lemma}[\label{lem:readCallExpression}Read CallExpression]\mbox{}
  
  \( \forall s. s \in \gprod{CallExpression}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{CallExpression'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have three cases:
  \begin{itemize}
  \item \( s \in \gprod{CallExpression}{e~\parens{e'}} \) by
    \[
    \gprod{MemberExpression}{e}~\parens{\gprod{AssignmentExpression'}{e'}}
    \]
    We have \( s = s' \cdot \parens{s''} \) where \( s' \in
    \gprod{MemberExpression}{e} \) and \( s'' \in
    \gprod{AssignmentExpression}{e'} \). Then
    \[
    \begin{array}{rcl}
      t &=& \readfn{s' \cdot \parens{s''}}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot
      \readfn{\parens{s''}}{
        p \cdot \readfn{s'}{p}{b}
      }{b}
    \end{array}
    \]
    By Lemma \ref{lem:readMemberExpression} we have \(
    \readfn{s'}{p}{b} \in \gprod{MemberExpression'}{e} \) and my Lemma
    \ref{lem:readAssignmentExpression} we have
    \(\readfn{s''}{\epsilon}{\textit{false}} \in
    \gprod{AssignmentExpression'}{e'} \) thus
    \( t \in \gprod{CallExpression'}{e~\parens{e'}} \).

  \item \( s \in \gprod{CallExpression}{e\texttt{.\var}} ::=
    \gprod{CallExpression}{e} ~\texttt{.} ~\var \). Then
    \( s = s' \cdot \texttt{.}\cdot \var \) where \( s' \in
    \gprod{CallExpression}{e} \). Then
    \[
    \begin{array}{rcl}
      t &=& \readfn{s' \cdot \texttt{.} \cdot \var}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot \texttt{.}\cdot \var
    \end{array}
    \]
    By induction \( \readfn{s'}{p}{b} \in \gprod{CallExpression'}{e}
    \). Thus \( t \in \gprod{CallExpression'}{e~\texttt{.\var}} \).
  \end{itemize}
\end{proof}

\begin{lemma}[\label{lem:readMemberExpression}Read MemberExpression]\mbox{}

  \( \forall s. s \in \gprod{MemberExpression}{e} \Leftrightarrow 
  \readfn{s}{p}{b} \in \gprod{MemberExpression'}{e} \)
\end{lemma}
\begin{proof}
  For the if direction we have three cases:
  \begin{itemize}
  \item \( s \in \gprod{MemberExpression}{e} ::=
    \gprod{PrimaryExpression}{e} \). This follows from Lemma
    \ref{lem:readPrimaryExpression}.
    
  \item \( s \in \gprod{MemberExpression}{e} ::=
    \gprod{FunctionExpression}{e} \). This follows from Lemma
    \ref{lem:readFunctionExpression}.
    
  \item \( s \in \gprod{MemberExpression}{e\texttt{.\var}} ::=
    \gprod{MemberExpression}{e} ~\texttt{.}~\var \). We have 
    \( s = s' \cdot \texttt{.} \var \) where \( s \in
    \gprod{MemberExpression}{e} \). Then
    \[
    \begin{array}{rcl}
      t &=& \readfn{s' \cdot \texttt{.} \cdot \var}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot \texttt{.} \cdot \var
    \end{array}
    \]
    By induction \( \readfn{s'}{p}{b} \in \gprod{MemberExpression'}{e}
    \) thus \( t \in \gprod{MemberExpression'}{e\texttt{.\var}} \).
  \end{itemize}
\end{proof}


\begin{lemma}[\label{lem:readunit}Reading a Unit]\mbox{}

  \( s \in \textit{ReadUnit} \Rightarrow \)
\[
  \readfn{s\cdot s'}{p}{b} = 
  \readfn{s}{p}{b} \cdot \readfn{s'}{p \cdot \readfn{s}{p}{b}}{b}
\] 
\end{lemma}

\begin{lemma}[\label{lem:endingofexpr}Reading the end of an expr]\mbox{}

  \( s \in \gprod{Expr}{e} \Rightarrow p \cdot \readfn{s}{p}{b} \in \divprefix \)
\end{lemma}

\begin{lemma}
  \( s \in \gprod{Expr}{e} \Rightarrow s \in \textit{ReadUnit} \)
\end{lemma}

\begin{lemma}[\label{lem:readExpr}Read Expr]\mbox{}
  
  \( \forall s,~p. ~p \not \in \divprefix \)

  \( s \in \gprod{Expr}{e} \Leftrightarrow \readfn{s}{p}{b} \in \gprod{Expr'}{e} \)
\end{lemma}
\begin{proof}
  
  By cases of \( \gprod{Expr}{e} \):

  \begin{itemize}

  \item Case \(\gprod{Expr}{e~\div~e'} ::= \gprod{Expr}{e} ~\div~ \gprod{Expr}{e'} \).
    From this \( s = s' \cdot \div \cdot s'' \) where \( s' \in
    \gprod{Expr}{e} \) and \( s'' \in \gprod{Expr}{e'} \). So
    \[
    \begin{array}{rcl}
      t &=& \readfn{s' \cdot \div \cdot s''}{p}{b}
      \\
      &=& \readfn{s'}{p}{b} \cdot \readfn{\div \cdot s''}{
        p\cdot \readfn{s'}{p}{b}
      }{b}
      \\
      &&\textrm{(by Lemma \ref{lem:readunit} since \( s' \in \textit{ReadUnit} \))}
      \\
      &=& \readfn{s'}{p}{b} \cdot \div \cdot 
      \readfn{s''}{
        p\cdot \readfn{s'}{p}{b} \cdot \div
      }{b}
      \\
      &&\textrm{(since by Lemma \ref{lem:endingofexpr}, \(
        \readfn{s'}{p}{b} \in \divprefix \))}
      \\
    \end{array}
    \]
    By induction \( \readfn{s'}{p}{b} \in \gprod{Expr'}{e} \) and
    \( 
      \readfn{s''}{
        p\cdot \readfn{s'}{p}{b} \cdot \div
      }{b} \in \gprod{Expr'}{e'}
      \) so \( t \in \gprod{Expr'}{e ~\div~ e'} \).

  \end{itemize}
\end{proof}

\end{document}